{
  "task_id": "cf_58832",
  "entry_point": "maxProbability",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [0] / n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] / n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [0] + n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] + n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [0] ** n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] ** n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_prob[start] = 1",
      "mutated_line": "max_prob[start] = 2",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 2\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_prob[start] = 1",
      "mutated_line": "max_prob[start] = 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 0\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_prob[start] = 1",
      "mutated_line": "max_prob[start] = 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 0\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_prob[start] = 1",
      "mutated_line": "max_prob[start] = -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = -1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "prob = -prob",
      "mutated_line": "prob = +prob",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = +prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if prob < max_prob[node]: # Skip because we have already found a better way",
      "mutated_line": "if prob <= max_prob[node]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob <= max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if prob < max_prob[node]: # Skip because we have already found a better way",
      "mutated_line": "if prob >= max_prob[node]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob >= max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if prob < max_prob[node]: # Skip because we have already found a better way",
      "mutated_line": "if prob != max_prob[node]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob != max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [1] * n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [1] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [-1] * n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [-1] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "max_prob = [0] * n",
      "mutated_line": "max_prob = [1] * n",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [1] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "pq = [(-1, start)]  # Use negative prob to sort max first",
      "mutated_line": "pq = [(+1, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(+1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "new_prob = prob * neighbor_prob",
      "mutated_line": "new_prob = prob / neighbor_prob",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob / neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "new_prob = prob * neighbor_prob",
      "mutated_line": "new_prob = prob + neighbor_prob",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob + neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "new_prob = prob * neighbor_prob",
      "mutated_line": "new_prob = prob ** neighbor_prob",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob ** neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_prob > max_prob[neighbor]:",
      "mutated_line": "if new_prob >= max_prob[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob >= max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_prob > max_prob[neighbor]:",
      "mutated_line": "if new_prob <= max_prob[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob <= max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if new_prob > max_prob[neighbor]:",
      "mutated_line": "if new_prob != max_prob[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob != max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pq = [(-1, start)]  # Use negative prob to sort max first",
      "mutated_line": "pq = [(-2, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-2, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pq = [(-1, start)]  # Use negative prob to sort max first",
      "mutated_line": "pq = [(-0, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-0, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pq = [(-1, start)]  # Use negative prob to sort max first",
      "mutated_line": "pq = [(-0, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-0, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pq = [(-1, start)]  # Use negative prob to sort max first",
      "mutated_line": "pq = [(--1, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(--1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n    return max_prob[end]"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "heapq.heappush(pq, (-new_prob, neighbor))",
      "mutated_line": "heapq.heappush(pq, (+new_prob, neighbor))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for ((src, dst), prob) in zip(edges, succProb):\n        graph[src].append((dst, prob))\n        graph[dst].append((src, prob))\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n    while pq:\n        (prob, node) = heapq.heappop(pq)\n        prob = -prob\n        if prob < max_prob[node]:\n            continue\n        for (neighbor, neighbor_prob) in graph[node]:\n            new_prob = prob * neighbor_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (+new_prob, neighbor))\n    return max_prob[end]"
    }
  ]
}