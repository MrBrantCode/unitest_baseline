{
  "task_id": "cf_40537",
  "entry_point": "find_shortest_path",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (x, y) == goal:",
      "mutated_line": "if (x, y) != goal:",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) != goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows or 0 <= new_y < cols or grid[new_x][new_y] == 0 or ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows or 0 <= new_y < cols or grid[new_x][new_y] == 0 or ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x - dx, y + dy)",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x - dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x * dx, y + dy)",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x * dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y - dy)",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y - dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y * dy)",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y * dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 < new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 < new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 > new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 > new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 == new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 == new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 < new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 < new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 > new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 > new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 == new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 == new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] != 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if -1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if -1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and -1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and -1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 1 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 1) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 1) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == -1) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == -1) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == 0 and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 1) and ((new_x, new_y) not in visited):",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 1) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append(((new_x, new_y), path + [(new_x, new_y)]))",
      "mutated_line": "queue.append(((new_x, new_y), path - [(new_x, new_y)]))",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path - [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append(((new_x, new_y), path + [(new_x, new_y)]))",
      "mutated_line": "queue.append(((new_x, new_y), path * [(new_x, new_y)]))",
      "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == goal:\n            return path\n        for (dx, dy) in directions:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == 0) and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path * [(new_x, new_y)]))\n                visited.add((new_x, new_y))\n    return []"
    }
  ]
}