{
  "task_id": "cf_36890",
  "entry_point": "generate_pcm_data",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq1 = 440  # Frequency of the first sine wave component (e.g., A4 note)",
      "mutated_line": "freq1 = 441",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 441\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq1 = 440  # Frequency of the first sine wave component (e.g., A4 note)",
      "mutated_line": "freq1 = 439",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 439\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq1 = 440  # Frequency of the first sine wave component (e.g., A4 note)",
      "mutated_line": "freq1 = 0",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 0\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq1 = 440  # Frequency of the first sine wave component (e.g., A4 note)",
      "mutated_line": "freq1 = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 1\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "freq1 = 440  # Frequency of the first sine wave component (e.g., A4 note)",
      "mutated_line": "freq1 = -440",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = -440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "freq2 = 660  # Frequency of the second sine wave component (e.g., E5 note)",
      "mutated_line": "freq2 = 661",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 661\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "freq2 = 660  # Frequency of the second sine wave component (e.g., E5 note)",
      "mutated_line": "freq2 = 659",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 659\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "freq2 = 660  # Frequency of the second sine wave component (e.g., E5 note)",
      "mutated_line": "freq2 = 0",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 0\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "freq2 = 660  # Frequency of the second sine wave component (e.g., E5 note)",
      "mutated_line": "freq2 = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 1\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "freq2 = 660  # Frequency of the second sine wave component (e.g., E5 note)",
      "mutated_line": "freq2 = -660",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = -660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fade = 0.5   # Amplitude fade factor",
      "mutated_line": "fade = 1.5",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 1.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fade = 0.5   # Amplitude fade factor",
      "mutated_line": "fade = -0.5",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = -0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fade = 0.5   # Amplitude fade factor",
      "mutated_line": "fade = 0",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fade = 0.5   # Amplitude fade factor",
      "mutated_line": "fade = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 1\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fade = 0.5   # Amplitude fade factor",
      "mutated_line": "fade = -0.5",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = -0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sampRate = 44100  # Sample rate in Hz",
      "mutated_line": "sampRate = 44101",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44101\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sampRate = 44100  # Sample rate in Hz",
      "mutated_line": "sampRate = 44099",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44099\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sampRate = 44100  # Sample rate in Hz",
      "mutated_line": "sampRate = 0",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 0\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sampRate = 44100  # Sample rate in Hz",
      "mutated_line": "sampRate = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 1\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sampRate = 44100  # Sample rate in Hz",
      "mutated_line": "sampRate = -44100",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = -44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "phase = 0    # Phase offset",
      "mutated_line": "phase = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 1\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "phase = 0    # Phase offset",
      "mutated_line": "phase = -1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = -1\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "phase = 0    # Phase offset",
      "mutated_line": "phase = 1",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 1\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data -= struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data -= struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return pcm_data * numCh",
      "mutated_line": "return pcm_data / numCh",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data / numCh"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return pcm_data * numCh",
      "mutated_line": "return pcm_data + numCh",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data + numCh"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return pcm_data * numCh",
      "mutated_line": "return pcm_data ** numCh",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data ** numCh"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 * (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 + peakLevel / 20\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 11 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 9 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 0 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 1 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = -10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel * 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel // 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level / (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level / (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level + (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level + (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int((fade * level) ** (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int((fade * level) ** (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' - ('h' if sampWidth == 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' - ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' * ('h' if sampWidth == 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' * ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 21)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 19)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 0)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 1)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "level = 10 ** (peakLevel / 20)  # Convert peak level from dB to linear scale",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / -20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade / level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade / level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int((fade + level) * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int((fade + level) * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade ** level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade ** level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) - 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) - 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) * (0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase))))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) * (0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase))))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('' + ('h' if sampWidth == 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 / math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 / math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 + math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 + math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 ** math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 ** math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 / math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 / math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + (0.5 + math.sin(freq2 * 2 * math.pi * i / sampRate + phase))))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + (0.5 + math.sin(freq2 * 2 * math.pi * i / sampRate + phase))))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 ** math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 ** math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth != 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth != 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('' if sampWidth == 16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else ''), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else ''), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (1.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (1.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (-0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (-0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (1 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (1 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (-0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (-0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 1.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 1.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + -0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + -0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 1 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 1 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + -0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + -0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 17 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 17 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 15 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 15 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 0 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 0 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 1 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 1 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)",
      "mutated_line": "pcm_data += struct.pack('<' + ('h' if sampWidth == -16 else 'B'), sample)",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == -16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate - phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate - phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate * phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate * phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate - phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate - phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate * phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate * phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i * sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i * sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i // sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i // sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i * sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i * sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i // sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i // sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi / i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi / i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin((freq1 * 2 * math.pi + i) / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin((freq1 * 2 * math.pi + i) / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin((freq1 * 2 * math.pi) ** i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin((freq1 * 2 * math.pi) ** i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi / i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi / i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 * math.pi + i) / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 * math.pi + i) / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 * math.pi) ** i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 * math.pi) ** i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 / math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 / math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin((freq1 * 2 + math.pi) * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin((freq1 * 2 + math.pi) * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin((freq1 * 2) ** math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin((freq1 * 2) ** math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 / math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 / math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 + math.pi) * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2 + math.pi) * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2) ** math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 * 2) ** math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 / 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 / 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin((freq1 + 2) * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin((freq1 + 2) * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 ** 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 ** 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 / 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 / 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 + 2) * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin((freq2 + 2) * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 ** 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 ** 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 3 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 3 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 1 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 1 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 0 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 0 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 1 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 1 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sample = int((fade * level * (0.5 * math.sin((freq1 * 2 * math.pi * i) / sampRate + phase) +",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * -2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * -2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 3 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 3 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 1 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 1 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 0 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 0 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 1 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * 1 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "0.5 * math.sin((freq2 * 2 * math.pi * i) / sampRate + phase))))",
      "mutated_line": "sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * -2 * math.pi * i / sampRate + phase)))",
      "code": "import math\nimport struct\n\ndef generate_pcm_data(numCh, peakLevel, sampWidth):\n    freq1 = 440\n    freq2 = 660\n    fade = 0.5\n    sampRate = 44100\n    phase = 0\n    pcm_data = b''\n    for i in range(sampRate):\n        level = 10 ** (peakLevel / 20)\n        sample = int(fade * level * (0.5 * math.sin(freq1 * 2 * math.pi * i / sampRate + phase) + 0.5 * math.sin(freq2 * -2 * math.pi * i / sampRate + phase)))\n        pcm_data += struct.pack('<' + ('h' if sampWidth == 16 else 'B'), sample)\n    return pcm_data * numCh"
    }
  ]
}