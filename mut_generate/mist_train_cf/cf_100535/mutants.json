{
  "task_id": "cf_100535",
  "entry_point": "minMeetingRooms",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_rooms = 0",
      "mutated_line": "min_rooms = 1",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 1\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_rooms = 0",
      "mutated_line": "min_rooms = -1",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = -1\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_rooms = 0",
      "mutated_line": "min_rooms = 1",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 1\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap or min_heap[0] <= interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap or min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] < interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] < interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] > interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] > interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] == interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] == interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heapq.heappush(min_heap, interval[1])",
      "mutated_line": "heapq.heappush(min_heap, interval[2])",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[2])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heapq.heappush(min_heap, interval[1])",
      "mutated_line": "heapq.heappush(min_heap, interval[0])",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[0])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heapq.heappush(min_heap, interval[1])",
      "mutated_line": "heapq.heappush(min_heap, interval[0])",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[0])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heapq.heappush(min_heap, interval[1])",
      "mutated_line": "heapq.heappush(min_heap, interval[-1])",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[-1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[1] <= interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[1] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[-1] <= interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[-1] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[1] <= interval[0]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[1] <= interval[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] <= interval[1]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[1]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] <= interval[-1]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[-1]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while min_heap and min_heap[0] <= interval[0]:",
      "mutated_line": "while min_heap and min_heap[0] <= interval[1]:",
      "code": "import heapq\n\ndef minMeetingRooms(intervals):\n    intervals.sort()\n    min_heap = []\n    min_rooms = 0\n    for interval in intervals:\n        while min_heap and min_heap[0] <= interval[1]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, interval[1])\n        min_rooms = max(min_rooms, len(min_heap))\n    return min_rooms"
    }
  ]
}