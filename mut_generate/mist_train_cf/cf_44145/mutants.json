{
  "task_id": "cf_44145",
  "entry_point": "minimum_intervals",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "end = float('-inf')",
      "mutated_line": "end = float('')",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[0] >= end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] >= end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[0] <= end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] <= end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[0] != end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] != end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[1] >= end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] >= end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[1] <= end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] <= end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[1] != end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] != end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[1] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[1] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[-1] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[-1] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if interval[0] > end:",
      "mutated_line": "if interval[1] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[1] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[2]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[2]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[0]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[0]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[-1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[-1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda interval: interval[0])",
      "mutated_line": "intervals.sort(key=lambda interval: interval[1])",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[1])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda interval: interval[0])",
      "mutated_line": "intervals.sort(key=lambda interval: interval[-1])",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[-1])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda interval: interval[0])",
      "mutated_line": "intervals.sort(key=lambda interval: interval[1])",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[1])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[2] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[2] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[0] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[0] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[0] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[0] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif interval[1] > end:",
      "mutated_line": "elif interval[-1] > end:",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[-1] > end:\n            res[-1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][2] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][2] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][0] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][0] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][0] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][0] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][-1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][-1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][1] = interval[2]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[2]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][1] = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[0]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][1] = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[0]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-1][1] = interval[-1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[-1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[2]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[2]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[0]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[0]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[0]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "end = interval[1]",
      "mutated_line": "end = interval[-1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-1][1] = interval[1]\n            end = interval[-1]\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[+1][1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[+1][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-2][1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-2][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-0][1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-0][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[-0][1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[-0][1] = interval[1]\n            end = interval[1]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res[-1][1] = interval[1]",
      "mutated_line": "res[--1][1] = interval[1]",
      "code": "def minimum_intervals(intervals):\n    intervals.sort(key=lambda interval: interval[0])\n    res = []\n    end = float('-inf')\n    for interval in intervals:\n        if interval[0] > end:\n            res.append(interval)\n            end = interval[1]\n        elif interval[1] > end:\n            res[--1][1] = interval[1]\n            end = interval[1]\n    return res"
    }
  ]
}