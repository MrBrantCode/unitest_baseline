{
  "task_id": "cf_71833",
  "entry_point": "entance",
  "mutant_count": 142,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return False\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root - 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root - 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root * 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root * 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root - 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root - 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root * 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root * 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left < n or heap[left] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n or heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right < n or heap[right] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n or heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if largest != root:",
      "mutated_line": "if largest == root:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest == root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) + 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) + 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) * 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) * 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, +1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, +1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, +1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, +1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i - 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i - 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i * 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i * 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while j < n:",
      "mutated_line": "while j <= n:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j <= n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while j < n:",
      "mutated_line": "while j >= n:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j >= n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while j < n:",
      "mutated_line": "while j != n:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j != n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j /= 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j /= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) + 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) + 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) * 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) * 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, +1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, +1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, +1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, +1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 / root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 / root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 + root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 + root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 ** root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 ** root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 2\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root + 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 0\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root + 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 0\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 2 * root + -1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + -1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 / root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 / root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 + root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 + root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 ** root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 ** root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root + 3",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 3\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 1\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root + 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 0\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 1\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 2 * root + -2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + -2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left <= n and heap[left] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left <= n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left >= n and heap[left] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left >= n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left != n and heap[left] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left != n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left < n and heap[left] >= heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] >= heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left < n and heap[left] <= heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] <= heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if left < n and heap[left] > heap[largest]:",
      "mutated_line": "if left < n and heap[left] != heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] != heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right <= n and heap[right] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right <= n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right >= n and heap[right] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right >= n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right != n and heap[right] > heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right != n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right < n and heap[right] >= heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] >= heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right < n and heap[right] <= heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] <= heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if right < n and heap[right] > heap[largest]:",
      "mutated_line": "if right < n and heap[right] != heap[largest]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] != heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 2, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 2, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 0, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 0, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 0, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 0, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - -1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - -1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -2, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -2, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -0, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -0, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -0, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -0, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, --1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, --1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -2):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -2):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -0):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -0):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -0):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -0):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, --1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, --1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 / i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 / i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 + i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 + i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 ** i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 ** i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 2\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i + 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 0\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i + 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 0\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 2 * i + -1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + -1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n or heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n or heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j -= 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if heap[i] < heap[j]:",
      "mutated_line": "if heap[i] <= heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] <= heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if heap[i] < heap[j]:",
      "mutated_line": "if heap[i] >= heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] >= heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if heap[i] < heap[j]:",
      "mutated_line": "if heap[i] != heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] != heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j *= 3",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 3\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j *= 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 1\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j *= 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 0\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j *= 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 1\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j *= 2",
      "mutated_line": "j *= -2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= -2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 2, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 2, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 0, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 0, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 0, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 0, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - -1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - -1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -2, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -2, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -0, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -0, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -0, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -0, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, --1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, --1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -2):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -2):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -0):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -0):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, -0):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -0):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 2) - 1, -1, --1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, --1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 3 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 3 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 1 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 1 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 0 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 0 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = 1 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 1 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "left = 2 * root + 1",
      "mutated_line": "left = -2 * root + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = -2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 3 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 3 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 1 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 1 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 0 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 0 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = 1 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 1 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right = 2 * root + 2",
      "mutated_line": "right = -2 * root + 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = -2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n * 2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n * 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n // 2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n // 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 3 * i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 3 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 1 * i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 1 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 0 * i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 0 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = 1 * i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 1 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "j = 2 * i + 1",
      "mutated_line": "j = -2 * i + 1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = -2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 <= n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 <= n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 >= n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 >= n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 != n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 != n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 1] >= heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] >= heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 1] <= heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] <= heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 1] != heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] != heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 2\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 0\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 0\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += -1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return True\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n * 2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n * 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n // 2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n // 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 3) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 3) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 1) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 1) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 0) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 0) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 1) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 1) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / -2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / -2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j - 1 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j - 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j * 1 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j * 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 3) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 3) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 1) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 1) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 0) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 0) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / 1) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 1) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(int(n/2)-1, -1, -1):",
      "mutated_line": "for i in range(int(n / -2) - 1, -1, -1):",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / -2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 2 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 2 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 0 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 0 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 0 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 0 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + -1 < n and heap[j + 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + -1 < n and heap[j + 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j - 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j - 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j * 1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j * 1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 2] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 2] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 0] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 0] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + 0] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + 0] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if j + 1 < n and heap[j+1] > heap[j]:",
      "mutated_line": "if j + 1 < n and heap[j + -1] > heap[j]:",
      "code": "def entance(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        j = 2 * i + 1\n        while j < n:\n            if j + 1 < n and heap[j + -1] > heap[j]:\n                j += 1\n            if heap[i] < heap[j]:\n                return False\n            j *= 2\n    return True\n\ndef buildMaxHeap(heap):\n    n = len(heap)\n    for i in range(int(n / 2) - 1, -1, -1):\n        heapify(heap, i, n)\n    return heap\n\ndef heapify(heap, root, n):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < n and heap[left] > heap[largest]:\n        largest = left\n    if right < n and heap[right] > heap[largest]:\n        largest = right\n    if largest != root:\n        (heap[root], heap[largest]) = (heap[largest], heap[root])\n        heapify(heap, largest, n)"
    }
  ]
}