{
  "task_id": "cf_65929",
  "entry_point": "compute_U",
  "mutant_count": 363,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "res = 0.0",
      "mutated_line": "res = 1.0",
      "code": "def compute_U(N):\n    res = 1.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "res = 0.0",
      "mutated_line": "res = -1.0",
      "code": "def compute_U(N):\n    res = -1.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "res = 0.0",
      "mutated_line": "res = 1",
      "code": "def compute_U(N):\n    res = 1\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "res += max(probs[n][n]) - min(probs[n][n])",
      "mutated_line": "res -= max(probs[n][n]) - min(probs[n][n])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res -= max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(4, N + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(4, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(2, N + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(2, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(0, N + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(0, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(1, N + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(1, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(-3, N + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(-3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N - 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N - 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N * 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N * 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "res += max(probs[n][n]) - min(probs[n][n])",
      "mutated_line": "res += max(probs[n][n]) + min(probs[n][n])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) + min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "res += max(probs[n][n]) - min(probs[n][n])",
      "mutated_line": "res += max(probs[n][n]) * min(probs[n][n])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) * min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return round(res, 8)",
      "mutated_line": "return round(res, 9)",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 9)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return round(res, 8)",
      "mutated_line": "return round(res, 7)",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 7)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return round(res, 8)",
      "mutated_line": "return round(res, 0)",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return round(res, 8)",
      "mutated_line": "return round(res, 1)",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return round(res, 8)",
      "mutated_line": "return round(res, -8)",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, -8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N + 2):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 2):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 0):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 0):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(3, N+1):",
      "mutated_line": "for n in range(3, N + -1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + -1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(2, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(0, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(0, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(-1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n - 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n * 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 2):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 0):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 0):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n+1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + -1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n - 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n - 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n * 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n * 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[1.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[1.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[-1.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[-1.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[1, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[1, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 1.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 1.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, -1.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, -1.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 1, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 1, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 1.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 1.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, -1.0] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, -1.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 1] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 1] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n - 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n - 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n * 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n * 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n + 2):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 2):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 0):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n + 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 0):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, n+1):",
      "mutated_line": "for j in range(i, n + -1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + -1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(2, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(2, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(0, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(0, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(-1, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(-1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 6):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 6):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 4):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 4):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 0):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 1):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, -5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, -5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i <= k:",
      "mutated_line": "if i < k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i < k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i <= k:",
      "mutated_line": "if i > k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i > k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i <= k:",
      "mutated_line": "if i == k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i == k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] -= 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] -= 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] -= p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] -= p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] -= p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] -= p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] -= p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] -= p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(2, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(2, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(0, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(0, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(-1, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(-1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 6):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 6):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 4):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 4):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 0):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 1):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, -5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, -5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j <= k:",
      "mutated_line": "if j < k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j < k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j <= k:",
      "mutated_line": "if j > k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j > k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j <= k:",
      "mutated_line": "if j == k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j == k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] -= 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] -= 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] -= p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] -= p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] -= p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] -= p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] -= p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] -= p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(2, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(2, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(0, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(0, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(0, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(-1, 5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(-1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 6):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 6):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 4):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 4):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 0):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 0):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, 1):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 1):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(1, 5):",
      "mutated_line": "for k in range(1, -5):",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, -5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= k:",
      "mutated_line": "if i < k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i < k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= k:",
      "mutated_line": "if i > k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i > k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= k:",
      "mutated_line": "if i == k:",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i == k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] -= 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] -= 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] -= p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] -= p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] -= p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] -= p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] -= p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] -= p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n - 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n - 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n * 1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n * 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 2)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 2)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 0)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 0)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 0)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 0)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + -1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + -1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] += 1.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 1.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] += -0.75",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += -0.75\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] += 0",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] += 1",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 1\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][0] += -0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += -0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] += 1.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 1.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] += -0.75",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += -0.75\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] += 0",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] += 1",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 1\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][1] += -0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += -0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] += 1.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 1.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] += -0.75",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += -0.75\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] += 0",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] += 1",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 1\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][2] += -0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += -0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 2)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 2)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 0)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 0)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + 0)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 0)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n+1)] for _ in range(n+1)]",
      "mutated_line": "probs = [[[0.0, 0.0, 0.0] for _ in range(n + -1)] for _ in range(n + 1)]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + -1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][-1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][-1] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "probs[i][j][0] += 0.25",
      "mutated_line": "probs[i][j][1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] - 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] - 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] * (0.25 * p[0]), p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] * (0.25 * p[0]), p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] - 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] - 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] * (0.25 * p[0]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] * (0.25 * p[0]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][-1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][-1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[-1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][2] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][-1] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][-1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[2]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[-1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][3] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][3] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][0] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][0] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][-2] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][-2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[3]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[3]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[0]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[-2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[-2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][2] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][0] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][0] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "probs[i][j][1] += 0.25",
      "mutated_line": "probs[i][j][-1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][-1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] - 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] - 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] * (0.25 * p[1]), p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] * (0.25 * p[1]), p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] - 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] - 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] * (0.25 * p[1]), p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] * (0.25 * p[1]), p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] - 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] - 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] * (0.25 * p[1]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] * (0.25 * p[1]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][-1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][-1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[-1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][2] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][-1] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][-1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[2]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[-1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][3] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][3] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][0] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][0] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][-2] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][-2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[3]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[3]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[0]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[-2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[-2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][3] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][3] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][0] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][1] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "probs[i][j][2] += 0.25",
      "mutated_line": "probs[i][j][-2] += 0.25",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][-2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] - 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] - 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] * (0.25 * p[0]), p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] * (0.25 * p[0]), p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] - 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] - 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] * (0.25 * p[0]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] * (0.25 * p[0]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][-1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][-1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][1] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[-1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "probs[i][j][0] += p[0]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[1]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][2] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][0] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][0] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][-1] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][-1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[2]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[0]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "probs[i][j][1] += p[1]",
      "mutated_line": "probs[i][j][1] += p[-1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[-1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][3] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][3] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][0] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][0] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][1] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][1] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][-2] += p[2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][-2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[3]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[3]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[0]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[0]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[1]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[1]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "probs[i][j][2] += p[2]",
      "mutated_line": "probs[i][j][2] += p[-2]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[-2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[-1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[-1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[1], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[0]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[0]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[0]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[0]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[-1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[-1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 / p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 / p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + (0.25 + p[0]), p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + (0.25 + p[0]), p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 ** p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 ** p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 / p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 / p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + (0.25 + p[0]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + (0.25 + p[0]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 ** p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 ** p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[-1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[-1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[1], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[2], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[2], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[-1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[-1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[3]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[3]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[1]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[1]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[0]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[0]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[1]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[1]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[-2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[-2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 / p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 / p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + (0.25 + p[1]), p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + (0.25 + p[1]), p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 ** p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 ** p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 / p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 / p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + (0.25 + p[1]), p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + (0.25 + p[1]), p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 ** p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 ** p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 / p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 / p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + (0.25 + p[1]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + (0.25 + p[1]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 ** p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 ** p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[-1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[-1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[3]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[3]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[0]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[0]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[-2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[-2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 / p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 / p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + (0.25 + p[0]), p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + (0.25 + p[0]), p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 ** p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 ** p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 / p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 / p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + (0.25 + p[0]))",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + (0.25 + p[0]))\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 ** p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 ** p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = probs[i-k][i][:]",
      "mutated_line": "p = probs[i + k][i][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i + k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = probs[i-k][i][:]",
      "mutated_line": "p = probs[i * k][i][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i * k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[2] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[2] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[0] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[0] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[0] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[0] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[-1] + 0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[-1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 1.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 1.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + -0.75 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + -0.75 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 1 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 1 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + -0.25 * p[0], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + -0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[3] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[3] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[1] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[1] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[1] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[1] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[-2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[-2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 1.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 1.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + -0.75 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + -0.75 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 1 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 1 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + -0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + -0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "p = probs[j-k][j][:]",
      "mutated_line": "p = probs[j + k][j][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j + k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "p = probs[j-k][j][:]",
      "mutated_line": "p = probs[j * k][j][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j * k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[3] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[3] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[1] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[1] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[0] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[0] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[1] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[1] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[-2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[-2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 1.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 1.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + -0.75 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + -0.75 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 1 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 1 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + -0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + -0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[1] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[1] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[-1] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[-1] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[1] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[1] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 1.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 1.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + -0.75 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + -0.75 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 1 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 1 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + -0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + -0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[3] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[3] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[1] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[1] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[0] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[0] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[1] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[1] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[-2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[-2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 1.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 1.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + -0.75 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + -0.75 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 1 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 1 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + -0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + -0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "p = probs[i-k][i][:]",
      "mutated_line": "p = probs[i + k][i][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i + k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "p = probs[i-k][i][:]",
      "mutated_line": "p = probs[i * k][i][:]",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i * k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[3] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[3] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[0] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[0] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[1] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[-2] + 0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[-2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 1.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 1.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + -0.75 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + -0.75 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 1 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 1 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + -0.25 * p[0], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + -0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[1] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[1] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[-1] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[-1] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[1] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[1] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 1.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 1.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + -0.75 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + -0.75 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 1 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 1 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + -0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + -0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[1], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[1], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[-1], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[-1], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[1], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[1], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[-1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[-1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0], p[1] = p[1]+0.25*p[0], p[2]+0.25*p[0]",
      "mutated_line": "(p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[2], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[2], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[-1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[-1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[2], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[2], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[-1], p[2] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[-1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[2])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[2])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[0], p[1], p[2] = p[2]+0.25*p[1], p[0]+0.25*p[1], p[2]+0.25*p[1]",
      "mutated_line": "(p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[-1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[-1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[-1], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[-1], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[-1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[-1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "p[0], p[2] = p[2]+0.25*p[0], p[0]+0.25*p[0]",
      "mutated_line": "(p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1])",
      "code": "def compute_U(N):\n    res = 0.0\n    for n in range(3, N + 1):\n        probs = [[[0.0, 0.0, 0.0] for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][0] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[1]) = (p[1] + 0.25 * p[0], p[2] + 0.25 * p[0])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if j <= k:\n                        probs[i][j][1] += 0.25\n                    else:\n                        p = probs[j - k][j][:]\n                        (p[0], p[1], p[2]) = (p[2] + 0.25 * p[1], p[0] + 0.25 * p[1], p[2] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n                for k in range(1, 5):\n                    if i <= k:\n                        probs[i][j][2] += 0.25\n                    else:\n                        p = probs[i - k][i][:]\n                        (p[0], p[2]) = (p[2] + 0.25 * p[0], p[0] + 0.25 * p[1])\n                        probs[i][j][0] += p[0]\n                        probs[i][j][1] += p[1]\n                        probs[i][j][2] += p[2]\n        res += max(probs[n][n]) - min(probs[n][n])\n    return round(res, 8)"
    }
  ]
}