{
  "task_id": "cf_45620",
  "entry_point": "minimumEffortPath",
  "mutant_count": 90,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 1\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = -1",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = -1\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 1\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dp = [[float('inf')] / n for _ in range(m)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] / n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dp = [[float('inf')] + n for _ in range(m)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] + n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dp = [[float('inf')] ** n for _ in range(m)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] ** n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][1] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][-1] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][-1] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][1] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) != (m - 1, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) != (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(1, 0, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(1, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(-1, 0, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(-1, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(1, 0, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(1, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, 1, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 1, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, -1, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, -1, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, 1, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 1, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, 0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 1)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, 0, -1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, -1)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap = [(0, 0, 0)]",
      "mutated_line": "heap = [(0, 0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 1)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[1][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[-1][0] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[-1][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[1][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(+1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(+1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, -1), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, -1), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 1), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 1), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (2, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (2, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (0, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (0, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (-1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (-1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, -1), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, -1), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 1), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 1), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (-1, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (-1, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (1, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (1, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, +1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, +1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (-1, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (1, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (1, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 2)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 2)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 0)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 0)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, -1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, -1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(heights), len(heights[0])",
      "mutated_line": "(m, n) = (len(heights), len(heights[1]))",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[1]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(heights), len(heights[0])",
      "mutated_line": "(m, n) = (len(heights), len(heights[-1]))",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[-1]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(heights), len(heights[0])",
      "mutated_line": "(m, n) = (len(heights), len(heights[1]))",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[1]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-2, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-2, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-0, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-0, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(--1, 0), (1, 0), (0, -1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(--1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -2), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -2), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, -0), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -0), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "mutated_line": "dir = [(-1, 0), (1, 0), (0, --1), (0, 1)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, --1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m + 1, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m + 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m * 1, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m * 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n + 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n + 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n * 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n * 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost < dp[nx][ny]:",
      "mutated_line": "if cost <= dp[nx][ny]:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost <= dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost < dp[nx][ny]:",
      "mutated_line": "if cost >= dp[nx][ny]:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost >= dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cost < dp[nx][ny]:",
      "mutated_line": "if cost != dp[nx][ny]:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost != dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "dp = [[float('')] * n for _ in range(m)]",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 2, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 2, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 0, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 0, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 0, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 0, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - -1, n - 1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - -1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n - 2):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 2):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n - 0):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 0):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n - 0):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 0):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x, y) == (m-1, n-1):",
      "mutated_line": "if (x, y) == (m - 1, n - -1):",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - -1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))",
      "mutated_line": "cost = max(maxDist, abs(heights[x][y] + heights[nx][ny]))",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] + heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cost = max(maxDist, abs(heights[x][y] - heights[nx][ny]))",
      "mutated_line": "cost = max(maxDist, abs(heights[x][y] * heights[nx][ny]))",
      "code": "import heapq\n\ndef minimumEffortPath(heights):\n    (m, n) = (len(heights), len(heights[0]))\n    heap = [(0, 0, 0)]\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while heap:\n        (maxDist, x, y) = heapq.heappop(heap)\n        if (x, y) == (m - 1, n - 1):\n            return maxDist\n        for (dx, dy) in dir:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                cost = max(maxDist, abs(heights[x][y] * heights[nx][ny]))\n                if cost < dp[nx][ny]:\n                    dp[nx][ny] = cost\n                    heapq.heappush(heap, (cost, nx, ny))"
    }
  ]
}