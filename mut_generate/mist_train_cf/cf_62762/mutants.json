{
  "task_id": "cf_62762",
  "entry_point": "hybrid_recommendation",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[1])[1]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[1])[-1]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[1])[1]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[1]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "similar_to_liked = any(similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']])",
      "mutated_line": "similar_to_liked = any((similar_design not in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design not in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score / 1.1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score / 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score + 1.1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score + 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score ** 1.1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score ** 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[2])[0]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[2])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[0])[0]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[0])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[0])[0]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[0])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return max(recommended_designs, key=lambda x: x[1])[0]",
      "mutated_line": "return max(recommended_designs, key=lambda x: x[-1])[0]",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[-1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "score = sum(preferences[component] for component in design['components'])",
      "mutated_line": "similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score * 2.1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 2.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score * 0.10000000000000009))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 0.10000000000000009))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score * 0))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 0))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score * 1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "recommended_designs.append((design, score * 1.1))",
      "mutated_line": "recommended_designs.append((design, score * -1.1))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * -1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "similar_to_liked = any(similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']])",
      "mutated_line": "similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] != design['components']]))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] != design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "similar_to_liked = any(similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']])",
      "mutated_line": "similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d[''] == design['components']]))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d[''] == design['components']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "similar_to_liked = any(similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['components']])",
      "mutated_line": "similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['']]))",
      "code": "def hybrid_recommendation(preferences, liked_designs, rules, designs):\n    \"\"\"\n    Combines collaborative filtering and content-based recommendation systems for a keyboard design recommendation system.\n\n    Args:\n    - preferences (dict): Designer preferences for different design components.\n    - liked_designs (list): Designs previously liked and rated by designers or users with similar taste.\n    - rules (list): Rules that suggest plausible modifications to designs.\n    - designs (list): Set of designs to choose from.\n\n    Returns:\n    - recommended_design: A design recommendation that meets the rules' requirements.\n    \"\"\"\n    recommended_designs = []\n    for design in designs:\n        if all((rule(design) for rule in rules)):\n            score = sum((preferences[component] for component in design['components']))\n            similar_to_liked = any((similar_design in liked_designs for similar_design in [d for d in designs if d['components'] == design['']]))\n            if similar_to_liked:\n                recommended_designs.append((design, score * 1.1))\n            else:\n                recommended_designs.append((design, score))\n    return max(recommended_designs, key=lambda x: x[1])[0]"
    }
  ]
}