{
  "task_id": "cf_43804",
  "entry_point": "maxProfit",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 - 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 * 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_profit = 0",
      "mutated_line": "max_profit = 1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 1\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_profit = 0",
      "mutated_line": "max_profit = -1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = -1\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_profit = 0",
      "mutated_line": "max_profit = 1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 1\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders >= 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders >= 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders <= 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders <= 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders != 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders != 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit -= total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit -= total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "orders -= n_to_reduce",
      "mutated_line": "orders += n_to_reduce",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders += n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 * 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 + 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 8\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 6\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 0\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 1\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + -7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [-1 / a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 / a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [-1 + a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 + a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [(-1) ** a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [(-1) ** a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders > 1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 1:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders > -1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > -1:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while orders > 0:",
      "mutated_line": "while orders > 1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 1:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = -1 / heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 / heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = -1 + heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 + heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = (-1) ** heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = (-1) ** heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) >= 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) >= 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) <= 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) <= 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) != 0:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) != 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) - r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) - r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) * (r * (cur_val - total))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) * (r * (cur_val - total))\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 11 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 9 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 0 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 1 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = -10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 10 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 8 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 0 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 1 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** -9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [+1 * a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [+1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = +1 * heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = +1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) > 1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 1:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) > -1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > -1:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(inventory) > 0:",
      "mutated_line": "if len(inventory) > 1:",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 1:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -1 / inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 / inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -1 + inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 + inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = (-1) ** inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = (-1) ** inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "next_val = 0",
      "mutated_line": "next_val = 1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 1\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "next_val = 0",
      "mutated_line": "next_val = -1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = -1\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "next_val = 0",
      "mutated_line": "next_val = 1",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 1\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val - next_val - 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val - 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, (cur_val - next_val) * 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, (cur_val - next_val) * 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val - next_val - 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val - 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, (cur_val - next_val) * 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, (cur_val - next_val) * 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 / (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 / (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 + (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 + (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += (total * (cur_val + cur_val - total + 1) // 2) ** (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += (total * (cur_val + cur_val - total + 1) // 2) ** (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r / (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r / (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + (r + (cur_val - total))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + (r + (cur_val - total))\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r ** (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r ** (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 / (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 / (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 + (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 + (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, (-1) ** (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, (-1) ** (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [-2 * a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-2 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [-0 * a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-0 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [-0 * a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-0 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inventory = [-1*a for a in inventory]",
      "mutated_line": "inventory = [--1 * a for a in inventory]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [--1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = -2 * heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -2 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = -0 * heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -0 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = -0 * heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -0 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_val = -1*heapq.heappop(inventory)",
      "mutated_line": "cur_val = --1 * heapq.heappop(inventory)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = --1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = +1 * inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = +1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val + next_val + 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val + next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val * next_val + 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val * next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val - next_val + 2)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 2)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val - next_val + 0)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 0)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val - next_val + 0)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 0)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_to_reduce = min(orders, cur_val-next_val+1)",
      "mutated_line": "n_to_reduce = min(orders, cur_val - next_val + -1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + -1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val + next_val + 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val + next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val * next_val + 1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val * next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val - next_val + 2)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 2)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val - next_val + 0)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 0)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val - next_val + 0)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 0)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "total, r = divmod(n_to_reduce, cur_val-next_val+1)",
      "mutated_line": "(total, r) = divmod(n_to_reduce, cur_val - next_val + -1)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + -1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) / 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) / 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) * 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) * 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val - 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val - 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * ((cur_val - next_val) * 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * ((cur_val - next_val) * 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val + total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val + total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val * total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val * total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, +1 * (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, +1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val - total + 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total + 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * ((cur_val - total) * 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * ((cur_val - total) * 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -2 * inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -2 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -0 * inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -0 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -0 * inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -0 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = --1 * inventory[0]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = --1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -1 * inventory[1]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[1]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -1 * inventory[-1]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[-1]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_val = -1*inventory[0]",
      "mutated_line": "next_val = -1 * inventory[1]",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[1]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total / (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total / (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += (total + (cur_val + cur_val - total + 1)) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += (total + (cur_val + cur_val - total + 1)) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total ** (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total ** (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 3 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 3 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 1 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 1 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 0 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 0 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 1 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 1 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // -2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // -2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val + next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val + next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val * next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val * next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 2) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 2) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 0) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 0) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 0) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 0) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + -1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + -1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -2 * (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -2 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -0 * (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -0 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -0 * (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -0 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, --1 * (cur_val - total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, --1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val + total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val + total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val * total - 1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val * total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val - total - 2))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 2))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val - total - 0))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 0))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val - total - 0))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 0))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(inventory, -1*(cur_val - total - 1))",
      "mutated_line": "heapq.heappush(inventory, -1 * (cur_val - total - -1))",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - -1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total - 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total - 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * ((cur_val + cur_val - total) * 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * ((cur_val + cur_val - total) * 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val + total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val + total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * ((cur_val + cur_val) * total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * ((cur_val + cur_val) * total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 2) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 2) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 0) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 0) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + 0) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + 0) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val + cur_val - total + -1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val + cur_val - total + -1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val - cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val - cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_profit += (total*(cur_val+cur_val-total+1))//2*(cur_val-next_val+1) + r*(cur_val-total)",
      "mutated_line": "max_profit += total * (cur_val * cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)",
      "code": "import heapq\n\ndef maxProfit(inventory, orders):\n    MOD = 10 ** 9 + 7\n    inventory = [-1 * a for a in inventory]\n    heapq.heapify(inventory)\n    max_profit = 0\n    while orders > 0:\n        cur_val = -1 * heapq.heappop(inventory)\n        if len(inventory) > 0:\n            next_val = -1 * inventory[0]\n        else:\n            next_val = 0\n        n_to_reduce = min(orders, cur_val - next_val + 1)\n        (total, r) = divmod(n_to_reduce, cur_val - next_val + 1)\n        max_profit += total * (cur_val * cur_val - total + 1) // 2 * (cur_val - next_val + 1) + r * (cur_val - total)\n        max_profit %= MOD\n        heapq.heappush(inventory, -1 * (cur_val - total - 1))\n        orders -= n_to_reduce\n    return max_profit"
    }
  ]
}