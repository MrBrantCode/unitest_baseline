{
  "task_id": "cf_69237",
  "entry_point": "intricate_prime_triplet_product",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 and a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 and a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a >= 10000 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a >= 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a <= 10000 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a <= 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a != 10000 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a != 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a <= 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a <= 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a >= 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a >= 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a != 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a != 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 2",
      "mutated_line": "p = 3",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 3\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 2",
      "mutated_line": "p = 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 1\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 2",
      "mutated_line": "p = 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 0\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 2",
      "mutated_line": "p = 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 1\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = 2",
      "mutated_line": "p = -2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = -2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 2 < n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 < n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 2 > n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 > n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 2 == n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 == n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p -= 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return ('Not a product of 3 distinct prime numbers.')",
      "mutated_line": "return ''",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return ''\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10001 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10001 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 9999 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 9999 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 0 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 0 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 1 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 1 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > -10000 or a < 0:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > -10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a < 1:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 1:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a < -1:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < -1:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if a > 10000 or a < 0:",
      "mutated_line": "if a > 10000 or a < 1:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 1:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "raise Exception('a should be between 0 and 10000')",
      "mutated_line": "raise Exception('')",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [False for _ in range(n + 1)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [False for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p * 2 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p * 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p + 2 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p + 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if prime_list[p] == True:",
      "mutated_line": "if prime_list[p] != True:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] != True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 2\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 0\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 0\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += -1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(1, n - 3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(1, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(-1, n - 3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(-1, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(1, n - 3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(1, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n + 3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n + 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n * 3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n * 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 or primes[i] == primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 or primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i - 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i - 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i * 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i * 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n + 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n + 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n * 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n * 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while j < k:",
      "mutated_line": "while j <= k:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j <= k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while j < k:",
      "mutated_line": "while j >= k:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j >= k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while j < k:",
      "mutated_line": "while j != k:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j != k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 3 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 3 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 1 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 1 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 0 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 0 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** 1 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 1 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while p**2 <= n:",
      "mutated_line": "while p ** -2 <= n:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** -2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if prime_list[p] == True:",
      "mutated_line": "if prime_list[p] == False:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == False:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n - 4):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 4):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n - 2):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 2):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n - 0):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 0):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 1):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(0, n-3):",
      "mutated_line": "for i in range(0, n - -3):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - -3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i == 0 and primes[i] == primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i == 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] != primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] != primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 2\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 0\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 0\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + -1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + -1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n - 2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 2\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n - 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 0\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n - 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 0\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "k = n - 1",
      "mutated_line": "k = n - -1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - -1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = primes[i] * primes[j] / primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] / primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = primes[i] * primes[j] + primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] + primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = (primes[i] * primes[j]) ** primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = (primes[i] * primes[j]) ** primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if sum == target:",
      "mutated_line": "if sum != target:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum != target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n - 1)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n - 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n * 1)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n * 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p * 2, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p * 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p + 2, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p + 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n - 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n - 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n * 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n * 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime_list[i] = False",
      "mutated_line": "prime_list[i] = True",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = True\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 1 and primes[i] == primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 1 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != -1 and primes[i] == primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != -1 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 1 and primes[i] == primes[i - 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 1 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = primes[i] / primes[j] * primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] / primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = (primes[i] + primes[j]) * primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = (primes[i] + primes[j]) * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sum = primes[i] * primes[j] * primes[k]",
      "mutated_line": "sum = primes[i] ** primes[j] * primes[k]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] ** primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sum < target:",
      "mutated_line": "elif sum <= target:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum <= target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sum < target:",
      "mutated_line": "elif sum >= target:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum >= target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sum < target:",
      "mutated_line": "elif sum != target:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum != target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j -= 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k += 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n + 2)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 2)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n + 0)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 0)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n + 0)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 0)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prime_list = [True for _ in range(n+1)]",
      "mutated_line": "prime_list = [True for _ in range(n + -1)]",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + -1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 3, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 3, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 1, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 1, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 0, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 0, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 1, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 1, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** -2, n + 1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** -2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n + 2, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 2, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n + 0, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 0, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n + 0, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 0, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(p**2, n+1, p):",
      "mutated_line": "for i in range(p ** 2, n + -1, p):",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + -1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i + 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i + 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i * 1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i * 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 2\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 0\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 0\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += -1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 2\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 0\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 0\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= -1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i - 2]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 2]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i - 0]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 0]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i - 0]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - 0]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i != 0 and primes[i] == primes[i-1]:",
      "mutated_line": "if i != 0 and primes[i] == primes[i - -1]:",
      "code": "def intricate_prime_triplet_product(a):\n    if a > 10000 or a < 0:\n        raise Exception('a should be between 0 and 10000')\n\n    def prime_generator(n):\n        prime_list = [True for _ in range(n + 1)]\n        p = 2\n        while p ** 2 <= n:\n            if prime_list[p] == True:\n                yield p\n                for i in range(p ** 2, n + 1, p):\n                    prime_list[i] = False\n            p += 1\n\n    def find_triplet_product(primes, target):\n        primes.sort()\n        n = len(primes)\n        for i in range(0, n - 3):\n            if i != 0 and primes[i] == primes[i - -1]:\n                continue\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = primes[i] * primes[j] * primes[k]\n                if sum == target:\n                    return (primes[i], primes[j], primes[k])\n                elif sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return 'Not a product of 3 distinct prime numbers.'\n    primes = [p for p in prime_generator(a)]\n    return find_triplet_product(primes, a)"
    }
  ]
}