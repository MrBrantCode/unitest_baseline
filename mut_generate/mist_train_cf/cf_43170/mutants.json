{
  "task_id": "cf_43170",
  "entry_point": "shortestPath",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (1, 0)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (1, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (-1, 0)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (-1, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (1, 0)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (1, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (0, 1)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 1)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (0, -1)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "start_row, start_col = 0, 0",
      "mutated_line": "(start_row, start_col) = (0, 1)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 1)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if maze[row][col] == 'E':",
      "mutated_line": "if maze[row][col] != 'E':",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] != 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if maze[i][j] == 'S':",
      "mutated_line": "if maze[i][j] != 'S':",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] != 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if maze[row][col] == 'E':",
      "mutated_line": "if maze[row][col] == '':",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == '':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows or 0 <= new_col < cols or maze[new_row][new_col] != '#':",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows or 0 <= new_col < cols or maze[new_row][new_col] != '#':\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[-1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if maze[i][j] == 'S':",
      "mutated_line": "if maze[i][j] == '':",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == '':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(start_row, start_col, 0)])",
      "mutated_line": "queue = deque([(start_row, start_col, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 1)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(start_row, start_col, 0)])",
      "mutated_line": "queue = deque([(start_row, start_col, -1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, -1)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = deque([(start_row, start_col, 0)])",
      "mutated_line": "queue = deque([(start_row, start_col, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 1)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row - dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row * dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col - dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col * dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 < new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 < new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 > new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 > new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 == new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 == new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 0 < new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 < new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 0 > new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 > new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 0 == new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 == new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] == '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] == '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if (new_row, new_col) not in visited:",
      "mutated_line": "if (new_row, new_col) in visited:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while -1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while -1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 1 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 1 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 1 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and -1 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and -1 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 1 <= new_col < cols and (maze[new_row][new_col] != '#'):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 1 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != '#':",
      "mutated_line": "while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != ''):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != ''):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_row, new_col = new_row + dr, new_col + dc",
      "mutated_line": "(new_row, new_col) = (new_row - dr, new_col + dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row - dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_row, new_col = new_row + dr, new_col + dc",
      "mutated_line": "(new_row, new_col) = (new_row * dr, new_col + dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row * dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_row, new_col = new_row + dr, new_col + dc",
      "mutated_line": "(new_row, new_col) = (new_row + dr, new_col - dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col - dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_row, new_col = new_row + dr, new_col + dc",
      "mutated_line": "(new_row, new_col) = (new_row + dr, new_col * dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 1))\n                (new_row, new_col) = (new_row + dr, new_col * dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance - 1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance - 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance * 1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance * 1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance + 2))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 2))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance + 0))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 0))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance + 0))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + 0))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((new_row, new_col, distance + 1))",
      "mutated_line": "queue.append((new_row, new_col, distance + -1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(maze: List[List[str]]) -> int:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    (start_row, start_col) = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 'S':\n                (start_row, start_col) = (i, j)\n                break\n    queue = deque([(start_row, start_col, 0)])\n    visited = set((start_row, start_col))\n    while queue:\n        (row, col, distance) = queue.popleft()\n        if maze[row][col] == 'E':\n            return distance\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            while 0 <= new_row < rows and 0 <= new_col < cols and (maze[new_row][new_col] != '#'):\n                if (new_row, new_col) not in visited:\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col, distance + -1))\n                (new_row, new_col) = (new_row + dr, new_col + dc)\n    return -1"
    }
  ]
}