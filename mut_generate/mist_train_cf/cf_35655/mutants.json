{
  "task_id": "cf_35655",
  "entry_point": "generate_paths",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start not in graph and end not in graph:",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start not in graph and end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current != end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start not in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start in graph or end not in graph:",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if start not in graph or end not in graph:",
      "mutated_line": "if start not in graph or end in graph:",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start not in graph or end in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "yield path + [current]",
      "mutated_line": "yield (path - [current])",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path - [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start not in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "yield path + [current]",
      "mutated_line": "yield (path * [current])",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path * [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path + [current])\n    if start not in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "yield from dfs(neighbor, path + [current])",
      "mutated_line": "yield from dfs(neighbor, path - [current])",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path - [current])\n    if start not in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "yield from dfs(neighbor, path + [current])",
      "mutated_line": "yield from dfs(neighbor, path * [current])",
      "code": "def generate_paths(graph, start, end):\n\n    def dfs(current, path):\n        if current == end:\n            yield (path + [current])\n        else:\n            for neighbor in graph.get(current, []):\n                yield from dfs(neighbor, path * [current])\n    if start not in graph or end not in graph:\n        return\n    yield from dfs(start, [])"
    }
  ]
}