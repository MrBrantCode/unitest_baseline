{
  "task_id": "cf_28968",
  "entry_point": "letter_combinations",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'2': 'abc',",
      "mutated_line": "digit_map = {'': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'3': 'def',",
      "mutated_line": "digit_map = {'2': 'abc', '': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'4': 'ghi',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'5': 'jkl',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'6': 'mno',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'7': 'pqrs',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'8': 'tuv',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'9': 'wxyz'",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'2': 'abc',",
      "mutated_line": "digit_map = {'2': '', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': '', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'3': 'def',",
      "mutated_line": "digit_map = {'2': 'abc', '3': '', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': '', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'4': 'ghi',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': '', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': '', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'5': 'jkl',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': '', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': '', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'6': 'mno',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': '', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': '', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'7': 'pqrs',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': '', '8': 'tuv', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': '', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'8': 'tuv',",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': '', '9': 'wxyz'}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': '', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'9': 'wxyz'",
      "mutated_line": "digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': ''}",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': ''}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index == len(digits):",
      "mutated_line": "if index != len(digits):",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index != len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "backtrack(0, [])",
      "mutated_line": "backtrack(1, [])",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(1, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "backtrack(0, [])",
      "mutated_line": "backtrack(-1, [])",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(-1, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "backtrack(0, [])",
      "mutated_line": "backtrack(1, [])",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(1, [])\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index - 1, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index - 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index * 1, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index * 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index + 2, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 2, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index + 0, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 0, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index + 0, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 0, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "backtrack(index + 1, path)",
      "mutated_line": "backtrack(index + -1, path)",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + -1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "combinations.append(''.join(path))",
      "mutated_line": "combinations.append('MUTATED'.join(path))",
      "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n    digit_map = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append('MUTATED'.join(path))\n            return\n        for letter in digit_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    combinations = []\n    backtrack(0, [])\n    return combinations"
    }
  ]
}