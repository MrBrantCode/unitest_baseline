{
  "task_id": "cf_82755",
  "entry_point": "quick_sort",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def quick_sort(arr):\n    \"\"\"\"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) < 1:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) < 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) > 1:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) > 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) == 1:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) == 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)",
      "mutated_line": "return quick_sort(items_lower) + [pivot] - quick_sort(items_greater)",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] - quick_sort(items_greater)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)",
      "mutated_line": "return (quick_sort(items_lower) + [pivot]) * quick_sort(items_greater)",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return (quick_sort(items_lower) + [pivot]) * quick_sort(items_greater)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) <= 2:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 2:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) <= 0:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 0:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) <= 0:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 0:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(arr) <= 1:",
      "mutated_line": "if len(arr) <= -1:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= -1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if item > pivot:",
      "mutated_line": "if item >= pivot:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item >= pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if item > pivot:",
      "mutated_line": "if item <= pivot:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item <= pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if item > pivot:",
      "mutated_line": "if item != pivot:",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item != pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "print(\"Custom message: Sorting has been successfully completed.\")",
      "mutated_line": "print('')",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('')\n    return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)",
      "mutated_line": "return quick_sort(items_lower) - [pivot] + quick_sort(items_greater)",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) - [pivot] + quick_sort(items_greater)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return quick_sort(items_lower) + [pivot] + quick_sort(items_greater)",
      "mutated_line": "return quick_sort(items_lower) * [pivot] + quick_sort(items_greater)",
      "code": "def quick_sort(arr):\n    \"\"\"\n    This function implements quick sort algorithm. \n\n    The algorithm works as follows:\n    1. Select a 'pivot' element from the array and partition the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. \n    2. Recursively sort the sub-arrays.\n    3. Combine the sub-arrays with the pivot to get the sorted array.\n\n    Quick sort is very efficient for large data sets. It performs well for data sets that do not contain duplicate values. \n\n    The function is not suitable for smaller lists as its overhead is higher than simple sorting algorithms like insertion sort.\n    It is also not suitable for lists with many duplicate values as they decrease the efficiency of the pivot selection process.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr.pop()\n    items_greater = []\n    items_lower = []\n    for item in arr:\n        if item > pivot:\n            items_greater.append(item)\n        else:\n            items_lower.append(item)\n    print('Custom message: Sorting has been successfully completed.')\n    return quick_sort(items_lower) * [pivot] + quick_sort(items_greater)"
    }
  ]
}