{
  "task_id": "cf_63301",
  "entry_point": "can_finish_project",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_time = 0",
      "mutated_line": "current_time = 1",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 1\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_time = 0",
      "mutated_line": "current_time = -1",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = -1\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_time = 0",
      "mutated_line": "current_time = 1",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 1\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "current_time += current_task.time_needed",
      "mutated_line": "current_time -= current_task.time_needed",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time -= current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "available_resources -= current_task.resources_needed",
      "mutated_line": "available_resources += current_task.resources_needed",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources += current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return \"yes\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return self.time_needed < other.time_needed",
      "mutated_line": "return self.time_needed <= other.time_needed",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed <= other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return self.time_needed < other.time_needed",
      "mutated_line": "return self.time_needed >= other.time_needed",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed >= other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return self.time_needed < other.time_needed",
      "mutated_line": "return self.time_needed != other.time_needed",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed != other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_time + current_task.time_needed > deadline:",
      "mutated_line": "if current_time + current_task.time_needed >= deadline:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed >= deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_time + current_task.time_needed > deadline:",
      "mutated_line": "if current_time + current_task.time_needed <= deadline:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed <= deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_time + current_task.time_needed > deadline:",
      "mutated_line": "if current_time + current_task.time_needed != deadline:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed != deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if current_task.resources_needed > available_resources:",
      "mutated_line": "if current_task.resources_needed >= available_resources:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed >= available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if current_task.resources_needed > available_resources:",
      "mutated_line": "if current_task.resources_needed <= available_resources:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed <= available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if current_task.resources_needed > available_resources:",
      "mutated_line": "if current_task.resources_needed != available_resources:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed != available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if current_time + current_task.time_needed > deadline:",
      "mutated_line": "if current_time - current_task.time_needed > deadline:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time - current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if current_time + current_task.time_needed > deadline:",
      "mutated_line": "if current_time * current_task.time_needed > deadline:",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time * current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return \"no\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return ''\n        if current_task.resources_needed > available_resources:\n            return 'no'\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return \"no\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\nclass Task:\n\n    def __init__(self, time_needed, resources_needed):\n        self.time_needed = time_needed\n        self.resources_needed = resources_needed\n\n    def __lt__(self, other):\n        return self.time_needed < other.time_needed\n\ndef can_finish_project(project_tasks, available_resources, deadline):\n    current_time = 0\n    task_heap = []\n    for task in project_tasks:\n        heapq.heappush(task_heap, task)\n    while task_heap:\n        current_task = heapq.heappop(task_heap)\n        if current_time + current_task.time_needed > deadline:\n            return 'no'\n        if current_task.resources_needed > available_resources:\n            return ''\n        current_time += current_task.time_needed\n        available_resources -= current_task.resources_needed\n    return 'yes'"
    }
  ]
}