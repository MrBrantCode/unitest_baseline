{
  "task_id": "cf_55061",
  "entry_point": "exact_largest_prime_factor",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"\"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 and is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn >= 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn >= 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn <= 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn <= 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn != 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn != 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num not in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 and num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 and num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) - 1",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) - 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) * 1",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) * 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return False\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn < 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn > 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn == 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return \"Error: abs(n) must be larger than 1 and not a prime number.\"",
      "mutated_line": "return ''",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return ''\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(3, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(3, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(1, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(1, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(0, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(0, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(1, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(1, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(-2, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(-2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) - 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) - 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) * 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) * 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i != 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i != 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 2:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 2:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 0:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 0:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > -1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > -1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return False\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 != 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 != 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 or num != 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num != 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return True\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) + 2",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 2\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) + 0",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 0\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) + 0",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 0\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "sqr = int(math.sqrt(num)) + 1",
      "mutated_line": "sqr = int(math.sqrt(num)) + -1",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + -1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(4, sqr, 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(4, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(2, sqr, 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(2, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(0, sqr, 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(0, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(1, sqr, 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(1, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(-3, sqr, 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(-3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 3):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 3):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 1):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 0):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 0):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 1):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, -2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, -2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor != 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor != 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 2 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 0 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 0 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "return 'Error: abs(n) must be larger than 1 and not a prime number.'",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= -1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 2):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 2):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 0):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 0):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 0):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 0):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + -1):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + -1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn * i == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn * i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn + i == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn + i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == -1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == -1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i != 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i != 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "absn /= i",
      "mutated_line": "absn *= i",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn *= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (3, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (1, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (0, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (1, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (-2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 4):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 2):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 0):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 1):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num in (2, 3):",
      "mutated_line": "def is_prime(num: int):",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, -3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num * 2 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num * 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num + 2 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num + 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 1 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 1 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == -1 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == -1 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 1 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 1 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 or num == 2:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 2:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 or num == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 0:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 or num == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 0:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 2 == 0 or num == -1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == -1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num * divisor == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num * divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num + divisor == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num + divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 1:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == -1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == -1:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 1:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return True\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn * i == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn * i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn + i == 0:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn + i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == -1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == -1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 3 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 3 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 1 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 1 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 0 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 0 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % 1 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % 1 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if num % 2 == 0 or num == 1:",
      "mutated_line": "if num % -2 == 0 or num == 1:",
      "code": "import math\n\ndef exact_largest_prime_factor(n: float):\n    \"\"\"Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n\n    def is_prime(num: int):\n        if num in (2, 3):\n            return True\n        if num % -2 == 0 or num == 1:\n            return False\n        sqr = int(math.sqrt(num)) + 1\n        for divisor in range(3, sqr, 2):\n            if num % divisor == 0:\n                return False\n        return True\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor"
    }
  ]
}