{
  "task_id": "cf_64561",
  "entry_point": "intersperse",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 or isinstance(delimiter, int) or delimiter >= 0:",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 or isinstance(delimiter, int) or delimiter >= 0:\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i <= len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i <= len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i >= len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i >= len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i != len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i != len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter > 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter > 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter < 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter < 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter == 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter == 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) + 1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) + 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) * 1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) * 1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 1):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 1):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= -1):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= -1):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 1):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and (delimiter >= 1):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 2 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 2 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 0 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 0 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - 0 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - 0 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i < len(flattened_numbers) - 1 and isinstance(delimiter, int) and delimiter >= 0:",
      "mutated_line": "if i < len(flattened_numbers) - -1 and isinstance(delimiter, int) and (delimiter >= 0):",
      "code": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, List[int]]], delimiter: Union[int, float]) -> List[int]:\n    \"\"\"\n    Introduce the 'delimiter' digit amongst every couple of sequential numbers in the supplied 'numbers' list.\n    Moreover, make sure to manage scenarios that involve a negative or non-integer `delimiter`.\n    Also handles nested list within numbers list.\n    \"\"\"\n    outcome = []\n    flattened_numbers = []\n    for num in numbers:\n        if isinstance(num, list):\n            flattened_numbers.extend(intersperse(num, delimiter))\n        else:\n            flattened_numbers.append(num)\n    for i in range(len(flattened_numbers)):\n        outcome.append(flattened_numbers[i])\n        if i < len(flattened_numbers) - -1 and isinstance(delimiter, int) and (delimiter >= 0):\n            outcome.append(delimiter)\n    return outcome"
    }
  ]
}