{
  "task_id": "cf_45852",
  "entry_point": "is_perfect_cube",
  "mutant_count": 195,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** 3 != n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 != n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 and n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 and n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return False\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 * (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 * (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 + (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 + (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits + 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits + 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits * 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits * 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper <= lower:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper <= lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper >= lower:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper >= lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if upper < lower:",
      "mutated_line": "if upper != lower:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper != lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 1\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = -1\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 1\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 1\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = -1\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 1\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 and len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 and len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_m_prime_nums = 0",
      "mutated_line": "n_m_prime_nums = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 1\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_m_prime_nums = 0",
      "mutated_line": "n_m_prime_nums = -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = -1\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_m_prime_nums = 0",
      "mutated_line": "n_m_prime_nums = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 1\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]",
      "mutated_line": "n_m_prime_nums -= find_start_end_with_one(len(str(num)), num)[0]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums -= find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = -1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "p_q_total = 0",
      "mutated_line": "p_q_total = 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 1\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total -= find_start_end_with_one(len(str(num)), num)[1]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total -= find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return n_m_prime_nums + p_q_total",
      "mutated_line": "return n_m_prime_nums - p_q_total",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums - p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return n_m_prime_nums + p_q_total",
      "mutated_line": "return n_m_prime_nums * p_q_total",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums * p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) * 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) * 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) + 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) + 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n <= 2 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n <= 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n >= 2 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n >= 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n != 2 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n != 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 >= 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 >= 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 <= 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 <= 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 != 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 != 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(3, int(math.sqrt(n)) + 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(n)) + 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(1, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(n)) + 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(0, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(n)) + 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(1, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(-2, int(math.sqrt(n)) + 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(-2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) - 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) - 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) * 1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) * 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 1, 2):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 1, 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 0):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 1, 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 0):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 1, -1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, -1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i != 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i != 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 11 ** (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 11 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 9 ** (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 9 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 0 ** (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 0 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 1 ** (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 1 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = -10 ** (num_digits - 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = -10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits + 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits + 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits * 1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits * 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 * num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 * num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 + num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 + num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 2",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 2\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 0\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - 0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 0\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 10 ** num_digits - -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - -1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return +1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper - 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper - 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper * 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper * 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' and str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' and str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(3, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(3, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(0, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(0, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(1, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(-2, int(math.sqrt(num)) + 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(-2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) - 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) - 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) * 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) * 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i != 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i != 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):",
      "mutated_line": "if not (is_perfect_cube(m) or is_perfect_cube(p) or is_perfect_cube(q)):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) or is_perfect_cube(p) or is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 'Invalid Inputs.'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return ''\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) <= 4 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) <= 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) >= 4 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) >= 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) != 4 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) != 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) <= 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) <= 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) >= 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) >= 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) != 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) != 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 'Invalid Inputs.'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return ''\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** 4 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 4 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** 2 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 2 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** 0 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 0 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** 1 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 1 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 3)) ** -3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** -3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 3 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 3 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 1 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 1 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 0 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 0 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 1 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 1 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < -2 or n % 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < -2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n * 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n * 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n + 1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n + 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 > 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 > -1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > -1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 1 > 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 2, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 2, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 0, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 0, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + 0, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 0, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(n)) + 1, 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(n)) + -1, 1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + -1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n * i == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n * i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n + i == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n + i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 1:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == -1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == -1:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 1:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return True\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 2)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 2)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 0)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 0)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - 0)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 0)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lower = 10 ** (num_digits - 1)",
      "mutated_line": "lower = 10 ** (num_digits - -1)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - -1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 11 ** num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 11 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 9 ** num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 9 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 0 ** num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 0 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = 1 ** num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 1 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "upper = 10 ** num_digits - 1",
      "mutated_line": "upper = -10 ** num_digits - 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = -10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -2\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -0\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -0\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return --1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 2):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 2):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 0):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 0):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for num in range(lower, upper + 1):",
      "mutated_line": "for num in range(lower, upper + -1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + -1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] != '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] != '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-1] != '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] != '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor != 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor != 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt -= 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "total += num",
      "mutated_line": "total -= num",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total -= num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 2):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 2):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 0):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + 0):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 0):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, int(math.sqrt(num)) + 1):",
      "mutated_line": "for i in range(2, int(math.sqrt(num)) + -1):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + -1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num * i == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num * i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num + i == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num + i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 1:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == -1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == -1:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 1:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 5 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 5 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 3 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 3 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 0 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 0 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 1 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 1 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < -4 or len(find_prime_divisors(m)) < 4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < -4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 5:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 5:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 3:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 3:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 0:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 1:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:",
      "mutated_line": "if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < -4:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < -4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]",
      "mutated_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[1]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[1]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]",
      "mutated_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[-1]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[-1]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]",
      "mutated_line": "n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[1]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[1]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[2]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[2]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[0]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[0]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[0]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[0]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[1]",
      "mutated_line": "p_q_total += find_start_end_with_one(len(str(num)), num)[-1]",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[-1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n * (1.0 / 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n * (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n + 1.0 / 3) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n + 1.0 / 3) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 2 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 2 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 0 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 0 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % 0 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 0 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n < 2 or n % 1 > 0:",
      "mutated_line": "if n < 2 or n % -1 > 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % -1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '' or str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-1] == '':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num * divisor == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num * divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num + divisor == 0:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num + divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 1:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == -1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == -1:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if num % divisor == 0:",
      "mutated_line": "if num % divisor == 1:",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 1:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 2\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 0\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 0\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += -1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if is_prime(num // i):",
      "mutated_line": "if is_prime(num / i):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num / i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if is_prime(num // i):",
      "mutated_line": "if is_prime(num * i):",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num * i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 * 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 * 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 // 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 // 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[1] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[-1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[-1] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[1] == '1' or str(num)[-1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[1] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[+1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[+1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "divs.add(num // i)",
      "mutated_line": "divs.add(num / i)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num / i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "divs.add(num // i)",
      "mutated_line": "divs.add(num * i)",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num * i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (2.0 / 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (2.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (0.0 / 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (0.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (0 / 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (-1.0 / 3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (-1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 4)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 4)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 2)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 2)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 0)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 0)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / 1)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 1)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return round(n**(1./3))**3 == n",
      "mutated_line": "return round(n ** (1.0 / -3)) ** 3 == n",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / -3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-2] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-2] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-0] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-0] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[-0] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[-0] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if str(num)[0] == '1' or str(num)[-1] == '1':",
      "mutated_line": "if str(num)[0] == '1' or str(num)[--1] == '1':",
      "code": "import math\n\ndef is_perfect_cube(n):\n    return round(n ** (1.0 / 3)) ** 3 == n\n\ndef is_prime(n):\n    if n < 2 or n % 1 > 0:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1, 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_start_end_with_one(num_digits, divisor):\n    lower = 10 ** (num_digits - 1)\n    upper = 10 ** num_digits - 1\n    if upper < lower:\n        return -1\n    cnt = 0\n    total = 0\n    for num in range(lower, upper + 1):\n        if str(num)[0] == '1' or str(num)[--1] == '1':\n            if num % divisor == 0:\n                cnt += 1\n                total += num\n    return (cnt, total)\n\ndef find_prime_divisors(num):\n    divs = set()\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if is_prime(i):\n                divs.add(i)\n            if is_prime(num // i):\n                divs.add(num // i)\n    if is_prime(num):\n        divs.add(num)\n    return divs\n\ndef advanced_operation(n, m, p, q):\n    if not (is_perfect_cube(m) and is_perfect_cube(p) and is_perfect_cube(q)):\n        return 'Invalid Inputs.'\n    if len(find_prime_divisors(n)) < 4 or len(find_prime_divisors(m)) < 4:\n        return 'Invalid Inputs.'\n    n_m_prime_nums = 0\n    for num in [n, m]:\n        n_m_prime_nums += find_start_end_with_one(len(str(num)), num)[0]\n    p_q_total = 0\n    for num in [p, q]:\n        p_q_total += find_start_end_with_one(len(str(num)), num)[1]\n    return n_m_prime_nums + p_q_total"
    }
  ]
}