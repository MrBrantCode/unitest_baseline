{
  "task_id": "cf_32022",
  "entry_point": "find_cheapest_itinerary",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if source not in graph:",
      "mutated_line": "if source in graph:",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if curr == end:",
      "mutated_line": "if curr != end:",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr != end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heap = [(0, start, [])]",
      "mutated_line": "heap = [(1, start, [])]",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(1, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heap = [(0, start, [])]",
      "mutated_line": "heap = [(-1, start, [])]",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(-1, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "heap = [(0, start, [])]",
      "mutated_line": "heap = [(1, start, [])]",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(1, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return total_cost, path + [end]",
      "mutated_line": "return (total_cost, path - [end])",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path - [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return total_cost, path + [end]",
      "mutated_line": "return (total_cost, path * [end])",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path * [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))",
      "mutated_line": "heapq.heappush(heap, (total_cost - cost, neighbor, path + [curr]))",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost - cost, neighbor, path + [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))",
      "mutated_line": "heapq.heappush(heap, (total_cost * cost, neighbor, path + [curr]))",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost * cost, neighbor, path + [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))",
      "mutated_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path - [curr]))",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path - [curr]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path + [curr]))",
      "mutated_line": "heapq.heappush(heap, (total_cost + cost, neighbor, path * [curr]))",
      "code": "import heapq\n\ndef find_cheapest_itinerary(flights, start, end):\n    graph = {}\n    for (source, dest, cost) in flights:\n        if source not in graph:\n            graph[source] = []\n        graph[source].append((dest, cost))\n    heap = [(0, start, [])]\n    while heap:\n        (total_cost, curr, path) = heapq.heappop(heap)\n        if curr == end:\n            return (total_cost, path + [end])\n        for (neighbor, cost) in graph.get(curr, []):\n            heapq.heappush(heap, (total_cost + cost, neighbor, path * [curr]))"
    }
  ]
}