{
  "task_id": "cf_51478",
  "entry_point": "exact_longest_prime_factor",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn <= 1 and is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 and is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn >= 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn >= 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn <= 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn <= 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn != 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn != 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n not in (2, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n not in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 and n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 and n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) - 1",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) - 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) * 1",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) * 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn < 1 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn < 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn > 1 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn > 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn == 1 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn == 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return \"Error: abs(n) must be larger than 1 and not a prime number.\"",
      "mutated_line": "return ''",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return ''\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(3, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(3, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(1, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(1, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(0, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(0, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(1, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(1, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(-2, math.isqrt(absn) + 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(-2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) - 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) - 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) * 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) * 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i != 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i != 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 2:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 2:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 0:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 0:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if absn > 1:",
      "mutated_line": "if absn > -1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > -1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return False\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 != 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 != 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 or n != 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n != 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return True\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 2",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 2\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 0",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 0\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + 0",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 0\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sqr = int(math.sqrt(n)) + 1",
      "mutated_line": "sqr = int(math.sqrt(n)) + -1",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + -1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(4, sqr, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(4, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(2, sqr, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(2, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(0, sqr, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(0, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(1, sqr, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(1, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(-3, sqr, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(-3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 3):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 1):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 0):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 0):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 1):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for divisor in range(3, sqr, 2):",
      "mutated_line": "for divisor in range(3, sqr, -2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, -2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor != 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor != 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn <= 2 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 2 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn <= 0 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 0 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn <= 0 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 0 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if absn <= 1 or is_prime(absn):",
      "mutated_line": "if absn <= -1 or is_prime(absn):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= -1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 2):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 0):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 0):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + 0):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 0):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, math.isqrt(absn) + 1):",
      "mutated_line": "for i in range(2, math.isqrt(absn) + -1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + -1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn * i == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn * i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn + i == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn + i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == -1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == -1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if absn % i == 0:",
      "mutated_line": "if absn % i == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 1:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i != 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i != 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "absn /= i",
      "mutated_line": "absn *= i",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn *= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (3, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (3, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (1, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (1, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (0, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (0, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (1, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (1, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (-2, 3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (-2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (2, 4):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 4):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (2, 2):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 2):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (2, 0):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 0):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (2, 1):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 1):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n in (2, 3):",
      "mutated_line": "if n in (2, -3):",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, -3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n * 2 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n * 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n + 2 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n + 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 1 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 1 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == -1 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == -1 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 1 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 1 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 or n == 2:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 2:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 or n == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 0:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 or n == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 0:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 2 == 0 or n == -1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == -1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n * divisor == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n * divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n + divisor == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n + divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 1:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == -1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == -1:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n % divisor == 0:",
      "mutated_line": "if n % divisor == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 1:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return True\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn * i == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn * i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn + i == 0:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn + i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == -1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == -1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while absn % i == 0:",
      "mutated_line": "while absn % i == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 1:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 3 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 3 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 1 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 1 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 0 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 0 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % 1 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % 1 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 0 or n == 1:",
      "mutated_line": "if n % -2 == 0 or n == 1:",
      "code": "import math\n\ndef exact_longest_prime_factor(n: float):\n    \"\"\"\n    Offer the supreme prime factor of a positively or negatively valued 'n', or a floating-point numerical entity, \n    while complying with the proviso that abs(n) > 1 and isn't a prime number per se.\n    Assign priority to bolster not just prime efficiency, but also the preciseness of the methodology applied to deduce prime factors.\n    \"\"\"\n    absn = abs(round(n))\n    if absn <= 1 or is_prime(absn):\n        return 'Error: abs(n) must be larger than 1 and not a prime number.'\n    max_factor = None\n    for i in range(2, math.isqrt(absn) + 1):\n        if absn % i == 0:\n            max_factor = i\n            while absn % i == 0:\n                absn /= i\n    if absn > 1:\n        max_factor = absn\n    return max_factor\n\ndef is_prime(n: int):\n    if n in (2, 3):\n        return True\n    if n % -2 == 0 or n == 1:\n        return False\n    sqr = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqr, 2):\n        if n % divisor == 0:\n            return False\n    return True"
    }
  ]
}