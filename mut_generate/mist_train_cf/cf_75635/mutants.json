{
  "task_id": "cf_75635",
  "entry_point": "matchParens",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def matchParens(first, last):\n    \"\"\"\"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "open_count = first.count('(') + last.count('(')",
      "mutated_line": "open_count = first.count('(') - last.count('(')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') - last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "open_count = first.count('(') + last.count('(')",
      "mutated_line": "open_count = first.count('(') * last.count('(')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') * last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "close_count = first.count(')') + last.count(')')",
      "mutated_line": "close_count = first.count(')') - last.count(')')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') - last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "close_count = first.count(')') + last.count(')')",
      "mutated_line": "close_count = first.count(')') * last.count(')')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') * last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count or first[0] != ')' or last[-1] != '(':",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count or first[0] != ')' or last[-1] != '(':\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count != close_count and first[0] != ')' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count != close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] == ')' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] == ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[-1] == '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] == '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Yes'",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return ''\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count or first[0] != ')' or first[-1] != '(' or (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count or first[0] != ')' or first[-1] != '(' or (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "open_count = first.count('(') + last.count('(')",
      "mutated_line": "open_count = first.count('') + last.count('(')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "open_count = first.count('(') + last.count('(')",
      "mutated_line": "open_count = first.count('(') + last.count('')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "close_count = first.count(')') + last.count(')')",
      "mutated_line": "close_count = first.count('') + last.count(')')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count('') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "close_count = first.count(')') + last.count(')')",
      "mutated_line": "close_count = first.count(')') + last.count('')",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count('')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != '' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != '' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[-1] != ''):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != ''):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count != close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count != close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] == ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] == ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] == '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] == '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] == ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] == ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return ''\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[1] != ')' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[1] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[-1] != ')' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[-1] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[1] != ')' and (last[-1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[1] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[+1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[+1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != '' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != '' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ''):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ''):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[-2] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-2] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[-0] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-0] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[-0] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-0] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if open_count == close_count and first[0] != ')' and last[-1] != '(':",
      "mutated_line": "if open_count == close_count and first[0] != ')' and (last[--1] != '('):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[--1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[1] != ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[1] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[-1] != ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[-1] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[1] != ')' and (first[-1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[1] != ')' and (first[-1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[+1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[+1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[1] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[1] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[-1] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[-1] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[1] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-1] != '(') and (last[1] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-2] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-2] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-0] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-0] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[-0] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[-0] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif open_count == close_count and first[0] != ')' and first[-1] != '(' and last[0] != ')':",
      "mutated_line": "elif open_count == close_count and first[0] != ')' and (first[--1] != '(') and (last[0] != ')'):",
      "code": "def matchParens(first, last):\n    \"\"\"\n    Determine if it's possible to concatenate two strings of parentheses in some order to result in a balanced string.\n\n    Args:\n        first (str): The first string of parentheses.\n        last (str): The second string of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string is possible, 'No' otherwise.\n    \"\"\"\n    open_count = first.count('(') + last.count('(')\n    close_count = first.count(')') + last.count(')')\n    if open_count == close_count and first[0] != ')' and (last[-1] != '('):\n        return 'Yes'\n    elif open_count == close_count and first[0] != ')' and (first[--1] != '(') and (last[0] != ')'):\n        return 'Yes'\n    else:\n        return 'No'"
    }
  ]
}