{
  "task_id": "cf_57479",
  "entry_point": "get_lcm",
  "mutant_count": 5,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return reduce(lambda x, y: x * y // math.gcd(x, y), flat_nums)",
      "mutated_line": "return reduce(lambda x, y: x * y / math.gcd(x, y), flat_nums)",
      "code": "from typing import List, Union\nfrom functools import reduce\nimport math\n\ndef get_lcm(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(lambda x, y: x * y / math.gcd(x, y), flat_nums)\n\ndef get_gcd(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(math.gcd, flat_nums)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return reduce(lambda x, y: x * y // math.gcd(x, y), flat_nums)",
      "mutated_line": "return reduce(lambda x, y: x * y * math.gcd(x, y), flat_nums)",
      "code": "from typing import List, Union\nfrom functools import reduce\nimport math\n\ndef get_lcm(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(lambda x, y: x * y * math.gcd(x, y), flat_nums)\n\ndef get_gcd(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(math.gcd, flat_nums)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return reduce(lambda x, y: x * y // math.gcd(x, y), flat_nums)",
      "mutated_line": "return reduce(lambda x, y: x / y // math.gcd(x, y), flat_nums)",
      "code": "from typing import List, Union\nfrom functools import reduce\nimport math\n\ndef get_lcm(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(lambda x, y: x / y // math.gcd(x, y), flat_nums)\n\ndef get_gcd(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(math.gcd, flat_nums)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return reduce(lambda x, y: x * y // math.gcd(x, y), flat_nums)",
      "mutated_line": "return reduce(lambda x, y: (x + y) // math.gcd(x, y), flat_nums)",
      "code": "from typing import List, Union\nfrom functools import reduce\nimport math\n\ndef get_lcm(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(lambda x, y: (x + y) // math.gcd(x, y), flat_nums)\n\ndef get_gcd(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(math.gcd, flat_nums)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return reduce(lambda x, y: x * y // math.gcd(x, y), flat_nums)",
      "mutated_line": "return reduce(lambda x, y: x ** y // math.gcd(x, y), flat_nums)",
      "code": "from typing import List, Union\nfrom functools import reduce\nimport math\n\ndef get_lcm(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(lambda x, y: x ** y // math.gcd(x, y), flat_nums)\n\ndef get_gcd(nums: List[Union[int, List[int]]]) -> int:\n    flat_nums = [i for n in nums for i in (n if isinstance(n, list) else (n,))]\n    return reduce(math.gcd, flat_nums)"
    }
  ]
}