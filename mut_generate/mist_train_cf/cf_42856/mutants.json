{
  "task_id": "cf_42856",
  "entry_point": "parseDirective",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if line.startswith('.entry'):",
      "mutated_line": "if line.startswith(''):",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith(''):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "entry = line.split()[1]",
      "mutated_line": "entry = line.split()[2]",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[2]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "entry = line.split()[1]",
      "mutated_line": "entry = line.split()[0]",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[0]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "entry = line.split()[1]",
      "mutated_line": "entry = line.split()[0]",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[0]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "entry = line.split()[1]",
      "mutated_line": "entry = line.split()[-1]",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[-1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return int(entry, 0)  # parse immediate value with base detection",
      "mutated_line": "return int(entry, 1)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 1)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return int(entry, 0)  # parse immediate value with base detection",
      "mutated_line": "return int(entry, -1)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, -1)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return int(entry, 0)  # parse immediate value with base detection",
      "mutated_line": "return int(entry, 1)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 1)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif line.startswith('.align'):",
      "mutated_line": "elif line.startswith(''):",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith(''):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif line.startswith('.db'):",
      "mutated_line": "elif line.startswith(''):",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith(''):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[3:].split('')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split('')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif line.startswith('.zero'):",
      "mutated_line": "elif line.startswith(''):",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith(''):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_section.align(int(line.split()[1]))",
      "mutated_line": "current_section.align(int(line.split()[2]))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[2]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_section.align(int(line.split()[1]))",
      "mutated_line": "current_section.align(int(line.split()[0]))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[0]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_section.align(int(line.split()[1]))",
      "mutated_line": "current_section.align(int(line.split()[0]))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[0]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_section.align(int(line.split()[1]))",
      "mutated_line": "current_section.align(int(line.split()[-1]))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[-1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if data.startswith('0x'):",
      "mutated_line": "if data.startswith(''):",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith(''):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bytes_data = bytes(int(i.strip(), 16) for i in data)",
      "mutated_line": "bytes_data = bytes((int(i.strip(), 17) for i in data))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 17) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bytes_data = bytes(int(i.strip(), 16) for i in data)",
      "mutated_line": "bytes_data = bytes((int(i.strip(), 15) for i in data))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 15) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bytes_data = bytes(int(i.strip(), 16) for i in data)",
      "mutated_line": "bytes_data = bytes((int(i.strip(), 0) for i in data))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 0) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bytes_data = bytes(int(i.strip(), 16) for i in data)",
      "mutated_line": "bytes_data = bytes((int(i.strip(), 1) for i in data))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 1) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bytes_data = bytes(int(i.strip(), 16) for i in data)",
      "mutated_line": "bytes_data = bytes((int(i.strip(), -16) for i in data))",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), -16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "n = int(data, 16)",
      "mutated_line": "n = int(data, 17)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 17)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "n = int(data, 16)",
      "mutated_line": "n = int(data, 15)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 15)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "n = int(data, 16)",
      "mutated_line": "n = int(data, 0)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 0)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "n = int(data, 16)",
      "mutated_line": "n = int(data, 1)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 1)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "n = int(data, 16)",
      "mutated_line": "n = int(data, -16)",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, -16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[4:].split(',')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[4:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[2:].split(',')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[2:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[0:].split(',')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[0:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[1:].split(',')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[1:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data = line[3:].split(',')",
      "mutated_line": "data = line[-3:].split(',')",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[-3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "data = line[5:].strip()",
      "mutated_line": "data = line[6:].strip()",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[6:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "data = line[5:].strip()",
      "mutated_line": "data = line[4:].strip()",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[4:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "data = line[5:].strip()",
      "mutated_line": "data = line[0:].strip()",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[0:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "data = line[5:].strip()",
      "mutated_line": "data = line[1:].strip()",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[1:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "data = line[5:].strip()",
      "mutated_line": "data = line[-5:].strip()",
      "code": "def parseDirective(line, current_section):\n    \"\"\"\n    Parse assembly language directives.\n\n    Args:\n    line (str): A single line of assembly code containing one of the supported directives.\n    current_section (object): An object with methods align, write, and reserve_zero.\n\n    Returns:\n    int: The parsed immediate value for the .entry directive.\n    \"\"\"\n    if line.startswith('.entry'):\n        entry = line.split()[1]\n        return int(entry, 0)\n    elif line.startswith('.align'):\n        current_section.align(int(line.split()[1]))\n    elif line.startswith('.db'):\n        data = line[3:].split(',')\n        bytes_data = bytes((int(i.strip(), 16) for i in data))\n        current_section.write(bytes_data)\n    elif line.startswith('.zero'):\n        data = line[-5:].strip()\n        if data.startswith('0x'):\n            n = int(data, 16)\n        else:\n            n = int(data)\n        current_section.reserve_zero(n)"
    }
  ]
}