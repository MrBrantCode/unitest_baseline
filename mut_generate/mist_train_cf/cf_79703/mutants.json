{
  "task_id": "cf_79703",
  "entry_point": "operation_matrix",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if N not in ops.keys():",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "'+': lambda p, q: p + q,",
      "mutated_line": "ops = {'': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "'-': lambda p, q: p - q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'*': lambda p, q: p * q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return \"Invalid operation\"",
      "mutated_line": "return ''",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return ''\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "'+': lambda p, q: p + q,",
      "mutated_line": "ops = {'+': lambda p, q: p - q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p - q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "'+': lambda p, q: p + q,",
      "mutated_line": "ops = {'+': lambda p, q: p * q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p * q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "'-': lambda p, q: p - q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p + q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p + q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "'-': lambda p, q: p - q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p * q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p * q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "'*': lambda p, q: p * q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p / q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p / q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "'*': lambda p, q: p * q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p + q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p + q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "'*': lambda p, q: p * q,",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p ** q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p ** q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q == 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q == 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p * q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p * q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p // q if q != 0 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p // q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else ''}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else ''}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M - 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M - 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M * 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M * 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 1 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 1 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != -1 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != -1 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'/': lambda p, q: p / q if q != 0 else 'Undefined',",
      "mutated_line": "ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 1 else 'Undefined'}",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 1 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M - 1)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M - 1)] for p in range(M + 1)]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M * 1)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M * 1)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 2)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 0)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 0)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 0)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + 0)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + -1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 1)] for p in range(M + -1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 2)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 2)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 0)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 0)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + 0)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + 0)] for p in range(M + 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [[ops[N](p, q) for q in range(M+1)] for p in range(M+1)]",
      "mutated_line": "return [[ops[N](p, q) for q in range(M + -1)] for p in range(M + 1)]",
      "code": "def operation_matrix(M, N):\n    ops = {'+': lambda p, q: p + q, '-': lambda p, q: p - q, '*': lambda p, q: p * q, '/': lambda p, q: p / q if q != 0 else 'Undefined'}\n    if N not in ops.keys():\n        return 'Invalid operation'\n    return [[ops[N](p, q) for q in range(M + -1)] for p in range(M + 1)]"
    }
  ]
}