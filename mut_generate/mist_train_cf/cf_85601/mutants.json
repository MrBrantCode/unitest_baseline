{
  "task_id": "cf_85601",
  "entry_point": "advanced_median",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float = 1.0) -> float:",
      "mutated_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float=2.0) -> float:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=2.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float = 1.0) -> float:",
      "mutated_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float=0.0) -> float:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=0.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float = 1.0) -> float:",
      "mutated_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float=0) -> float:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float = 1.0) -> float:",
      "mutated_line": "def advanced_median(l: List[Union[int, float, tuple]], multiplier: float=-1.0) -> float:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=-1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"\"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 2 != 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 != 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "\"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(sublist) == 1:",
      "mutated_line": "if len(sublist) != 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) != 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if idx < len(lows):",
      "mutated_line": "if idx <= len(lows):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx <= len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if idx < len(lows):",
      "mutated_line": "if idx >= len(lows):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx >= len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if idx < len(lows):",
      "mutated_line": "if idx != len(lows):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx != len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) * 2 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) * 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) + 2 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) + 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 2 == 2:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 2:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 2 == 0:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 0:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 2 == 0:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 0:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 2 == -1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == -1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 / (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 / (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 + (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 + (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 ** (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 ** (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(sublist) == 1:",
      "mutated_line": "if len(sublist) == 2:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 2:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(sublist) == 1:",
      "mutated_line": "if len(sublist) == 0:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 0:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(sublist) == 1:",
      "mutated_line": "if len(sublist) == 0:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 0:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(sublist) == 1:",
      "mutated_line": "if len(sublist) == -1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == -1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) / 2]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) / 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) * 2]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) * 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif idx < len(lows) + len(pivots):",
      "mutated_line": "elif idx <= len(lows) + len(pivots):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx <= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif idx < len(lows) + len(pivots):",
      "mutated_line": "elif idx >= len(lows) + len(pivots):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx >= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif idx < len(lows) + len(pivots):",
      "mutated_line": "elif idx != len(lows) + len(pivots):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx != len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el / multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el / multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el + multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el + multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el ** multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el ** multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0] / multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] / multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0] + multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] + multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0] ** multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] ** multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 3 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 3 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 1 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 1 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 0 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 0 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % 1 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 1 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(l) % 2 == 1:",
      "mutated_line": "if len(l) % -2 == 1:",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % -2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) / 2)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) / 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) * 2)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) * 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 1.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 1.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return -0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return -0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 1 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 1 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return -0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return -0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) - selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) - selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) * selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) * selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return sublist[0]",
      "mutated_line": "return sublist[1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[1]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return sublist[0]",
      "mutated_line": "return sublist[-1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[-1]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return sublist[0]",
      "mutated_line": "return sublist[1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[1]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) // 3]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 3]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) // 1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 1]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) // 0]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 0]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) // 1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 1]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pivot = sublist[len(sublist) // 2]",
      "mutated_line": "pivot = sublist[len(sublist) // -2]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // -2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [el for el in sublist if el < pivot]",
      "mutated_line": "lows = [el for el in sublist if el <= pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el <= pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [el for el in sublist if el < pivot]",
      "mutated_line": "lows = [el for el in sublist if el >= pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el >= pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [el for el in sublist if el < pivot]",
      "mutated_line": "lows = [el for el in sublist if el != pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el != pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [el for el in sublist if el > pivot]",
      "mutated_line": "highs = [el for el in sublist if el >= pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el >= pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [el for el in sublist if el > pivot]",
      "mutated_line": "highs = [el for el in sublist if el <= pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el <= pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [el for el in sublist if el > pivot]",
      "mutated_line": "highs = [el for el in sublist if el != pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el != pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "pivots = [el for el in sublist if el == pivot]",
      "mutated_line": "pivots = [el for el in sublist if el != pivot]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el != pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif idx < len(lows) + len(pivots):",
      "mutated_line": "elif idx < len(lows) - len(pivots):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) - len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif idx < len(lows) + len(pivots):",
      "mutated_line": "elif idx < len(lows) * len(pivots):",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) * len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) // 3)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 3)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) // 1)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 1)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) // 0)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 0)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) // 1)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 1)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return selection_algorithm(l, len(l) // 2)",
      "mutated_line": "return selection_algorithm(l, len(l) // -2)",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // -2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[-1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[-1]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return selection_algorithm(highs, idx - len(lows) - len(pivots))",
      "mutated_line": "return selection_algorithm(highs, idx - len(lows) + len(pivots))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) + len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return selection_algorithm(highs, idx - len(lows) - len(pivots))",
      "mutated_line": "return selection_algorithm(highs, (idx - len(lows)) * len(pivots))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, (idx - len(lows)) * len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[1] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[1] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[-1] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[-1] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = [el * multiplier if not isinstance(el, tuple) else el[0]*multiplier for el in l]",
      "mutated_line": "l = [el * multiplier if not isinstance(el, tuple) else el[1] * multiplier for el in l]",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[1] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 + 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 + 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 * 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 * 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) / 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) / 2))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) * 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) * 2))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return selection_algorithm(highs, idx - len(lows) - len(pivots))",
      "mutated_line": "return selection_algorithm(highs, idx + len(lows) - len(pivots))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx + len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return selection_algorithm(highs, idx - len(lows) - len(pivots))",
      "mutated_line": "return selection_algorithm(highs, idx * len(lows) - len(pivots))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx * len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) / 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) / 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) * 2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) * 2 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 2) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 2) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 0) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 0) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 0) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 0) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - -1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - -1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 3))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 3))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 1))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 0))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 0))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 1))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "selection_algorithm(l, len(l) // 2))",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // -2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) + selection_algorithm(l, len(l) // -2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 3 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 3 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 1 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 1 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 0 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 0 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // 1 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // 1 - 1) + selection_algorithm(l, len(l) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0.5 * (selection_algorithm(l, len(l) // 2 - 1) +",
      "mutated_line": "return 0.5 * (selection_algorithm(l, len(l) // -2 - 1) + selection_algorithm(l, len(l) // 2))",
      "code": "from typing import List, Union\n\ndef advanced_median(l: List[Union[int, float, tuple]], multiplier: float=1.0) -> float:\n    \"\"\"Estimates the median of constituents in the list 'l' without sorting them or using library function.\n    Handles tuples with negative and positive integers, and decimals, with the use of an optional multiplier.\n    \"\"\"\n\n    def selection_algorithm(sublist: List[Union[int, float]], idx: int) -> float:\n        \"\"\"A simple selection algorithm that finds the element at index `idx` in the sorted version of `sublist`, without actually sorting sublist.\"\"\"\n        if len(sublist) == 1:\n            return sublist[0]\n        pivot = sublist[len(sublist) // 2]\n        lows = [el for el in sublist if el < pivot]\n        highs = [el for el in sublist if el > pivot]\n        pivots = [el for el in sublist if el == pivot]\n        if idx < len(lows):\n            return selection_algorithm(lows, idx)\n        elif idx < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return selection_algorithm(highs, idx - len(lows) - len(pivots))\n    l = [el * multiplier if not isinstance(el, tuple) else el[0] * multiplier for el in l]\n    if len(l) % 2 == 1:\n        return selection_algorithm(l, len(l) // 2)\n    else:\n        return 0.5 * (selection_algorithm(l, len(l) // -2 - 1) + selection_algorithm(l, len(l) // 2))"
    }
  ]
}