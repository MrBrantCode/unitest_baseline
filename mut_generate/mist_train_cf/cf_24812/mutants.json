{
  "task_id": "cf_24812",
  "entry_point": "is_deadlock_possible",
  "mutant_count": 36,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [0] / len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] / len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [0] + len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] + len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [0] ** len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] ** len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] += 1",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [1] * len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [1] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [-1] * len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [-1] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "in_degree = [0] * len(processes)",
      "mutated_line": "in_degree = [1] * len(processes)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [1] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i != j:",
      "mutated_line": "if i == j:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i == j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 0]",
      "mutated_line": "queue = [i for i in range(len(processes)) if in_degree[i] != 0]",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] != 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(1)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(1)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(-1)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(-1)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(1)",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(1)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 2",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 2\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 0",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 0\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 0",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 0\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= -1",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= -1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] != 0:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] != 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 0]",
      "mutated_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 1]",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 1]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 0]",
      "mutated_line": "queue = [i for i in range(len(processes)) if in_degree[i] == -1]",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == -1]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 0]",
      "mutated_line": "queue = [i for i in range(len(processes)) if in_degree[i] == 1]",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 1]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == 1:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 1:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == -1:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == -1:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == 1:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 1:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for resource in processes[i][1]:",
      "mutated_line": "for resource in processes[i][2]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][2]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for resource in processes[i][1]:",
      "mutated_line": "for resource in processes[i][0]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][0]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for resource in processes[i][1]:",
      "mutated_line": "for resource in processes[i][0]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][0]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for resource in processes[i][1]:",
      "mutated_line": "for resource in processes[i][-1]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][-1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if resource in processes[j][0]:",
      "mutated_line": "if resource not in processes[j][0]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource not in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] -= 1",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] -= 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 2",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 2\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 0",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 0\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += 0",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += 0\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "in_degree[j] += 1",
      "mutated_line": "in_degree[j] += -1",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][0]:\n                        graph[i].append(j)\n                        in_degree[j] += -1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if resource in processes[j][0]:",
      "mutated_line": "if resource in processes[j][1]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][1]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if resource in processes[j][0]:",
      "mutated_line": "if resource in processes[j][-1]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][-1]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if resource in processes[j][0]:",
      "mutated_line": "if resource in processes[j][1]:",
      "code": "def is_deadlock_possible(available_resources, processes):\n    graph = [[] for _ in range(len(processes))]\n    in_degree = [0] * len(processes)\n    for i in range(len(processes)):\n        for j in range(len(processes)):\n            if i != j:\n                for resource in processes[i][1]:\n                    if resource in processes[j][1]:\n                        graph[i].append(j)\n                        in_degree[j] += 1\n    queue = [i for i in range(len(processes)) if in_degree[i] == 0]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return any(in_degree)"
    }
  ]
}