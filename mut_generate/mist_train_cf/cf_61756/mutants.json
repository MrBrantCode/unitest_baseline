{
  "task_id": "cf_61756",
  "entry_point": "rounded_avg_custom_base",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m and (not 2 <= base <= 10):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m and (not 2 <= base <= 10):\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "total += i",
      "mutated_line": "total -= i",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total -= i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count -= 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base != 2:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base != 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "convert_string = \"0123456789ABCDEF\"",
      "mutated_line": "convert_string = ''",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = ''\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if n < base:",
      "mutated_line": "if n <= base:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n <= base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if n < base:",
      "mutated_line": "if n >= base:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n >= base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if n < base:",
      "mutated_line": "if n != base:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n != base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return +1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (1, 0)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (1, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (-1, 0)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (-1, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (1, 0)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (1, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (0, 1)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 1)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (0, -1)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, -1)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "total, count = 0, 0",
      "mutated_line": "(total, count) = (0, 1)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 1)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m - 1):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m - 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m * 1):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m * 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 2\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 0\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 0\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += -1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "avg = round(total / count)",
      "mutated_line": "avg = round(total * count)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total * count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "avg = round(total / count)",
      "mutated_line": "avg = round(total // count)",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total // count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 3:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 3:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 1:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 1:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 0:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 0:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 1:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 1:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if base == 2:",
      "mutated_line": "if base == -2:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == -2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base != 8:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base != 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n // base, base) - convert_string[n % base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) - convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n // base, base) * convert_string[n % base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) * convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 < n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 < n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 > n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 > n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 == n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 == n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 < base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 < base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 > base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 > base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 == base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 == base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -2\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -0\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -0\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return --1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m + 2):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 2):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m + 0):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 0):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m + 0):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 0):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n, m+1):",
      "mutated_line": "for i in range(n, m + -1):",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + -1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 9:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 9:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 7:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 7:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 0:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 0:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 1:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 1:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == -8:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == -8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base != 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base != 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 2 <= n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 2 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 0 <= n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 0 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 0 <= n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 0 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not -1 <= n <= m or not 2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not -1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 3 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 3 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 1 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 1 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 0 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 0 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 1 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 1 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not -2 <= base <= 10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not -2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 <= base <= 11:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 11:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 <= base <= 9:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 9:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 <= base <= 0:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 0:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 <= base <= 1:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 1:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not 1 <= n <= m or not 2 <= base <= 10:",
      "mutated_line": "if not 1 <= n <= m or not 2 <= base <= -10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= -10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return bin(avg)[2:]  # Remove '0b' prefix",
      "mutated_line": "return bin(avg)[3:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[3:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return bin(avg)[2:]  # Remove '0b' prefix",
      "mutated_line": "return bin(avg)[1:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[1:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return bin(avg)[2:]  # Remove '0b' prefix",
      "mutated_line": "return bin(avg)[0:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[0:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return bin(avg)[2:]  # Remove '0b' prefix",
      "mutated_line": "return bin(avg)[1:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[1:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return bin(avg)[2:]  # Remove '0b' prefix",
      "mutated_line": "return bin(avg)[-2:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[-2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base == 11:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 11:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base == 9:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 9:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base == 0:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 0:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base == 1:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 1:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif base == 10:",
      "mutated_line": "elif base == -10:",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == -10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n / base, base) + convert_string[n % base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n / base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n * base, base) + convert_string[n % base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n * base, base) + convert_string[n % base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n // base, base) + convert_string[n * base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n * base]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return to_base_x(n // base, base) + convert_string[n % base]",
      "mutated_line": "return to_base_x(n // base, base) + convert_string[n + base]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n + base]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return oct(avg)[2:]  # Remove '0o' prefix",
      "mutated_line": "return oct(avg)[3:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[3:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return oct(avg)[2:]  # Remove '0o' prefix",
      "mutated_line": "return oct(avg)[1:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[1:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return oct(avg)[2:]  # Remove '0o' prefix",
      "mutated_line": "return oct(avg)[0:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[0:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return oct(avg)[2:]  # Remove '0o' prefix",
      "mutated_line": "return oct(avg)[1:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[1:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return oct(avg)[2:]  # Remove '0o' prefix",
      "mutated_line": "return oct(avg)[-2:]",
      "code": "def rounded_avg_custom_base(n, m, base):\n    \"\"\"\n    Calculate the divisor-weighted average of the sequential integers from n to m (inclusive),\n    round it to the nearest integer, and convert the result to the specified base.\n\n    Args:\n        n (int): The start of the sequence (inclusive).\n        m (int): The end of the sequence (inclusive).\n        base (int): The base to convert the result to.\n\n    Returns:\n        str: The result as a string in the specified base, or -1 if the inputs are invalid.\n    \"\"\"\n    if not 1 <= n <= m or not 2 <= base <= 10:\n        return -1\n    (total, count) = (0, 0)\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    if base == 2:\n        return bin(avg)[2:]\n    elif base == 8:\n        return oct(avg)[-2:]\n    elif base == 10:\n        return str(avg)\n    else:\n        return to_base_x(avg, base)\n\ndef to_base_x(n, base):\n    \"\"\"\n    Convert an integer to a custom base.\n\n    Args:\n        n (int): The number to convert.\n        base (int): The base to convert to.\n\n    Returns:\n        str: The number in the specified base.\n    \"\"\"\n    convert_string = '0123456789ABCDEF'\n    if n < base:\n        return convert_string[n]\n    else:\n        return to_base_x(n // base, base) + convert_string[n % base]"
    }
  ]
}