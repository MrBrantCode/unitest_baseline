{
  "task_id": "cf_26717",
  "entry_point": "calculate_positions_and_momenta",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like / 2.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like / 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like + 2.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like + 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like ** 2.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like ** 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like / 3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like / 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like + 3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like + 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like ** 3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like ** 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like / 4.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like / 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like + 4.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like + 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like ** 4.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like ** 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like / 1.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like / 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like + 1.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like + 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like ** 1.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like ** 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like * 3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 3.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like * 1.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 1.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like * 0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like * 1",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 1\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = time_like * 2.0",
      "mutated_line": "x = time_like * -2.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * -2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like * 4.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 4.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like * 2.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 2.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like * 0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like * 1",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 1\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "y = time_like * 3.0",
      "mutated_line": "y = time_like * -3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * -3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like * 5.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 5.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like * 3.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 3.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like * 0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like * 1",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 1\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = time_like * 4.0",
      "mutated_line": "z = time_like * -4.0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * -4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like * 2.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 2.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like * 0.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 0.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like * 0",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 0\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like * 1",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = time_like * 1.5",
      "mutated_line": "r = time_like * -1.5",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * -1.5\n        theta = math.radians(45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "theta = math.radians(45)",
      "mutated_line": "theta = math.radians(46)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(46)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "theta = math.radians(45)",
      "mutated_line": "theta = math.radians(44)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(44)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "theta = math.radians(45)",
      "mutated_line": "theta = math.radians(0)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(0)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "theta = math.radians(45)",
      "mutated_line": "theta = math.radians(1)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(1)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "theta = math.radians(45)",
      "mutated_line": "theta = math.radians(-45)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(-45)\n        phi = math.radians(60)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "phi = math.radians(60)",
      "mutated_line": "phi = math.radians(61)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(61)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "phi = math.radians(60)",
      "mutated_line": "phi = math.radians(59)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(59)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "phi = math.radians(60)",
      "mutated_line": "phi = math.radians(0)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(0)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "phi = math.radians(60)",
      "mutated_line": "phi = math.radians(1)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(1)\n        return (r, theta, phi)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "phi = math.radians(60)",
      "mutated_line": "phi = math.radians(-60)",
      "code": "from typing import Union, Tuple\nimport math\n\ndef calculate_positions_and_momenta(time_like: float, return_cartesian: bool) -> Union[Tuple[float, float, float], Tuple[float, float, float]]:\n    if return_cartesian:\n        x = time_like * 2.0\n        y = time_like * 3.0\n        z = time_like * 4.0\n        return (x, y, z)\n    else:\n        r = time_like * 1.5\n        theta = math.radians(45)\n        phi = math.radians(-60)\n        return (r, theta, phi)"
    }
  ]
}