{
  "task_id": "cf_29024",
  "entry_point": "sample_orthogonalizer",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):",
      "mutated_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1.000000000001):",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1.000000000001):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):",
      "mutated_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=-0.999999999999):",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=-0.999999999999):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):",
      "mutated_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=0):",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=0):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):",
      "mutated_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1):",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):",
      "mutated_line": "def sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=-1e-12):",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=-1e-12):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):\n    \"\"\"\"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)",
      "mutated_line": "return (X_orthogonalized, Y_selected)",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected + np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "X_orthogonalized = X_selected - np.dot(np.dot(Q, Q.T), X_selected)",
      "mutated_line": "return (X_orthogonalized, Y_selected)",
      "code": "import numpy as np\n\ndef sample_orthogonalizer(idx, X_proxy, Y_proxy, tol=1e-12):\n    \"\"\"\n    Orthogonalizes two matrices, meant to represent a feature matrix\n    :math:`{\\\\mathbf{X}}` and a property matrix :math:`{\\\\mathbf{Y}}`, given\n    the selected samples :math:`{r}`\n\n    Parameters:\n    idx (array-like): Indices of the selected samples\n    X_proxy (np.ndarray): Feature matrix X\n    Y_proxy (np.ndarray): Property matrix Y\n    tol (float): Tolerance value for numerical stability (default: 1e-12)\n\n    Returns:\n    np.ndarray, np.ndarray: Orthogonalized subset of X and Y matrices\n\n    \"\"\"\n    X_selected = X_proxy[idx]\n    Y_selected = Y_proxy[idx]\n    (Q, _) = np.linalg.qr(Y_selected.T)\n    X_orthogonalized = X_selected * np.dot(np.dot(Q, Q.T), X_selected)\n    return (X_orthogonalized, Y_selected)"
    }
  ]
}