{
  "task_id": "cf_94708",
  "entry_point": "find_kth_largest",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i - 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i - 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i * 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i * 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i - 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i - 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i * 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i * 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left < n or heap[left] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n or heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right < n or heap[right] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n or heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if smallest != i:",
      "mutated_line": "(heap[i], heap[smallest]) = (heap[smallest], heap[i])",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest == i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(heap) < k:",
      "mutated_line": "if len(heap) <= k:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) <= k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(heap) < k:",
      "mutated_line": "if len(heap) >= k:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) >= k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(heap) < k:",
      "mutated_line": "if len(heap) != k:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) != k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return heap[0]",
      "mutated_line": "return heap[1]",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return heap[0]",
      "mutated_line": "return heap[-1]",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return heap[0]",
      "mutated_line": "return heap[1]",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 / i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 / i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 + i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 + i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 ** i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 ** i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 2\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 0",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 0\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + 0",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 0\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 2 * i + -1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + -1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 / i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 / i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 + i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 + i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 ** i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 ** i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 3",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 3\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 1\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 0",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 0\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 1\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 2 * i + -2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + -2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left <= n and heap[left] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left <= n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left >= n and heap[left] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left >= n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left != n and heap[left] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left != n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left < n and heap[left] <= heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] <= heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left < n and heap[left] >= heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] >= heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < n and heap[left] < heap[smallest]:",
      "mutated_line": "if left < n and heap[left] != heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] != heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right <= n and heap[right] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right <= n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right >= n and heap[right] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right >= n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right != n and heap[right] < heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right != n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right < n and heap[right] <= heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] <= heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right < n and heap[right] >= heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] >= heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < n and heap[right] < heap[smallest]:",
      "mutated_line": "if right < n and heap[right] != heap[smallest]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] != heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(heap) == k:",
      "mutated_line": "if len(heap) != k:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) != k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num >= heap[0]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num >= heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num <= heap[0]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num <= heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num != heap[0]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num != heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 3 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 3 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 1 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 1 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 0 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 0 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = 1 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 1 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = 2 * i + 1",
      "mutated_line": "left = -2 * i + 1",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = -2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 3 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 3 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 1 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 1 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 0 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 0 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = 1 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 1 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = 2 * i + 2",
      "mutated_line": "right = -2 * i + 2",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = -2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 + 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 + 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 * 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 * 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, +1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, +1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -1, +1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, +1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num > heap[1]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[1]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num > heap[-1]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[-1]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif num > heap[0]:",
      "mutated_line": "elif num > heap[1]:",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[1]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "heap[0] = num",
      "mutated_line": "heap[1] = num",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[1] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "heap[0] = num",
      "mutated_line": "heap[-1] = num",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[-1] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "heap[0] = num",
      "mutated_line": "heap[1] = num",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[1] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "heapify(heap, k, 0)",
      "mutated_line": "heapify(heap, k, 1)",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 1)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "heapify(heap, k, 0)",
      "mutated_line": "heapify(heap, k, -1)",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, -1)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "heapify(heap, k, 0)",
      "mutated_line": "heapify(heap, k, 1)",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 1)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k / 2 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k / 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k * 2 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k * 2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 2, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 2, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 0, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 0, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 0, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 0, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - -1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - -1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -2, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -2, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -0, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -0, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -0, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -0, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, --1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, --1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -1, -2):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -2):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -1, -0):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -0):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -1, -0):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, -0):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 2 - 1, -1, --1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 2 - 1, -1, --1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 3 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 3 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 1 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 1 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 0 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 0 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // 1 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // 1 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(k//2 - 1, -1, -1):",
      "mutated_line": "for i in range(k // -2 - 1, -1, -1):",
      "code": "def find_kth_largest(nums, k):\n    \"\"\"\n    This function takes an array `nums` of size n and an integer `k` as input and returns the kth largest element.\n    \n    The function uses a min heap data structure without utilizing any built-in sorting or priority queue functions and does not use extra space.\n    \n    The time complexity is O(n log k) and the space complexity is O(1).\n\n    :param nums: An array of integers\n    :param k: An integer representing the kth largest element to find\n    :return: The kth largest element in the array\n    \"\"\"\n\n    def heapify(heap, n, i):\n        \"\"\"\n        Helper function to maintain the heap property.\n\n        :param heap: The min heap\n        :param n: The size of the heap\n        :param i: The index of the current node\n        :return: None\n        \"\"\"\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest != i:\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i])\n            heapify(heap, n, smallest)\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heap.append(num)\n            if len(heap) == k:\n                for i in range(k // -2 - 1, -1, -1):\n                    heapify(heap, k, i)\n        elif num > heap[0]:\n            heap[0] = num\n            heapify(heap, k, 0)\n    return heap[0]"
    }
  ]
}