{
  "task_id": "cf_3298",
  "entry_point": "shortest_path",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [float('inf')] * num_nodes",
      "mutated_line": "distances = [float('inf')] / num_nodes",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] / num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [float('inf')] * num_nodes",
      "mutated_line": "distances = [float('inf')] + num_nodes",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] + num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "distances = [float('inf')] * num_nodes",
      "mutated_line": "distances = [float('inf')] ** num_nodes",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] ** num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 1\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = -1",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = -1\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 1\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_node == end_node:",
      "mutated_line": "if current_node != end_node:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node != end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = [(0, start_node)]",
      "mutated_line": "queue = [(1, start_node)]",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(1, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = [(0, start_node)]",
      "mutated_line": "queue = [(-1, start_node)]",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(-1, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = [(0, start_node)]",
      "mutated_line": "queue = [(1, start_node)]",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(1, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while current_node is not None:",
      "mutated_line": "while current_node is None:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight >= 0:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight >= 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight <= 0:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight <= 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight != 0:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight != 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances = [float('inf')] * num_nodes",
      "mutated_line": "distances = [float('')] * num_nodes",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > 1:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > -1:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > -1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if weight > 0:",
      "mutated_line": "if weight > 1:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 1:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance - weight",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance - weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance * weight",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance * weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance <= distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance >= distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(0, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance != distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(1, current_node)",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(1, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(-1, current_node)",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(-1, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path.insert(0, current_node)",
      "mutated_line": "path.insert(1, current_node)",
      "code": "import heapq\n\ndef shortest_path(distance_matrix, start_node, end_node):\n    num_nodes = len(distance_matrix)\n    distances = [float('inf')] * num_nodes\n    distances[start_node] = 0\n    queue = [(0, start_node)]\n    heapq.heapify(queue)\n    parent = {start_node: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == end_node:\n            path = []\n            while current_node is not None:\n                path.insert(1, current_node)\n                current_node = parent[current_node]\n            return path\n        for neighbor in range(num_nodes):\n            weight = distance_matrix[current_node][neighbor]\n            if weight > 0:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parent[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n    return []"
    }
  ]
}