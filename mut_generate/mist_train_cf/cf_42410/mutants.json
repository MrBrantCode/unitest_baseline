{
  "task_id": "cf_42410",
  "entry_point": "simulate_robot_motion",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x -= v * np.cos(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x -= v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y -= v * np.sin(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y -= v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "theta += omega * time_interval",
      "mutated_line": "theta -= omega * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta -= omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += v * np.cos(theta) / time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) / time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += v * np.cos(theta) + time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) + time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += (v * np.cos(theta)) ** time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += (v * np.cos(theta)) ** time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += v * np.sin(theta) / time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) / time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += v * np.sin(theta) + time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) + time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += (v * np.sin(theta)) ** time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += (v * np.sin(theta)) ** time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "theta += omega * time_interval",
      "mutated_line": "theta += omega / time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega / time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "theta += omega * time_interval",
      "mutated_line": "theta += omega + time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega + time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "theta += omega * time_interval",
      "mutated_line": "theta += omega ** time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega ** time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) * (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = theta + 2 * np.pi + 2 * np.pi\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += v / np.cos(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v / np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += (v + np.cos(theta)) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += (v + np.cos(theta)) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x += v * np.cos(theta) * time_interval",
      "mutated_line": "x += v ** np.cos(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v ** np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += v / np.sin(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v / np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += (v + np.sin(theta)) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += (v + np.sin(theta)) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y += v * np.sin(theta) * time_interval",
      "mutated_line": "y += v ** np.sin(theta) * time_interval",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v ** np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta - 2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = theta * (2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 / np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (2 + np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % 2 ** np.pi\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 / np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + (2 + np.pi)) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 ** np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (3 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (1 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (0 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (1 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 2 * np.pi) % (-2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 3 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 1 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 0 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + 1 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "theta = (theta + 2 * np.pi) % (2 * np.pi)",
      "mutated_line": "return (x, y, theta)",
      "code": "import numpy as np\n\ndef simulate_robot_motion(initial_pose, linear_velocity, angular_velocity, time_interval):\n    (x, y, theta) = initial_pose\n    v = linear_velocity\n    omega = angular_velocity\n    x += v * np.cos(theta) * time_interval\n    y += v * np.sin(theta) * time_interval\n    theta += omega * time_interval\n    theta = (theta + -2 * np.pi) % (2 * np.pi)\n    return (x, y, theta)"
    }
  ]
}