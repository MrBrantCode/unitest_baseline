{
  "task_id": "cf_56158",
  "entry_point": "segregate_and_sort",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "partition_size = len(arr) // n",
      "mutated_line": "partition_size = len(arr) / n",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) / n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "partition_size = len(arr) // n",
      "mutated_line": "partition_size = len(arr) * n",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) * n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "remaining = len(arr) % n",
      "mutated_line": "remaining = len(arr) * n",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) * n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "remaining = len(arr) % n",
      "mutated_line": "remaining = len(arr) + n",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) + n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "start_index = 0",
      "mutated_line": "start_index = 1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 1\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "start_index = 0",
      "mutated_line": "start_index = -1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = -1\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "start_index = 0",
      "mutated_line": "start_index = 1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 1\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end_index = start_index + partition_size",
      "mutated_line": "end_index = start_index - partition_size",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index - partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end_index = start_index + partition_size",
      "mutated_line": "end_index = start_index * partition_size",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index * partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining >= 0:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining >= 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining <= 0:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining <= 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining != 0:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining != 0:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "end_index += 1",
      "mutated_line": "end_index -= 1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index -= 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "remaining -= 1",
      "mutated_line": "remaining += 1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining += 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining > 1:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 1:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining > -1:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > -1:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if remaining > 0:",
      "mutated_line": "if remaining > 1:",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 1:\n            end_index += 1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "end_index += 1",
      "mutated_line": "end_index += 2",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 2\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "end_index += 1",
      "mutated_line": "end_index += 0",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 0\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "end_index += 1",
      "mutated_line": "end_index += 0",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 0\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "end_index += 1",
      "mutated_line": "end_index += -1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += -1\n            remaining -= 1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "remaining -= 1",
      "mutated_line": "remaining -= 2",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 2\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "remaining -= 1",
      "mutated_line": "remaining -= 0",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 0\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "remaining -= 1",
      "mutated_line": "remaining -= 0",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= 0\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "remaining -= 1",
      "mutated_line": "remaining -= -1",
      "code": "def segregate_and_sort(arr, n):\n    sorted_arr = sorted(arr)\n    partition_size = len(arr) // n\n    remaining = len(arr) % n\n    start_index = 0\n    result = []\n    for i in range(n):\n        end_index = start_index + partition_size\n        if remaining > 0:\n            end_index += 1\n            remaining -= -1\n        result.append(sorted_arr[start_index:end_index])\n        start_index = end_index\n    return result"
    }
  ]
}