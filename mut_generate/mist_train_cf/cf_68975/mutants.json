{
  "task_id": "cf_68975",
  "entry_point": "is_d_separated",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current_node == target_node:",
      "mutated_line": "if current_node != target_node:",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node != target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return True\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return False\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if neighbor == avoid_node or neighbor in visited:",
      "mutated_line": "if neighbor == avoid_node and neighbor in visited:",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node and neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if neighbor == avoid_node or neighbor in visited:",
      "mutated_line": "if neighbor != avoid_node or neighbor in visited:",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor != avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if neighbor == avoid_node or neighbor in visited:",
      "mutated_line": "if neighbor == avoid_node or neighbor not in visited:",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor not in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return True\n        return False\n    return not dfs(X, Y, Z)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_d_separated(bayesian_network, X, Y, Z):\n    \"\"\"\n    Checks if nodes X and Y are d-separated given node Z in a Bayesian network.\n    \n    Args:\n    bayesian_network (dict): A dictionary representing the Bayesian network where each key is a node and its corresponding value is a list of its neighbors.\n    X (node): The first node.\n    Y (node): The second node.\n    Z (node): The node to check for d-separation.\n    \n    Returns:\n    bool: True if X and Y are d-separated given Z, False otherwise.\n    \"\"\"\n    visited = set()\n\n    def dfs(current_node, target_node, avoid_node):\n        visited.add(current_node)\n        if current_node == target_node:\n            return True\n        for neighbor in bayesian_network.get(current_node, []):\n            if neighbor == avoid_node or neighbor in visited:\n                continue\n            if dfs(neighbor, target_node, avoid_node):\n                return False\n        return False\n    return not dfs(X, Y, Z)"
    }
  ]
}