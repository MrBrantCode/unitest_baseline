{
  "task_id": "cf_77109",
  "entry_point": "shortest_path_and_weight",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_distances[start] = 0",
      "mutated_line": "shortest_distances[start] = 1",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 1\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_distances[start] = 0",
      "mutated_line": "shortest_distances[start] = -1",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = -1\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_distances[start] = 0",
      "mutated_line": "shortest_distances[start] = 1",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 1\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while current is not None:",
      "mutated_line": "while current is None:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist != shortest_distances[node]:",
      "mutated_line": "if dist == shortest_distances[node]:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist == shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if adj_matrix[i][j] != 0:",
      "mutated_line": "if adj_matrix[i][j] == 0:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] == 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}",
      "mutated_line": "shortest_distances = {node: float('') for node in range(len(adj_matrix))}",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(1, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(-1, start)]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(-1, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(1, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_dist = dist + weight",
      "mutated_line": "new_dist = dist - weight",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist - weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_dist = dist + weight",
      "mutated_line": "new_dist = dist * weight",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist * weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist <= old_dist:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist <= old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist >= old_dist:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist >= old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist != old_dist:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist != old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "path = path[::-1]",
      "mutated_line": "path = path[::+1]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::+1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if adj_matrix[i][j] != 0:",
      "mutated_line": "if adj_matrix[i][j] != 1:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 1:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if adj_matrix[i][j] != 0:",
      "mutated_line": "if adj_matrix[i][j] != -1:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != -1:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if adj_matrix[i][j] != 0:",
      "mutated_line": "if adj_matrix[i][j] != 1:",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 1:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "path = path[::-1]",
      "mutated_line": "path = path[::-2]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-2]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "path = path[::-1]",
      "mutated_line": "path = path[::-0]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-0]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "path = path[::-1]",
      "mutated_line": "path = path[::-0]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::-0]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "path = path[::-1]",
      "mutated_line": "path = path[::--1]",
      "code": "import heapq\n\ndef shortest_path_and_weight(adj_matrix, start, end):\n    adj_list = {node: {} for node in range(len(adj_matrix))}\n    for i in range(len(adj_matrix)):\n        for j in range(len(adj_matrix[i])):\n            if adj_matrix[i][j] != 0:\n                adj_list[i][j] = adj_matrix[i][j]\n    shortest_distances = {node: float('inf') for node in range(len(adj_matrix))}\n    shortest_distances[start] = 0\n    heap = [(0, start)]\n    ancestors = {node: None for node in range(len(adj_matrix))}\n    while heap:\n        (dist, node) = heapq.heappop(heap)\n        if dist != shortest_distances[node]:\n            continue\n        for (neighbor, weight) in adj_list[node].items():\n            old_dist = shortest_distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                shortest_distances[neighbor] = new_dist\n                ancestors[neighbor] = node\n                heapq.heappush(heap, (new_dist, neighbor))\n    path = []\n    current = end\n    while current is not None:\n        path.append(current)\n        current = ancestors[current]\n    path = path[::--1]\n    weight = shortest_distances[end]\n    return (adj_list, path, weight)"
    }
  ]
}