{
  "task_id": "cf_47621",
  "entry_point": "constrainedSubsetSum",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([0] / n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] / n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([0] + n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] + n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([0] ** n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] ** n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[1] = nums[0]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[1] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[-1] = nums[0]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[-1] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[1] = nums[0]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[1] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[0] = nums[1]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[1]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[0] = nums[-1]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[-1]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0] = nums[0]",
      "mutated_line": "dp[0] = nums[1]",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[1]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(2, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(0, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(0, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(-1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue or queue[0][1] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue or queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i] > m: return m",
      "mutated_line": "dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] >= m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i] > m: return m",
      "mutated_line": "dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] <= m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i] > m: return m",
      "mutated_line": "dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] != m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] >= 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] <= 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] != 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [+dp[0], 0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [+dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[0], 1])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 1])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[0], -1])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], -1])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[0], 1])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 1])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][1] <= i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] <= i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][1] >= i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] >= i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][1] != i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] != i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 1:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > -1:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 1:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([1] * n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([1] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([-1] * n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([-1] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp, queue = [0]*n, []",
      "mutated_line": "(dp, queue) = ([1] * n, [])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([1] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][1] < i + k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i + k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][1] < i * k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i * k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] + queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] * queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[1], 0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[1], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[-1], 0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[-1], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(queue, [-dp[0], 0])",
      "mutated_line": "heapq.heappush(queue, [-dp[1], 0])",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[1], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][2] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][2] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][0] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][0] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][0] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][0] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[0][-1] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][-1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if dp[i] > 0: heapq.heappush(queue, [-dp[i], i])",
      "mutated_line": "if dp[i] > m:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [+dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[1][1] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[1][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[-1][1] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[-1][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while queue and queue[0][1] < i-k: heapq.heappop(queue)",
      "mutated_line": "while queue and queue[1][1] < i - k:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[1][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][1])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][-1])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[0][1])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[1][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[-1][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if queue: dp[i] = max(dp[i], nums[i] - queue[0][0])",
      "mutated_line": "if queue:",
      "code": "import heapq\n\ndef constrainedSubsetSum(nums, k, m):\n    n = len(nums)\n    (dp, queue) = ([0] * n, [])\n    dp[0] = nums[0]\n    heapq.heappush(queue, [-dp[0], 0])\n    for i in range(1, n):\n        while queue and queue[0][1] < i - k:\n            heapq.heappop(queue)\n        dp[i] = nums[i]\n        if queue:\n            dp[i] = max(dp[i], nums[i] - queue[1][0])\n        if dp[i] > m:\n            return m\n        if dp[i] > 0:\n            heapq.heappush(queue, [-dp[i], i])\n    return max(dp)"
    }
  ]
}