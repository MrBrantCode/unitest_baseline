{
  "task_id": "cf_12110",
  "entry_point": "combination_sum",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target or len(curr_combination) >= 2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target or len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum >= target:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum >= target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum <= target:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum <= target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum != target:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum != target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(1, [], 0)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(1, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(-1, [], 0)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(-1, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(1, [], 0)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(1, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(0, [], 1)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(0, [], -1)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], -1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "backtrack(0, [], 0)",
      "mutated_line": "backtrack(0, [], 1)",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum != target and len(curr_combination) >= 2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum != target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) > 2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) > 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) < 2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) < 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) == 2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) == 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start or nums[i] == nums[i - 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start or nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) >= 3:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 3:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) >= 1:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 1:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) >= 0:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 0:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) >= 1:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 1:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if curr_sum == target and len(curr_combination) >= 2:",
      "mutated_line": "if curr_sum == target and len(curr_combination) >= -2:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= -2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i >= start and nums[i] == nums[i - 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i >= start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i <= start and nums[i] == nums[i - 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i <= start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i != start and nums[i] == nums[i - 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i != start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] != nums[i - 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] != nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i - 1, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i - 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i * 1, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i * 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + 1, curr_combination, curr_sum - nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum - nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + 1, curr_combination, curr_sum * nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum * nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + 2, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 2, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + 0, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 0, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + 0, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 0, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "backtrack(i + 1, curr_combination, curr_sum + nums[i])",
      "mutated_line": "backtrack(i + -1, curr_combination, curr_sum + nums[i])",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + -1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i + 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i + 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i * 1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i * 1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i - 2]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 2]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i > start and nums[i] == nums[i - 1]:  # Skip duplicate elements",
      "mutated_line": "if i > start and nums[i] == nums[i - -1]:",
      "code": "def combination_sum(nums, target):\n\n    def backtrack(start, curr_combination, curr_sum):\n        if curr_sum == target and len(curr_combination) >= 2:\n            result.append(curr_combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - -1]:\n                continue\n            curr_combination.append(nums[i])\n            backtrack(i + 1, curr_combination, curr_sum + nums[i])\n            curr_combination.pop()\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result"
    }
  ]
}