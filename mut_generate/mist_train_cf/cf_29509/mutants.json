{
  "task_id": "cf_29509",
  "entry_point": "dijkstra_shortest_path",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 1\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = -1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = -1\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[source] = 0",
      "mutated_line": "distances[source] = 1",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 1\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance >= distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance >= distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance <= distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance <= distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance != distances[current_node]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance != distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(0, source)]",
      "mutated_line": "heap = [(1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(1, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(0, source)]",
      "mutated_line": "heap = [(-1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(-1, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heap = [(0, source)]",
      "mutated_line": "heap = [(1, source)]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(1, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "distance = current_distance + weights[(current_node, neighbor)]",
      "mutated_line": "distance = current_distance - weights[current_node, neighbor]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance - weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "distance = current_distance + weights[(current_node, neighbor)]",
      "mutated_line": "distance = current_distance * weights[current_node, neighbor]",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance * weights[current_node, neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance <= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance >= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra_shortest_path(graph, weights, source):\n    distances = {node: float('inf') for node in graph}\n    distances[source] = 0\n    heap = [(0, source)]\n    while heap:\n        (current_distance, current_node) = heapq.heappop(heap)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weights[current_node, neighbor]\n            if distance != distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n    return distances"
    }
  ]
}