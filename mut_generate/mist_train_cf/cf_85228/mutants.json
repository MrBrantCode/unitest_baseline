{
  "task_id": "cf_85228",
  "entry_point": "cycpattern_check",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"\"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]",
      "mutated_line": "return any((permutation in a_clean for permutation in cyclic_permutations))",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] - b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]",
      "mutated_line": "return any((permutation in a_clean for permutation in cyclic_permutations))",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] * b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return any(permutation in a_clean for permutation in cyclic_permutations)",
      "mutated_line": "return any((permutation not in a_clean for permutation in cyclic_permutations))",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation not in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a_clean = re.sub(r'\\W+', '', a).lower()",
      "mutated_line": "b_clean = re.sub('\\\\W+', '', b).lower()",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('', '', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a_clean = re.sub(r'\\W+', '', a).lower()",
      "mutated_line": "b_clean = re.sub('\\\\W+', '', b).lower()",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', 'MUTATED', a).lower()\n    b_clean = re.sub('\\\\W+', '', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b_clean = re.sub(r'\\W+', '', b).lower()",
      "mutated_line": "b_clean = re.sub('', '', b).lower()",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('', '', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b_clean = re.sub(r'\\W+', '', b).lower()",
      "mutated_line": "b_clean = re.sub('\\\\W+', 'MUTATED', b).lower()",
      "code": "import re\n\ndef cycpattern_check(a, b):\n    \"\"\"Checks if the second string or any of its cyclic permutations are found as a continuous subsequence within the first string.\n    \n    The function ignores case and special characters, accommodates various language-specific characters, and ensures optimal performance for longer string lengths.\n    \"\"\"\n    a_clean = re.sub('\\\\W+', '', a).lower()\n    b_clean = re.sub('\\\\W+', 'MUTATED', b).lower()\n    cyclic_permutations = [b_clean[i:] + b_clean[:i] for i in range(len(b_clean))]\n    return any((permutation in a_clean for permutation in cyclic_permutations))"
    }
  ]
}