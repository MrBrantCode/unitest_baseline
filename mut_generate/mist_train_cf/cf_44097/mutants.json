{
  "task_id": "cf_44097",
  "entry_point": "complex_encode",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(s) == 0:",
      "mutated_line": "if len(s) != 0:",
      "code": "def complex_encode(s, n):\n    if len(s) != 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) == 0:",
      "mutated_line": "if len(s) == 1:",
      "code": "def complex_encode(s, n):\n    if len(s) == 1:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) == 0:",
      "mutated_line": "if len(s) == -1:",
      "code": "def complex_encode(s, n):\n    if len(s) == -1:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if len(s) == 0:",
      "mutated_line": "if len(s) == 1:",
      "code": "def complex_encode(s, n):\n    if len(s) == 1:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char - complex_encode(s[1:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char - complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char * complex_encode(s[1:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char * complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_char = s[0]",
      "mutated_line": "new_char = s[1]",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[1]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_char = s[0]",
      "mutated_line": "new_char = s[-1]",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[-1]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_char = s[0]",
      "mutated_line": "new_char = s[1]",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[1]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 26 - ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 - ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 26 * ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 * ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ascii_offset = ord('A') if new_char.isupper() else ord('a')",
      "mutated_line": "ascii_offset = ord('') if new_char.isupper() else ord('a')",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ascii_offset = ord('A') if new_char.isupper() else ord('a')",
      "mutated_line": "ascii_offset = ord('A') if new_char.isupper() else ord('')",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) * 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) * 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr(ord(new_char) - ascii_offset + n + 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr(ord(new_char) - ascii_offset + n + 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) * 10)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) * 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str(int(new_char) + n + 10)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str(int(new_char) + n + 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset - n) % 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset - n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset) * n % 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset) * n % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 27 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 27 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 25 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 25 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 0 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 0 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % 1 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 1 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) - ascii_offset + n) % -26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % -26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) - n) % 10)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) - n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str(int(new_char) * n % 10)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str(int(new_char) * n % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) % 11)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 11)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) % 9)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 9)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) % 0)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 0)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) % 1)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 1)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "new_char = str((int(new_char) + n) % 10)",
      "mutated_line": "new_char = str((int(new_char) + n) % -10)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % -10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char + complex_encode(s[2:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[2:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char + complex_encode(s[0:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[0:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char + complex_encode(s[0:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[0:], n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return new_char + complex_encode(s[1:], n)",
      "mutated_line": "return new_char + complex_encode(s[-1:], n)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) - ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[-1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) + ascii_offset + n) % 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) + ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new_char = chr(((ord(new_char) - ascii_offset + n) % 26) + ascii_offset)",
      "mutated_line": "new_char = chr((ord(new_char) * ascii_offset + n) % 26 + ascii_offset)",
      "code": "def complex_encode(s, n):\n    if len(s) == 0:\n        return s\n    else:\n        new_char = s[0]\n        if new_char.isalpha():\n            ascii_offset = ord('A') if new_char.isupper() else ord('a')\n            new_char = chr((ord(new_char) * ascii_offset + n) % 26 + ascii_offset)\n        elif new_char.isdigit():\n            new_char = str((int(new_char) + n) % 10)\n        return new_char + complex_encode(s[1:], n)"
    }
  ]
}