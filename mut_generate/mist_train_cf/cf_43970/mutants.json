{
  "task_id": "cf_43970",
  "entry_point": "highestPeak",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[0] / n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] / n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[0] + n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] + n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[0] ** n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] ** n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if isWater[i][j] == 1:",
      "mutated_line": "if isWater[i][j] != 1:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] != 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or heights[nx][ny] == 0 or (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n or heights[nx][ny] == 0 or (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(isWater), len(isWater[0])",
      "mutated_line": "(m, n) = (len(isWater), len(isWater[1]))",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[1]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(isWater), len(isWater[0])",
      "mutated_line": "(m, n) = (len(isWater), len(isWater[-1]))",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[-1]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(isWater), len(isWater[0])",
      "mutated_line": "(m, n) = (len(isWater), len(isWater[1]))",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[1]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[1] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[1] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[-1] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[-1] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heights = [[0]*n for _ in range(m)]",
      "mutated_line": "heights = [[1] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[1] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if isWater[i][j] == 1:",
      "mutated_line": "if isWater[i][j] == 2:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 2:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if isWater[i][j] == 1:",
      "mutated_line": "if isWater[i][j] == 0:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 0:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if isWater[i][j] == 1:",
      "mutated_line": "if isWater[i][j] == 0:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 0:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if isWater[i][j] == 1:",
      "mutated_line": "if isWater[i][j] == -1:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == -1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heights[i][j] = 0",
      "mutated_line": "heights[i][j] = 1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 1\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heights[i][j] = 0",
      "mutated_line": "heights[i][j] = -1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = -1\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "heights[i][j] = 0",
      "mutated_line": "heights[i][j] = 1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 1\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] != 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] != 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] != 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] != 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] - 1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] - 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] * 1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] * 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 1) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 1) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == -1) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == -1) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 1) and (isWater[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 1) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 1):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == -1):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == -1):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and heights[nx][ny] == 0 and isWater[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 1):\n                heights[nx][ny] = heights[x][y] + 1\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] + 2",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 2\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] + 0",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 0\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] + 0",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + 0\n                queue.append((nx, ny))\n    return heights"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heights[nx][ny] = heights[x][y] + 1",
      "mutated_line": "heights[nx][ny] = heights[x][y] + -1",
      "code": "from collections import deque\n\ndef highestPeak(isWater):\n    (m, n) = (len(isWater), len(isWater[0]))\n    heights = [[0] * n for _ in range(m)]\n    queue = deque()\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j] == 1:\n                heights[i][j] = 0\n                queue.append((i, j))\n    while queue:\n        (x, y) = queue.popleft()\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n and (heights[nx][ny] == 0) and (isWater[nx][ny] == 0):\n                heights[nx][ny] = heights[x][y] + -1\n                queue.append((nx, ny))\n    return heights"
    }
  ]
}