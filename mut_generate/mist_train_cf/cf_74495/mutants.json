{
  "task_id": "cf_74495",
  "entry_point": "determine_big_o",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def determine_big_o(f, n_max=1000):",
      "mutated_line": "def determine_big_o(f, n_max=1001):",
      "code": "def determine_big_o(f, n_max=1001):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def determine_big_o(f, n_max=1000):",
      "mutated_line": "def determine_big_o(f, n_max=999):",
      "code": "def determine_big_o(f, n_max=999):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def determine_big_o(f, n_max=1000):",
      "mutated_line": "def determine_big_o(f, n_max=0):",
      "code": "def determine_big_o(f, n_max=0):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def determine_big_o(f, n_max=1000):",
      "mutated_line": "def determine_big_o(f, n_max=1):",
      "code": "def determine_big_o(f, n_max=1):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def determine_big_o(f, n_max=1000):",
      "mutated_line": "def determine_big_o(f, n_max=-1000):",
      "code": "def determine_big_o(f, n_max=-1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 'O(f(n))'",
      "mutated_line": "return ''",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 * i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 * i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 + i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 + i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 'O(1)'",
      "mutated_line": "return ''",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return ''\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 'O(log n)'",
      "mutated_line": "return ''",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return ''\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 'O(n)'",
      "mutated_line": "if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return ''\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n_log_n_values = [n * log_n for n, log_n in zip(n_values, log_n_values)]",
      "mutated_line": "if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n / log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n_log_n_values = [n * log_n for n, log_n in zip(n_values, log_n_values)]",
      "mutated_line": "if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n + log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n_log_n_values = [n * log_n for n, log_n in zip(n_values, log_n_values)]",
      "mutated_line": "if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n ** log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 'O(n log n)'",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return ''\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n * 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n + 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 'O(n^2)'",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return ''\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 * n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 + n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return 'O(2^n)'",
      "mutated_line": "return ''",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return ''\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [3 ** i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [3 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [1 ** i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [1 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [0 ** i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [0 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [1 ** i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [1 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [-2 ** i for i in range(10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [-2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if all(result == results[0] for result in results):",
      "mutated_line": "if all((result != results[0] for result in results)):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result != results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if all(result == log_n_value for result, log_n_value in zip(results, log_n_values)):",
      "mutated_line": "if all((result != log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result != log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if all(result == n for result, n in zip(results, n_values)):",
      "mutated_line": "if all((result != n for (result, n) in zip(results, n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result != n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if all(result == n_log_n for result, n_log_n in zip(results, n_log_n_values)):",
      "mutated_line": "if all((result != n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result != n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 3 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 1 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 0 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 1 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "n_squared_values = [n**2 for n in n_values]",
      "mutated_line": "if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** -2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if all(result == n_squared for result, n_squared in zip(results, n_squared_values)):",
      "mutated_line": "if all((result != n_squared for (result, n_squared) in zip(results, n_squared_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result != n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [3 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [1 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [0 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [1 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "two_pow_n_values = [2**n for n in n_values]",
      "mutated_line": "if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [-2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if all(result == two_pow_n for result, two_pow_n in zip(results, two_pow_n_values)):",
      "mutated_line": "if all((result != two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result != two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 ** i for i in range(11)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(11)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 ** i for i in range(9)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(9)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 ** i for i in range(0)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(0)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 ** i for i in range(1)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(1)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n_values = [2**i for i in range(10)]",
      "mutated_line": "n_values = [2 ** i for i in range(-10)]",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(-10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "log_n_values = [i for i in range(10)]",
      "mutated_line": "if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(11)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "log_n_values = [i for i in range(10)]",
      "mutated_line": "if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(9)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "log_n_values = [i for i in range(10)]",
      "mutated_line": "if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(0)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "log_n_values = [i for i in range(10)]",
      "mutated_line": "if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(1)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "log_n_values = [i for i in range(10)]",
      "mutated_line": "if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[0] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(-10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if all(result == results[0] for result in results):",
      "mutated_line": "if all((result == results[1] for result in results)):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[1] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if all(result == results[0] for result in results):",
      "mutated_line": "if all((result == results[-1] for result in results)):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[-1] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if all(result == results[0] for result in results):",
      "mutated_line": "if all((result == results[1] for result in results)):",
      "code": "def determine_big_o(f, n_max=1000):\n    \"\"\"\n    Determine the time complexity of an algorithm using Big O notation.\n\n    Args:\n    f (function): A function representing the number of basic operations required by an algorithm for a given input of size n.\n    n_max (int): The maximum input size to test. Defaults to 1000.\n\n    Returns:\n    str: The time complexity of the algorithm in Big O notation.\n    \"\"\"\n    n_values = [2 ** i for i in range(10)]\n    results = [f(n) for n in n_values]\n    if all((result == results[1] for result in results)):\n        return 'O(1)'\n    log_n_values = [i for i in range(10)]\n    if all((result == log_n_value for (result, log_n_value) in zip(results, log_n_values))):\n        return 'O(log n)'\n    if all((result == n for (result, n) in zip(results, n_values))):\n        return 'O(n)'\n    n_log_n_values = [n * log_n for (n, log_n) in zip(n_values, log_n_values)]\n    if all((result == n_log_n for (result, n_log_n) in zip(results, n_log_n_values))):\n        return 'O(n log n)'\n    n_squared_values = [n ** 2 for n in n_values]\n    if all((result == n_squared for (result, n_squared) in zip(results, n_squared_values))):\n        return 'O(n^2)'\n    two_pow_n_values = [2 ** n for n in n_values]\n    if all((result == two_pow_n for (result, two_pow_n) in zip(results, two_pow_n_values))):\n        return 'O(2^n)'\n    return 'O(f(n))'"
    }
  ]
}