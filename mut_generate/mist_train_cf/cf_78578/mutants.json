{
  "task_id": "cf_78578",
  "entry_point": "entrance",
  "mutant_count": 430,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return +1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if id(b) in used:",
      "mutated_line": "if id(b) not in used:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) not in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b != [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b != [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -2\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -0\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -0\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return --1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(4):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(4):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(2):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(2):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(0):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(0):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(1):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(1):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(-3):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(-3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({-1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({-1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({1: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 2: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 2: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 0: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 0: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 0: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 0: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, -1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, -1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 3: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 3: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 1: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 1: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 0: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 0: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 1: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 1: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, -2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, -2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 4: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 4: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 2: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 2: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 0: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 0: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 1: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 1: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, -3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, -3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 5: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 5: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 3: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 3: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 0: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 0: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 1: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 1: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, -4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, -4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 6: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 6: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 4: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 4: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 0: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 0: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 1: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 1: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, -5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, -5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 7: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 7: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 5: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 5: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 0: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 0: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 1: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 1: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, -6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, -6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 8: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 8: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 6: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 6: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 0: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 0: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 1: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 1: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, -7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, -7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 9: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 9: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 7: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 7: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 0: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 0: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 1: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 1: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, -8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, -8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nei in moves:",
      "mutated_line": "if nei not in moves:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei not in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(3):",
      "mutated_line": "for j in range(4):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(4):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(3):",
      "mutated_line": "for j in range(2):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(2):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(3):",
      "mutated_line": "for j in range(0):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(0):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(3):",
      "mutated_line": "for j in range(1):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(1):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(3):",
      "mutated_line": "for j in range(-3):",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(-3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if board[i][j] == 0:",
      "mutated_line": "if board[i][j] != 0:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] != 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(1, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(1, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(-1, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(-1, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(1, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(1, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 2), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 2), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, -1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, -1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, +1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, +1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (2, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (2, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, -1), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, -1), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (+1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (+1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, -1)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, -1)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] - d[0], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] - d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] * d[0], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] * d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] - d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] - d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] * d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] * d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if board[i][j] == 0:",
      "mutated_line": "if board[i][j] == 1:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 1:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if board[i][j] == 0:",
      "mutated_line": "if board[i][j] == -1:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == -1:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if board[i][j] == 0:",
      "mutated_line": "if board[i][j] == 1:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 1:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(2, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(2, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(0, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(0, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(0, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(0, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(-1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(-1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 4), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 4), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 2), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 2), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 0), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 0), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 1), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 1), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, -3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, -3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (-1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (-1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (1, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, -1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, -1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 1)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(-1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(-1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(1, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 2), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 2), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 0), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 0), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 0), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 0), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, -1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, -1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (-1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (-1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (1, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, -1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, -1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 1)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(-1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(-1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(1, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 3), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 3), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 1), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 1), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 0), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 0), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 1), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 1), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, -2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, -2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (-1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (-1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (1, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 2)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 2)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 0)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 0)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 0)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 0)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, -1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, -1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(2, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(2, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(0, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(0, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(0, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(0, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(-1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(-1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, -1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, -1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 1), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (-1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (-1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (1, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, -1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, -1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "moves, used, heap = {0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 1)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(2, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(2, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(0, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(0, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(0, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(0, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(-1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(-1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 2), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 2), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 0), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 0), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 0), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 0), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, -1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, -1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (-1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (-1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (1, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, -1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, -1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 1)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(2, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(2, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(0, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(0, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(0, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(0, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(-1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(-1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 3), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 3), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 1), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 1), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 0), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 0), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 1), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 1), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, -2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, -2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (-1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (-1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (1, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 2)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 2)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 0)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 0)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 0)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 0)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, -1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, -1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(3, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(3, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(1, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(1, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(0, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(0, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(1, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(1, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(-2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(-2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, -1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, -1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 1), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (2, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (2, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (0, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (0, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (0, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (0, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (-1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (-1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, -1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, -1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)},",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 1)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(3, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(3, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(1, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(1, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(0, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(0, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(1, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(1, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(-2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(-2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 2), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 2), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 0), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 0), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 0), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 0), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, -1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, -1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (2, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (2, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (0, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (0, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (0, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (0, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (-1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (-1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, -1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, -1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 1)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(3, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(3, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(1, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(1, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(0, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(0, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(1, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(1, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(-2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(-2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 3), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 3), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 1), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 1), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 0), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 0), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 1), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 1), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, -2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, -2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (2, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (2, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (0, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (0, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (0, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (0, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (-1, 1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (-1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 2)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 2)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 0)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 0)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 0)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 0)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))]",
      "mutated_line": "(moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, -1)}}, set(), [(0, id(board), board, findZero(board))])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, -1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[2, 2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[2, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[0, 2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[0, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[0, 2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[0, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[-1, 2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[-1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 3, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 3, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 1, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 1, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 0, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 0, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 1, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 1, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, -2, 3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, -2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 4], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 4], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 2], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 2], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 0], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 0], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 1], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 1], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, -3], [4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, -3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [5, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [5, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [3, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [3, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [0, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [0, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [1, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [1, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [-4, 5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [-4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 6, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 6, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 4, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 4, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 0, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 0, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 1, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 1, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, -5, 6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, -5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 7], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 7], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 5], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 5], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 0], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 0], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 1], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 1], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, -6], [7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, -6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [8, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [8, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [6, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [6, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [0, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [0, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [1, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [1, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [-7, 8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [-7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 9, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 9, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 7, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 7, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 0, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 0, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 1, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 1, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, -8, 0]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, -8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 8, 1]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 1]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 8, -1]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, -1]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == [[1,2,3],[4,5,6],[7,8,0]]:",
      "mutated_line": "if b == [[1, 2, 3], [4, 5, 6], [7, 8, 1]]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 1]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -2), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -2), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, --1), (1, 0), (-1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, --1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-2, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-2, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for d in [(0, 1), (0, -1), (1, 0), (--1, 0)]:",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (--1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[1] + d[0], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[1] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[-1] + d[0], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[-1] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[1] + d[0], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[1] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[1], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[1], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[-1], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[-1], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[1], zero[1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[1], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[2] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[2] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[0] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[0] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[0] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[0] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[-1] + d[1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[-1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] + d[2])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[2])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] + d[0])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[0])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] + d[0])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[0])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "nei = (zero[0] + d[0], zero[1] + d[1])",
      "mutated_line": "nei = (zero[0] + d[0], zero[1] + d[-1])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[-1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) + abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) + abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, ((cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0])) * abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, ((cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0])) * abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[2]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[2]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[0]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[0]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[0]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[0]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[-1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[-1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[2]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[2]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[0]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[0]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[0]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[0]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[-1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[-1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[2]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[2]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[0]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[0]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[0]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[0]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[-1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[-1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[2]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[2]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[0]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[0]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[0]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[0]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[-1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[-1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) + abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) + abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, ((cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3)))) * abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, ((cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3)))) * abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[-1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[-1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[1]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[-1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[-1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[1]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[1]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[1]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[-1]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[-1]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[1]][nei[1]], B[zero[0]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[1]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[1]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[1]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[-1]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[-1]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B[zero[0]][zero[1]], B[nei[0]][nei[1]] = B[nei[0]][nei[1]], B[zero[0]][zero[1]]",
      "mutated_line": "(B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[1]][zero[1]])",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[1]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 - sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 - sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, ((cost + 1) * sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, ((cost + 1) * sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 + moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 + moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 * moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 * moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost - 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost - 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost * 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost * 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 + moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 + moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 * moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 * moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] / 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] / 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] * 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] * 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 2 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 2 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 0 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 0 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 0 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 0 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + -1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + -1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] * 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] * 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] + 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] + 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 4 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 4 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 2 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 2 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 0 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 0 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 1 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 1 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // -3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // -3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][2]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][2]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][0]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][0]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][0]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][0]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][-1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][-1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) - abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) - abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) * abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) * abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 4 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 4 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 2 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 2 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 0 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 0 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 1 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 1 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % -3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % -3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][-1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][-1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][1]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][2][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][2][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][0][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][0][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][0][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][0][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][-1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][-1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][2][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][2][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][0][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][0][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][0][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][0][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][-1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][-1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[2]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[2]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[0]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[0]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[0]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[0]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[-1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[-1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[1][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[1][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[-1][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[-1][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[1][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[1][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 + moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 + moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 * moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 * moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 + moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 + moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 * moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 * moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(4) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(4) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(2) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(2) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(0) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(0) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(1) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(1) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(-3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(-3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(4))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(4))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(2))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(2))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(0))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(0))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(1))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(1))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(-3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(-3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[2]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[2]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[0]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[0]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[0]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[0]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[-1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[-1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[-1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[-1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[1][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[-1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[-1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "- abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[1]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] * 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] * 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] + 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] + 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] / 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] / 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] * 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] * 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[-1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[-1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(3) for j in range(3)) - abs(b[zero[0]][zero[1]]% 3 - moves[0][1][0])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[1]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 4 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 4 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 2 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 2 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 0 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 0 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 1 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 1 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % -3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % -3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][-1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][-1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][1]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 4 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 4 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 2 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 2 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 0 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 0 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 1 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 1 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // -3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // -3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][2]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][2]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][0]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][0]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][0]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][0]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][-1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][-1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][2][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][2][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][0][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][0][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][0][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][0][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][-1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][-1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][2][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][2][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][0][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][0][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][0][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][0][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(heap, (cost + 1 + sum(abs(B[i][j]%3 - moves[B[i][j]][1][0]) + abs(B[i][j]//3 - moves[B[i][j]][1][1])",
      "mutated_line": "heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][-1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))",
      "code": "from heapq import heappop, heappush\n\ndef entrance(board):\n    (moves, used, heap) = ({0: {(1, 3), (0, 0)}, 1: {(0, 1), (0, 0)}, 2: {(0, 2), (0, 1)}, 3: {(1, 0), (0, 0)}, 4: {(1, 1), (0, 0)}, 5: {(1, 2), (0, 1)}, 6: {(2, 0), (1, 0)}, 7: {(2, 1), (1, 0)}, 8: {(2, 2), (1, 1)}}, set(), [(0, id(board), board, findZero(board))])\n    while heap:\n        (cost, _, b, zero) = heappop(heap)\n        if id(b) in used:\n            continue\n        used.add(id(b))\n        if b == [[1, 2, 3], [4, 5, 6], [7, 8, 0]]:\n            return cost\n        for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nei = (zero[0] + d[0], zero[1] + d[1])\n            if nei in moves:\n                B = [row[:] for row in b]\n                (B[zero[0]][zero[1]], B[nei[0]][nei[1]]) = (B[nei[0]][nei[1]], B[zero[0]][zero[1]])\n                heappush(heap, (cost + 1 + sum((abs(B[i][j] % 3 - moves[B[i][j]][1][0]) + abs(B[i][j] // 3 - moves[B[i][j]][-1][1]) for i in range(3) for j in range(3))) - abs(b[zero[0]][zero[1]] % 3 - moves[0][1][0]) - abs(b[zero[0]][zero[1]] // 3 - moves[0][1][1]), id(B), B, nei))\n    return -1\n\ndef findZero(board):\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == 0:\n                return (i, j)"
    }
  ]
}