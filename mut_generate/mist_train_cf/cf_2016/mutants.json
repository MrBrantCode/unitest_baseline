{
  "task_id": "cf_2016",
  "entry_point": "external_merge_sort",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "chunk_size = 10000  # adjust this value based on available memory",
      "mutated_line": "chunk_size = 10001",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10001\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "chunk_size = 10000  # adjust this value based on available memory",
      "mutated_line": "chunk_size = 9999",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 9999\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "chunk_size = 10000  # adjust this value based on available memory",
      "mutated_line": "chunk_size = 0",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 0\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "chunk_size = 10000  # adjust this value based on available memory",
      "mutated_line": "chunk_size = 1",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 1\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "chunk_size = 10000  # adjust this value based on available memory",
      "mutated_line": "chunk_size = -10000",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = -10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 1 <= len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 <= len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 1 >= len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 >= len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 1 != len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 != len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index - 1 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index - 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index * 1 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index * 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]",
      "mutated_line": "chunks = [data[i:i - chunk_size] for i in range(0, len(data), chunk_size)]",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i - chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]",
      "mutated_line": "chunks = [data[i:i * chunk_size] for i in range(0, len(data), chunk_size)]",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i * chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]",
      "mutated_line": "chunks = [data[i:i + chunk_size] for i in range(1, len(data), chunk_size)]",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(1, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]",
      "mutated_line": "chunks = [data[i:i + chunk_size] for i in range(-1, len(data), chunk_size)]",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(-1, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]",
      "mutated_line": "chunks = [data[i:i + chunk_size] for i in range(1, len(data), chunk_size)]",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(1, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 2 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 2 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 0 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 0 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + 0 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 0 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if element_index + 1 < len(sorted_chunks[chunk_index]):",
      "mutated_line": "if element_index + -1 < len(sorted_chunks[chunk_index]):",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + -1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index - 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index - 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index * 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index * 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[0], i, 1))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 1))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[0], i, -1))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, -1))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[0], i, 1))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 1))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index - 1], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index - 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index * 1], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index * 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 2)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 2)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 0)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 0)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 0)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 0)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + -1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + -1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[1], i, 0))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[1], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[-1], i, 0))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[-1], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heapq.heappush(min_heap, (chunk[0], i, 0))",
      "mutated_line": "heapq.heappush(min_heap, (chunk[1], i, 0))",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[1], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 2], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 2], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 0], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 0], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 0], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + 0], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_tuple = (sorted_chunks[chunk_index][element_index + 1], chunk_index, element_index + 1)",
      "mutated_line": "next_tuple = (sorted_chunks[chunk_index][element_index + -1], chunk_index, element_index + 1)",
      "code": "import heapq\n\ndef external_merge_sort(data):\n    chunk_size = 10000\n    chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]\n    sorted_chunks = []\n    for chunk in chunks:\n        sorted_chunks.append(sorted(chunk))\n    return merge_sorted_chunks(sorted_chunks)\n\ndef merge_sorted_chunks(sorted_chunks):\n    min_heap = []\n    for (i, chunk) in enumerate(sorted_chunks):\n        if chunk:\n            heapq.heappush(min_heap, (chunk[0], i, 0))\n    result = []\n    while min_heap:\n        (val, chunk_index, element_index) = heapq.heappop(min_heap)\n        result.append(val)\n        if element_index + 1 < len(sorted_chunks[chunk_index]):\n            next_tuple = (sorted_chunks[chunk_index][element_index + -1], chunk_index, element_index + 1)\n            heapq.heappush(min_heap, next_tuple)\n    return result"
    }
  ]
}