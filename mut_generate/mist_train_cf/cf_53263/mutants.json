{
  "task_id": "cf_53263",
  "entry_point": "caesar_cipher",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "encrypted = \"\"",
      "mutated_line": "encrypted = 'MUTATED'",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = 'MUTATED'\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "unchanged_chars = \" ,.!?/\\[]{}():;-_+=@#^&*<>|~`$%0123456789\"",
      "mutated_line": "unchanged_chars = ''",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ''\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "decrypted = \"\"",
      "mutated_line": "decrypted = 'MUTATED'",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = 'MUTATED'\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "unchanged_chars = \" ,.!?/\\[]{}():;-_+=@#^&*<>|~`$%0123456789\"",
      "mutated_line": "unchanged_chars = ''",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ''\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "return original == reverse_caesar_cipher(encrypted, shift)",
      "mutated_line": "return original != reverse_caesar_cipher(encrypted, shift)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original != reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if char in unchanged_chars:",
      "mutated_line": "if char not in unchanged_chars:",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char not in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "encrypted += char",
      "mutated_line": "encrypted -= char",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted -= char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted -= chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted -= chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if char in unchanged_chars:",
      "mutated_line": "if char not in unchanged_chars:",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char not in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "decrypted += char",
      "mutated_line": "decrypted -= char",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted -= char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted -= chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted -= chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 66 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 66 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 64 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 64 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 0 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 0 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 1 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 1 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = -65 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = -65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 98",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 98\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 96",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 96\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 0",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 0\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 1",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 1\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else -97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else -97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 - ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 - ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 * ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 * ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 66 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 66 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 64 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 64 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 0 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 0 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 1 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 1 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = -65 if char.isupper() else 97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = -65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 98",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 98\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 96",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 96\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 0",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 0\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else 1",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 1\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ascii_offset = 65 if char.isupper() else 97",
      "mutated_line": "ascii_offset = 65 if char.isupper() else -97",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else -97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 - ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 - ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 * ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 * ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) * 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) * 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr(ord(char) - ascii_offset + shift + 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr(ord(char) - ascii_offset + shift + 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) * 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) * 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr(ord(char) - ascii_offset - shift + 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr(ord(char) - ascii_offset - shift + 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset) * shift % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset) * shift % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 27 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 27 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 25 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 25 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 0 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 0 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 1 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 1 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) - ascii_offset + shift) % -26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % -26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset) * shift % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset) * shift % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 27 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 27 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 25 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 25 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 0 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 0 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 1 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 1 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) - ascii_offset - shift) % -26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % -26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) + ascii_offset + shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) + ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)",
      "mutated_line": "encrypted += chr((ord(char) * ascii_offset + shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) * ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) + ascii_offset - shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) + ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)",
      "mutated_line": "decrypted += chr((ord(char) * ascii_offset - shift) % 26 + ascii_offset)",
      "code": "def caesar_cipher(message, shift):\n    \"\"\"\n    Encrypts the given message by shifting all alphabetic characters by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        message (str): The input message to be encrypted.\n        shift (int): The shift key for encryption.\n\n    Returns:\n        str: The encrypted message.\n    \"\"\"\n    encrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in message:\n        if char in unchanged_chars:\n            encrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n    return encrypted\n\ndef reverse_caesar_cipher(encrypted, shift):\n    \"\"\"\n    Decrypts the given encrypted message by shifting all alphabetic characters back by the shift key's magnitude while maintaining the original character case, punctuation, and spaces.\n\n    Args:\n        encrypted (str): The encrypted message to be decrypted.\n        shift (int): The shift key for decryption.\n\n    Returns:\n        str: The decrypted message.\n    \"\"\"\n    decrypted = ''\n    unchanged_chars = ' ,.!?/\\\\[]{}():;-_+=@#^&*<>|~`$%0123456789'\n    for char in encrypted:\n        if char in unchanged_chars:\n            decrypted += char\n        else:\n            ascii_offset = 65 if char.isupper() else 97\n            decrypted += chr((ord(char) * ascii_offset - shift) % 26 + ascii_offset)\n    return decrypted\n\ndef encryption_check(original, encrypted, shift):\n    \"\"\"\n    Checks if the encryption and decryption processes were successful by comparing the original message with the decrypted message.\n\n    Args:\n        original (str): The original message.\n        encrypted (str): The encrypted message.\n        shift (int): The shift key used for encryption.\n\n    Returns:\n        bool: True if the encryption and decryption processes were successful, False otherwise.\n    \"\"\"\n    return original == reverse_caesar_cipher(encrypted, shift)"
    }
  ]
}