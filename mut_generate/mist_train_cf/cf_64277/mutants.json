{
  "task_id": "cf_64277",
  "entry_point": "shortestPathAllKeys",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[0]), 1)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 1)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[0]), -1)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), -1)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[0]), 1)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 1)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (1, 0, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (1, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (-1, 0, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (-1, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (1, 0, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (1, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, 1, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 1, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, -1, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, -1, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, 1, 0, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 1, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, 0, 1, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 1, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, 0, -1, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, -1, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x, y, keys, dp, d = 0, 0, 0, set(), deque()",
      "mutated_line": "(x, y, keys, dp, d) = (0, 0, 1, set(), deque())",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 1, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys != (1 << numOfKeys) - 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys != (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return --1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if grid[i][j] == '@':",
      "mutated_line": "if grid[i][j] != '@':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= grid[i][j] <= 'f':",
      "mutated_line": "if 'a' < grid[i][j] <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' < grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= grid[i][j] <= 'f':",
      "mutated_line": "if 'a' > grid[i][j] <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' > grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= grid[i][j] <= 'f':",
      "mutated_line": "if 'a' == grid[i][j] <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' == grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "numOfKeys += 1",
      "mutated_line": "numOfKeys -= 1",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys -= 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, 1, 0))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 1, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, -1, 0))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, -1, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, 1, 0))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 1, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, 0, 1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 1))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, 0, -1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, -1))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d.append((x, y, 0, 0))",
      "mutated_line": "d.append((x, y, 0, 1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 1))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) + 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) + 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) * 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) * 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m or 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[1]), 0)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[1]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[-1]), 0)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[-1]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n, numOfKeys = len(grid), len(grid[0]), 0",
      "mutated_line": "(m, n, numOfKeys) = (len(grid), len(grid[1]), 0)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[1]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if grid[i][j] == '@':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 'a' <= grid[i][j] <= 'f':",
      "mutated_line": "if '' <= grid[i][j] <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if '' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 'a' <= grid[i][j] <= 'f':",
      "mutated_line": "if 'a' <= grid[i][j] <= '':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= '':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "numOfKeys += 1",
      "mutated_line": "numOfKeys += 2",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 2\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "numOfKeys += 1",
      "mutated_line": "numOfKeys += 0",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 0\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "numOfKeys += 1",
      "mutated_line": "numOfKeys += 0",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 0\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "numOfKeys += 1",
      "mutated_line": "numOfKeys += -1",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += -1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) - 2:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 2:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) - 0:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 0:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) - 0:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 0:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (1 << numOfKeys) - -1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - -1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 < ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 > ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 == ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if ch == '#':",
      "mutated_line": "if ch != '#':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch != '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if (nx, ny, keys) not in dp:",
      "mutated_line": "if (nx, ny, keys) in dp:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (2 << numOfKeys) - 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (2 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (0 << numOfKeys) - 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (0 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (0 << numOfKeys) - 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (0 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if keys == (1 << numOfKeys) - 1:",
      "mutated_line": "if keys == (-1 << numOfKeys) - 1:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (-1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and -1 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nx < m and 0 <= ny < n:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n:",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 1 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if ch == '#':",
      "mutated_line": "if ch == '':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' or not keys & 1 << ord(ch) - ord('A'):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' or not keys & 1 << ord(ch) - ord('A'):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' < ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' < ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' > ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' > ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' == ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' == ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif 'a' <= ch <= 'f':",
      "mutated_line": "elif 'a' < ch <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' < ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif 'a' <= ch <= 'f':",
      "mutated_line": "elif 'a' > ch <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' > ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif 'a' <= ch <= 'f':",
      "mutated_line": "elif 'a' == ch <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' == ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif '' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif '' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= '' and (not keys & 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= '' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys | 1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys | 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif 'a' <= ch <= 'f':",
      "mutated_line": "elif '' <= ch <= 'f':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif '' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif 'a' <= ch <= 'f':",
      "mutated_line": "elif 'a' <= ch <= '':",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= '':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps - 1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps - 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps * 1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps * 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 2 << ord(ch) - ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 2 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 0 << ord(ch) - ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 0 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 0 << ord(ch) - ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 0 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= -1 << ord(ch) - ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= -1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 1 << ord(ch) + ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) + ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 1 << ord(ch) * ord('a')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) * ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps + 2))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 2))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps + 0))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 0))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps + 0))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 0))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append((nx, ny, keys, steps + 1))",
      "mutated_line": "d.append((nx, ny, keys, steps + -1))",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + -1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 2 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 2 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 0 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 0 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 0 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 0 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & -1 << ord(ch) - ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & -1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) + ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) + ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) * ord('A')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) * ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "keys |= (1 << (ord(ch) - ord('a')))",
      "mutated_line": "keys |= 1 << ord(ch) - ord('')",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('A')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif 'A' <= ch <= 'F' and not (keys & (1 << (ord(ch) - ord('A')))):",
      "mutated_line": "elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('')):",
      "code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    (m, n, numOfKeys) = (len(grid), len(grid[0]), 0)\n    (x, y, keys, dp, d) = (0, 0, 0, set(), deque())\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                (x, y) = (i, j)\n            if 'a' <= grid[i][j] <= 'f':\n                numOfKeys += 1\n    d.append((x, y, 0, 0))\n    while d:\n        (x, y, keys, steps) = d.popleft()\n        if keys == (1 << numOfKeys) - 1:\n            return steps\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < m and 0 <= ny < n:\n                ch = grid[nx][ny]\n                if ch == '#':\n                    continue\n                elif 'A' <= ch <= 'F' and (not keys & 1 << ord(ch) - ord('')):\n                    continue\n                elif 'a' <= ch <= 'f':\n                    keys |= 1 << ord(ch) - ord('a')\n                if (nx, ny, keys) not in dp:\n                    d.append((nx, ny, keys, steps + 1))\n                    dp.add((nx, ny, keys))\n    return -1"
    }
  ]
}