{
  "task_id": "cf_79088",
  "entry_point": "shortestPath",
  "mutant_count": 184,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def shortestPath(grid):\n    \"\"\"\"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = 1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 1\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = -1\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][0] = 1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 1\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][1] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][1] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][-1] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][-1] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[0][1] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][1] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] <= float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] <= float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] >= float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] >= float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] != float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else +1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[1][0] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[1][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[-1][0] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[-1][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "distance[0][0] = 0",
      "mutated_line": "distance[1][0] = 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[1][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(1, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(-1, 0)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(-1, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(1, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 1)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, -1)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, -1)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 1)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "x, y = queue.pop(0)",
      "mutated_line": "(x, y) = queue.pop(1)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(1)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "x, y = queue.pop(0)",
      "mutated_line": "(x, y) = queue.pop(-1)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(-1)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "x, y = queue.pop(0)",
      "mutated_line": "(x, y) = queue.pop(1)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(1)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 and nx >= m and (ny < 0) and (ny >= n) and (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 and nx >= m and (ny < 0) and (ny >= n) and (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] - 1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] - 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] * 1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] * 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n + 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n + 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n * 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n * 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -2",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else --1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[1, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[-1, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[1, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, +1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [1, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [-1, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [1, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 2]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 0]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 0]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, -1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[+1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 1], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, -1], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 1], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [2, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [0, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [0, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [-1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 1]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, -1]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 1]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[1, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[-1, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[1, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, +1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [2, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [0, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [0, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 1]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, -1]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 1]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[1, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[-1, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[1, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 2], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 0], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 0], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, -1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [2, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [0, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [0, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [-1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 1]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, -1]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[[0, 1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 1]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[1, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[-1, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[1, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, +1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [+1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 1]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, -1]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 1]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[1, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[-1, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[1, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 2], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 0], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 0], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, -1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [+1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 1]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, -1]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 1]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[1]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[-1]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[1]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "mutated_line": "distance = [[float('') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x - dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x * dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y - dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y * dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx <= 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx <= 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx >= 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx >= 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx != 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx != 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx > m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx > m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx < m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx < m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx == m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx == m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny <= 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny <= 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny >= 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny >= 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny != 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny != 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny > n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny > n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny < n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny < n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny == n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny == n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] < distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] < distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] > distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] > distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] == distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] == distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] + 2",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 2\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] + 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 0\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] + 0",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 0\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "distance[nx][ny] = distance[x][y] + 1",
      "mutated_line": "distance[nx][ny] = distance[x][y] + -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + -1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n + 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n + 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n * 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n * 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m + 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m + 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m * 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m * 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 2] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 2] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 0] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 0] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 0] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 0] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - -1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - -1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -2], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -0], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -0], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "[[0, -1], [0, 1]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, --1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-2, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-0, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-0, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "[[-1, 0], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[--1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -2], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -0], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -0], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "[[0, -1], [1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, --1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -2], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -0], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -0], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, --1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-2, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-0, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-0, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[[0, -1], [-1, 0]],",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [--1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-2, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-0, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-0, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[[0, 1], [-1, 0]]",
      "mutated_line": "distance = [[float('inf') for _ in range(n)] for _ in range(m)]",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [--1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < -1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < -1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 1 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < -1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < -1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 1 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] - 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] - 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] * 1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] * 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m + 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m + 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m * 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m * 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 2] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 2] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 0] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 0] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 0] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 0] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 1][n - -1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - -1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 2][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 2][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 0][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 0][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 0][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 0][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - -1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - -1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 2):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 2):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 0):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 0):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 0):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 0):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or distance[nx][ny] <= distance[x][y] + 1:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + -1):",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + -1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 2][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 2][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 0][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 0][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - 0][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - 0][n - 1] < float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return distance[m - 1][n - 1] if distance[m - 1][n - 1] < float('inf') else -1",
      "mutated_line": "return distance[m - 1][n - 1] if distance[m - -1][n - 1] < float('inf') else -1",
      "code": "def shortestPath(grid):\n    \"\"\"\n    This function calculates the length of the shortest valid path from the top-left cell (0,0) \n    to the bottom-right cell (m - 1, n - 1) in a given grid.\n\n    Args:\n        grid (list of lists): A 2D grid representing a network of streets.\n\n    Returns:\n        int: The length of the shortest valid path, or -1 if there is no valid path.\n    \"\"\"\n    directions = [[], [[0, -1], [0, 1]], [[-1, 0], [1, 0]], [[0, -1], [1, 0]], [[0, 1], [1, 0]], [[0, -1], [-1, 0]], [[0, 1], [-1, 0]]]\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distance[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        (x, y) = queue.pop(0)\n        for (dx, dy) in directions[grid[x][y]]:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or (distance[nx][ny] <= distance[x][y] + 1):\n                continue\n            queue.append((nx, ny))\n            distance[nx][ny] = distance[x][y] + 1\n    return distance[m - 1][n - 1] if distance[m - -1][n - 1] < float('inf') else -1"
    }
  ]
}