{
  "task_id": "cf_76786",
  "entry_point": "common",
  "mutant_count": 4,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def common(l1: list, l2: list) -> list:\n    \"\"\"\"\"\"\n    common_set = set()\n    ordered_set = set()\n    for num in l1:\n        if num in l2 and num not in common_set:\n            common_set.add(num)\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    return list(ordered_set)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if num in l2 and num not in common_set:",
      "mutated_line": "if num in l2 or num not in common_set:",
      "code": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    for num in l1:\n        if num in l2 or num not in common_set:\n            common_set.add(num)\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    return list(ordered_set)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if num in l2 and num not in common_set:",
      "mutated_line": "if num not in l2 and num not in common_set:",
      "code": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    for num in l1:\n        if num not in l2 and num not in common_set:\n            common_set.add(num)\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    return list(ordered_set)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if num in l2 and num not in common_set:",
      "mutated_line": "if num in l2 and num in common_set:",
      "code": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Authoritatively yield manually ordered, non-repetitive intersecting elements for two lists.\n    This function is constructed to handle integer arrays including negative integers,without depending \n    on inherent Python list functionalities. The function returns a well-ordered list eliminating any duplicates.\n    If one of the lists is empty, the function returns an empty list. \n\n    :param l1: The first list of integers.\n    :type l1: list\n    :param l2: The second list of integers.\n    :type l2: list\n    :returns: A list containing ordered intersecting elements from both lists, without duplicates.\n    \"\"\"\n    common_set = set()\n    ordered_set = set()\n    for num in l1:\n        if num in l2 and num in common_set:\n            common_set.add(num)\n    for num in sorted(common_set):\n        ordered_set.add(num)\n    return list(ordered_set)"
    }
  ]
}