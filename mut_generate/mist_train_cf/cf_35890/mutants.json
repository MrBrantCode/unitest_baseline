{
  "task_id": "cf_35890",
  "entry_point": "compare_versions",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(version1_parts) > len(version2_parts):",
      "mutated_line": "if len(version1_parts) >= len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) >= len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(version1_parts) > len(version2_parts):",
      "mutated_line": "if len(version1_parts) <= len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) <= len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(version1_parts) > len(version2_parts):",
      "mutated_line": "if len(version1_parts) != len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) != len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if pre_release1 and not pre_release2:",
      "mutated_line": "if pre_release1 or not pre_release2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 or not pre_release2:\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 1\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return -1\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 1\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 > v2:",
      "mutated_line": "if v1 >= v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 >= v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 > v2:",
      "mutated_line": "if v1 <= v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 <= v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 > v2:",
      "mutated_line": "if v1 != v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 != v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 2\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 0\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 0\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return -1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif len(version1_parts) < len(version2_parts):",
      "mutated_line": "elif len(version1_parts) <= len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) <= len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif len(version1_parts) < len(version2_parts):",
      "mutated_line": "elif len(version1_parts) >= len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) >= len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif len(version1_parts) < len(version2_parts):",
      "mutated_line": "elif len(version1_parts) != len(version2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) != len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[0].split('-')[0].split('')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pre_release = re.search(r'[-+](.*)', version)",
      "mutated_line": "pre_release = re.search('', version)",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre_release_tag = pre_release.group(1) if pre_release else ''",
      "mutated_line": "pre_release_tag = pre_release.group(1) if pre_release else 'MUTATED'",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else 'MUTATED'\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return +1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "elif not pre_release1 and pre_release2:",
      "mutated_line": "elif not pre_release1 or pre_release2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 or pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 2\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 0\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 0\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return -1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif v1 < v2:",
      "mutated_line": "elif v1 <= v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 <= v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif v1 < v2:",
      "mutated_line": "elif v1 >= v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 >= v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif v1 < v2:",
      "mutated_line": "elif v1 != v2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 != v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return +1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre_release_tag = pre_release.group(1) if pre_release else ''",
      "mutated_line": "pre_release_tag = pre_release.group(2) if pre_release else ''",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(2) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre_release_tag = pre_release.group(1) if pre_release else ''",
      "mutated_line": "pre_release_tag = pre_release.group(0) if pre_release else ''",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(0) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre_release_tag = pre_release.group(1) if pre_release else ''",
      "mutated_line": "pre_release_tag = pre_release.group(0) if pre_release else ''",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(0) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pre_release_tag = pre_release.group(1) if pre_release else ''",
      "mutated_line": "pre_release_tag = pre_release.group(-1) if pre_release else ''",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(-1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -2\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -0\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -0\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return --1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 2\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 0\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 0\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return -1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "elif pre_release1 and pre_release2:",
      "mutated_line": "elif pre_release1 or pre_release2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 or pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return +1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -2\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -0\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -0\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return --1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[0].split('-')[1].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[1].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[0].split('-')[-1].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[-1].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[0].split('-')[1].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[1].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(pre_release1_parts) > len(pre_release2_parts):",
      "mutated_line": "if len(pre_release1_parts) >= len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) >= len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(pre_release1_parts) > len(pre_release2_parts):",
      "mutated_line": "if len(pre_release1_parts) <= len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) <= len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if len(pre_release1_parts) > len(pre_release2_parts):",
      "mutated_line": "if len(pre_release1_parts) != len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) != len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -2\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -0\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -0\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return --1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[0].split('')[0].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pre_release1_parts = re.findall(r'[\\dA-Za-z-]+', pre_release1)",
      "mutated_line": "pre_release1_parts = re.findall('', pre_release1)",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pre_release2_parts = re.findall(r'[\\dA-Za-z-]+', pre_release2)",
      "mutated_line": "pre_release2_parts = re.findall('', pre_release2)",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if part1.isdigit() and part2.isdigit():",
      "mutated_line": "if part1.isdigit() or part2.isdigit():",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() or part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 2\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 0\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 0\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return -1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif len(pre_release1_parts) < len(pre_release2_parts):",
      "mutated_line": "elif len(pre_release1_parts) <= len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) <= len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif len(pre_release1_parts) < len(pre_release2_parts):",
      "mutated_line": "elif len(pre_release1_parts) >= len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) >= len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif len(pre_release1_parts) < len(pre_release2_parts):",
      "mutated_line": "elif len(pre_release1_parts) != len(pre_release2_parts):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) != len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if int(part1) > int(part2):",
      "mutated_line": "if int(part1) >= int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) >= int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if int(part1) > int(part2):",
      "mutated_line": "if int(part1) <= int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) <= int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if int(part1) > int(part2):",
      "mutated_line": "if int(part1) != int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) != int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if part1 > part2:",
      "mutated_line": "return 1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 >= part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if part1 > part2:",
      "mutated_line": "return 1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 <= part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if part1 > part2:",
      "mutated_line": "return 1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 != part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return +1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[1].split('-')[0].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[1].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[-1].split('-')[0].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[-1].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('+')[1].split('-')[0].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[1].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 2\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 0\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 0\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return -1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif int(part1) < int(part2):",
      "mutated_line": "elif int(part1) <= int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) <= int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif int(part1) < int(part2):",
      "mutated_line": "elif int(part1) >= int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) >= int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif int(part1) < int(part2):",
      "mutated_line": "elif int(part1) != int(part2):",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) != int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 1",
      "mutated_line": "elif part1 < part2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 2\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 1",
      "mutated_line": "elif part1 < part2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 0\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 1",
      "mutated_line": "elif part1 < part2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 0\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 1",
      "mutated_line": "elif part1 < part2:",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return -1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif part1 < part2:",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 <= part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif part1 < part2:",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 >= part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif part1 < part2:",
      "mutated_line": "return -1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 != part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -2\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -0\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -0\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return --1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "version_parts = version.split('+')[0].split('-')[0].split('.')",
      "mutated_line": "version_parts = version.split('')[0].split('-')[0].split('.')",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return +1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return +1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -2\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -0\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -0\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return --1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -2\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -0\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return -0\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import re\n\ndef compare_versions(version1: str, version2: str) -> int:\n\n    def parse_version(version: str) -> tuple:\n        version_parts = version.split('+')[0].split('-')[0].split('.')\n        pre_release = re.search('[-+](.*)', version)\n        pre_release_tag = pre_release.group(1) if pre_release else ''\n        return (tuple(map(int, version_parts)), pre_release_tag)\n\n    def compare_pre_release(pre_release1: str, pre_release2: str) -> int:\n        if pre_release1 and (not pre_release2):\n            return -1\n        elif not pre_release1 and pre_release2:\n            return 1\n        elif pre_release1 and pre_release2:\n            pre_release1_parts = re.findall('[\\\\dA-Za-z-]+', pre_release1)\n            pre_release2_parts = re.findall('[\\\\dA-Za-z-]+', pre_release2)\n            for (part1, part2) in zip(pre_release1_parts, pre_release2_parts):\n                if part1.isdigit() and part2.isdigit():\n                    if int(part1) > int(part2):\n                        return 1\n                    elif int(part1) < int(part2):\n                        return -1\n                elif part1 > part2:\n                    return 1\n                elif part1 < part2:\n                    return --1\n            if len(pre_release1_parts) > len(pre_release2_parts):\n                return 1\n            elif len(pre_release1_parts) < len(pre_release2_parts):\n                return -1\n        return 0\n    (version1_parts, pre_release1) = parse_version(version1)\n    (version2_parts, pre_release2) = parse_version(version2)\n    for (v1, v2) in zip(version1_parts, version2_parts):\n        if v1 > v2:\n            return 1\n        elif v1 < v2:\n            return -1\n    if len(version1_parts) > len(version2_parts):\n        return 1\n    elif len(version1_parts) < len(version2_parts):\n        return -1\n    return compare_pre_release(pre_release1, pre_release2)"
    }
  ]
}