{
  "task_id": "cf_4267",
  "entry_point": "convert_nfa_to_dfa",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for symbol in 'ab':",
      "mutated_line": "for symbol in '':",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in '':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if next_state not in dfa_states:",
      "mutated_line": "if next_state in dfa_states:",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if state in nfa_transitions and symbol in nfa_transitions[state]:",
      "mutated_line": "if state in nfa_transitions or symbol in nfa_transitions[state]:",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions or symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if any(nfa_state in nfa_final_states for nfa_state in state):",
      "mutated_line": "if any((nfa_state not in nfa_final_states for nfa_state in state)):",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state not in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if state in nfa_transitions and symbol in nfa_transitions[state]:",
      "mutated_line": "if state not in nfa_transitions and symbol in nfa_transitions[state]:",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state not in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if state in nfa_transitions and symbol in nfa_transitions[state]:",
      "mutated_line": "if state in nfa_transitions and symbol not in nfa_transitions[state]:",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol not in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start_state = max(nfa_states, key=lambda state: sum(1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states))",
      "mutated_line": "start_state = max(nfa_states, key=lambda state: sum((2 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((2 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start_state = max(nfa_states, key=lambda state: sum(1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states))",
      "mutated_line": "start_state = max(nfa_states, key=lambda state: sum((0 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((0 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start_state = max(nfa_states, key=lambda state: sum(1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states))",
      "mutated_line": "start_state = max(nfa_states, key=lambda state: sum((0 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((0 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start_state = max(nfa_states, key=lambda state: sum(1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states))",
      "mutated_line": "start_state = max(nfa_states, key=lambda state: sum((-1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((-1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "start_state = max(nfa_states, key=lambda state: sum(1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state in next_states))",
      "mutated_line": "start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state not in next_states)))",
      "code": "from collections import defaultdict, deque\n\ndef convert_nfa_to_dfa(nfa_transitions, nfa_final_states, nfa_states):\n    dfa_transitions = defaultdict(dict)\n    dfa_states = set()\n    dfa_final_states = set()\n    start_state = max(nfa_states, key=lambda state: sum((1 for transitions in nfa_transitions.values() for next_states in transitions.values() if state not in next_states)))\n    queue = deque([[start_state]])\n    while queue:\n        current_state = queue.popleft()\n        dfa_states.add(tuple(sorted(current_state)))\n        for symbol in 'ab':\n            next_states = set()\n            for state in current_state:\n                if state in nfa_transitions and symbol in nfa_transitions[state]:\n                    next_states.update(nfa_transitions[state][symbol])\n            next_state = tuple(sorted(next_states))\n            if next_state not in dfa_states:\n                queue.append(list(next_state))\n            dfa_transitions[tuple(current_state)][symbol] = next_state\n    for state in dfa_states:\n        if any((nfa_state in nfa_final_states for nfa_state in state)):\n            dfa_final_states.add(state)\n    dfa_transitions = {state: {symbol: next_state for (symbol, next_state) in transitions.items()} for (state, transitions) in dfa_transitions.items()}\n    return (dfa_transitions, dfa_final_states)"
    }
  ]
}