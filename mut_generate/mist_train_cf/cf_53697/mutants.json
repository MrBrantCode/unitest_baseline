{
  "task_id": "cf_53697",
  "entry_point": "find_paths",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=1, y=0, path=''):",
      "code": "def find_paths(grid, x=1, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=-1, y=0, path=''):",
      "code": "def find_paths(grid, x=-1, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=1, y=0, path=''):",
      "code": "def find_paths(grid, x=1, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=0, y=1, path=''):",
      "code": "def find_paths(grid, x=0, y=1, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=0, y=-1, path=''):",
      "code": "def find_paths(grid, x=0, y=-1, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=0, y=1, path=''):",
      "code": "def find_paths(grid, x=0, y=1, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_paths(grid, x=0, y=0, path=''):",
      "mutated_line": "def find_paths(grid, x=0, y=0, path='MUTATED'):",
      "code": "def find_paths(grid, x=0, y=0, path='MUTATED'):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 or y == len(grid[0]) - 1 or grid[y][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 or y == len(grid[0]) - 1 or grid[y][x] == 'L':\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 or grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 or grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 or grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 or grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(grid) != len(grid[0]):",
      "mutated_line": "if len(grid) == len(grid[0]):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) == len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x != len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x != len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y != len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y != len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] != 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] != 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x <= len(grid) - 1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x <= len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x >= len(grid) - 1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x >= len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x != len(grid) - 1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x != len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + 1] != 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] != 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y <= len(grid) - 1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y <= len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y >= len(grid) - 1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y >= len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y != len(grid) - 1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y != len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + 1][x] != 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] != 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return True\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) + 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) + 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) * 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) * 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) + 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) + 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) * 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) * 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == ''):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == ''):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) + 1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) + 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) * 1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) * 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + 1] == '':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == '':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) + 1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) + 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) * 1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) * 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + 1][x] == '':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == '':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return True\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 2 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 2 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 0 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 0 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 0 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 0 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - -1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - -1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - 2 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 2 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - 0 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 0 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - 0 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 0 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[0]) - -1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - -1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 2 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 2 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 0 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 0 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 0 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 0 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - -1 and grid[y][x + 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - -1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x - 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x - 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x * 1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x * 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 2 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 2 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 0 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 0 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 0 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 0 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - -1 and grid[y + 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - -1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(grid) != len(grid[0]):",
      "mutated_line": "if len(grid) != len(grid[1]):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[1]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(grid) != len(grid[0]):",
      "mutated_line": "if len(grid) != len(grid[-1]):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[-1]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(grid) != len(grid[0]):",
      "mutated_line": "if len(grid) != len(grid[1]):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[1]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + 2] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 2] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + 0] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 0] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + 0] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 0] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < len(grid) - 1 and grid[y][x+1] == \"L\":",
      "mutated_line": "if x < len(grid) - 1 and grid[y][x + -1] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + -1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x - 1, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x - 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x * 1, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x * 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 1, y=y, path=path - 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path - 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 1, y=y, path=path * 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path * 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y - 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y - 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y * 1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y * 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y - 1, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y - 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y * 1, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y * 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 1, path=path - 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path - 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 1, path=path * 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path * 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if not all(cell in [\"L\", \"W\"] for cell in row):",
      "mutated_line": "if not all((cell not in ['L', 'W'] for cell in row)):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell not in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[1]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[1]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[-1]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[-1]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if x == len(grid) - 1 and y == len(grid[0]) - 1 and grid[y][x] == \"L\":",
      "mutated_line": "if x == len(grid) - 1 and y == len(grid[1]) - 1 and (grid[y][x] == 'L'):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[1]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 2, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 2, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 0, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 0, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 0, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 0, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + -1, y=y, path=path + 'R'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + -1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "paths.extend(find_paths(grid, x=x+1, y=y, path=path+'R'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x + 1, y=y, path=path + ''))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + ''))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + 2][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 2][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + 0][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 0][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + 0][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 0][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if y < len(grid) - 1 and grid[y+1][x] == \"L\":",
      "mutated_line": "if y < len(grid) - 1 and grid[y + -1][x] == 'L':",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + -1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 2, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 2, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 0, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 0, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 0, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 0, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + -1, path=path + 'D'))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + -1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "paths.extend(find_paths(grid, x=x, y=y+1, path=path+'D'))",
      "mutated_line": "paths.extend(find_paths(grid, x=x, y=y + 1, path=path + ''))",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + ''))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if not all(cell in [\"L\", \"W\"] for cell in row):",
      "mutated_line": "if not all((cell in ['', 'W'] for cell in row)):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['', 'W'] for cell in row)):\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if not all(cell in [\"L\", \"W\"] for cell in row):",
      "mutated_line": "if not all((cell in ['L', ''] for cell in row)):",
      "code": "def find_paths(grid, x=0, y=0, path=''):\n    \"\"\"\n    This function uses a recursive mechanism to find all unique paths through a given grid.\n    \n    Args:\n    grid (list): A 2D list representing the grid, where \"L\" denotes land and \"W\" denotes water.\n    x (int): The current x-coordinate (default is 0).\n    y (int): The current y-coordinate (default is 0).\n    path (str): The current path taken so far (default is an empty string).\n    \n    Returns:\n    list: A list of all unique paths from the top-left corner to the bottom-right corner.\n    \"\"\"\n    if not is_valid_grid(grid):\n        return []\n    if x == len(grid) - 1 and y == len(grid[0]) - 1 and (grid[y][x] == 'L'):\n        return [path]\n    paths = []\n    if x < len(grid) - 1 and grid[y][x + 1] == 'L':\n        paths.extend(find_paths(grid, x=x + 1, y=y, path=path + 'R'))\n    if y < len(grid) - 1 and grid[y + 1][x] == 'L':\n        paths.extend(find_paths(grid, x=x, y=y + 1, path=path + 'D'))\n    return paths\n\ndef is_valid_grid(grid):\n    if len(grid) != len(grid[0]):\n        return False\n    for row in grid:\n        if not all((cell in ['L', ''] for cell in row)):\n            return False\n    return True"
    }
  ]
}