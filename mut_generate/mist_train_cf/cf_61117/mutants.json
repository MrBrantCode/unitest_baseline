{
  "task_id": "cf_61117",
  "entry_point": "maxLength",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 1\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = -1",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = -1\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 1\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][1] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][-1] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][-1] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][1] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(2, 1 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(2, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(0, 1 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(0, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(0, 1 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(0, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(-1, 1 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(-1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "arr = [word for word in arr if len(set(word)) == len(word)]",
      "mutated_line": "arr = [word for word in arr if len(set(word)) != len(word)]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) != len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[+1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[+1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[1][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[-1][0] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[-1][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[1][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(1, 2 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 2 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(1, 0 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 0 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(1, 0 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 0 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for mask in range(1, 1 << len(arr)):",
      "mutated_line": "for mask in range(1, -1 << len(arr)):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, -1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for unique_char_count in range(27):",
      "mutated_line": "for unique_char_count in range(28):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(28):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for unique_char_count in range(27):",
      "mutated_line": "for unique_char_count in range(26):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(26):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for unique_char_count in range(27):",
      "mutated_line": "for unique_char_count in range(0):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(0):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for unique_char_count in range(27):",
      "mutated_line": "for unique_char_count in range(1):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(1):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for unique_char_count in range(27):",
      "mutated_line": "for unique_char_count in range(-27):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(-27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] != -1:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] != -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 1][k], +1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], +1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-2 for _ in range(27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-2 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-0 for _ in range(27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-0 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-0 for _ in range(27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-0 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[--1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[--1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] == +1:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == +1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 1][k], -2])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -2])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 1][k], -0])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -0])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 1][k], -0])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -0])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 1][k], --1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], --1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(28)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(28)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(26)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(26)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(0)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(0)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(1)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(1)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(-27)] for _ in range(1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(-27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(27)] for _ in range(2 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(2 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(27)] for _ in range(0 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(0 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(27)] for _ in range(0 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(0 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]",
      "mutated_line": "dp = [[-1 for _ in range(27)] for _ in range(-1 << len(arr))]",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(-1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] == -2:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -2:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] == -0:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -0:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] == -0:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -0:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dp[mask][unique_char_count] == -1:",
      "mutated_line": "if dp[mask][unique_char_count] == --1:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == --1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not mask & 1 << idx:",
      "mutated_line": "if not mask | 1 << idx:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask | 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 or all((v == 1 for v in chars.values())) or (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 or all((v == 1 for v in chars.values())) or (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) + 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) + 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) * 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) * 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count < 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count < 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count > 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count > 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count == 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count == 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "new_unique_char_count = unique_char_count + len(chars.keys())",
      "mutated_line": "new_unique_char_count = unique_char_count - len(chars.keys())",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count - len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "new_unique_char_count = unique_char_count + len(chars.keys())",
      "mutated_line": "new_unique_char_count = unique_char_count * len(chars.keys())",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count * len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 2][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 2][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 0][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 0][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - 0][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 0][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(1 << len(arr)) - -1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - -1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not mask & 1 << idx:",
      "mutated_line": "if not mask & 2 << idx:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 2 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not mask & 1 << idx:",
      "mutated_line": "if not mask & 0 << idx:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 0 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not mask & 1 << idx:",
      "mutated_line": "if not mask & 0 << idx:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 0 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not mask & 1 << idx:",
      "mutated_line": "if not mask & -1 << idx:",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & -1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) - unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) - unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) * unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) * unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 27 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 27 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 25 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 25 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 0 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 0 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 1 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 1 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= -26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= -26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count >= 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count >= 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count <= 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count <= 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count != 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count != 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c not in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c not in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else False):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else False):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] - len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] - len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] * len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] * len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(2 << len(arr)) - 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(2 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(0 << len(arr)) - 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(0 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(0 << len(arr)) - 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(0 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return max([dp[(1 << len(arr)) - 1][k], -1])",
      "mutated_line": "return max([dp[(-1 << len(arr)) - 1][k], -1])",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(-1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v != 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v != 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 1 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 1 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > -1 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > -1 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 1 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 1 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask & 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask & 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask ^ 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask ^ 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 2 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 2 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 0 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 0 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == 0 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 0 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(chars) + unique_char_count <= 26 and all(v == 1 for v in chars.values()) and (c in chars.keys() if unique_char_count > 0 else True):",
      "mutated_line": "if len(chars) + unique_char_count <= 26 and all((v == -1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == -1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask & 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask & 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask ^ 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask ^ 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 2 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 2 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 0 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 0 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 0 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 0 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | -1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | -1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 2 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 2 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 0 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 0 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 0 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 0 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | 1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "mutated_line": "dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | -1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))",
      "code": "def maxLength(arr, k, c):\n    \"\"\"\n    Returns the maximum length of a concatenation of strings from `arr` that uses at most `k` unique characters and contains the character `c`.\n\n    Args:\n        arr (list[str]): A list of strings.\n        k (int): The maximum number of unique characters allowed.\n        c (str): The character that the concatenation must contain.\n\n    Returns:\n        int: The maximum length of the concatenation. Returns -1 if no such concatenation exists.\n    \"\"\"\n    arr = [word for word in arr if len(set(word)) == len(word)]\n    dp = [[-1 for _ in range(27)] for _ in range(1 << len(arr))]\n    dp[0][0] = 0\n    for mask in range(1, 1 << len(arr)):\n        for unique_char_count in range(27):\n            if dp[mask][unique_char_count] == -1:\n                continue\n            for idx in range(len(arr)):\n                if not mask & 1 << idx:\n                    chars = collections.Counter(arr[idx])\n                    if len(chars) + unique_char_count <= 26 and all((v == 1 for v in chars.values())) and (c in chars.keys() if unique_char_count > 0 else True):\n                        new_unique_char_count = unique_char_count + len(chars.keys())\n                        dp[mask | 1 << idx][new_unique_char_count] = max(dp[mask | -1 << idx][new_unique_char_count], dp[mask][unique_char_count] + len(arr[idx]))\n    return max([dp[(1 << len(arr)) - 1][k], -1])"
    }
  ]
}