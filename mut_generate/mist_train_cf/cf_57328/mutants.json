{
  "task_id": "cf_57328",
  "entry_point": "median",
  "mutant_count": 155,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 2 != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 != 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index >= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index >= 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index <= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index <= 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index != 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while index < len(self.list):",
      "mutated_line": "while index <= len(self.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index <= len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while index < len(self.list):",
      "mutated_line": "while index >= len(self.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index >= len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while index < len(self.list):",
      "mutated_line": "while index != len(self.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index != len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 and cmp_func(num, max_heap.list[0]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 and cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(min_heap.list) > len(max_heap.list):",
      "mutated_line": "if len(min_heap.list) >= len(max_heap.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) >= len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(min_heap.list) > len(max_heap.list):",
      "mutated_line": "if len(min_heap.list) <= len(max_heap.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) <= len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(min_heap.list) > len(max_heap.list):",
      "mutated_line": "if len(min_heap.list) != len(max_heap.list):",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) != len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) * 2 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) * 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) + 2 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) + 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 2 == 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 1:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 2 == -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == -1:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 2 == 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 1:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) * 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) * 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) // 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) + 1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) + 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) * 1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) * 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "value = self.list[0]",
      "mutated_line": "value = self.list[1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[1]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "value = self.list[0]",
      "mutated_line": "value = self.list[-1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[-1]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "value = self.list[0]",
      "mutated_line": "value = self.list[1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[1]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[1] = self.list[len(self.list) - 1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[1] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[-1] = self.list[len(self.list) - 1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[-1] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[1] = self.list[len(self.list) - 1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[1] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) + 1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) + 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) * 1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) * 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.heapify_down(0)",
      "mutated_line": "self.heapify_down(1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(1)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.heapify_down(0)",
      "mutated_line": "self.heapify_down(-1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(-1)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.heapify_down(0)",
      "mutated_line": "self.heapify_down(1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(1)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 1:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index > -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > -1:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while index > 0:",
      "mutated_line": "while index > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 1:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) / 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) * 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) * 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) <= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) <= 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) >= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) >= 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) != 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 - 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 - 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 * 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 * 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 - 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 - 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 * 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 * 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) or self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) or self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) or self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) or self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if smallest != index:",
      "mutated_line": "if smallest == index:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest == index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "max_heap = Heap(lambda a, b: -cmp_func(a, b))",
      "mutated_line": "max_heap = Heap(lambda a, b: +cmp_func(a, b))",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: +cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) != 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) != 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) <= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) <= 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) >= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) >= 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) != 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) >= len(min_heap.list) + 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) >= len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) <= len(min_heap.list) + 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) <= len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) != len(min_heap.list) + 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) != len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 3 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 3 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 1 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 1 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 0 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 0 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % 1 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 1 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(numbers) % 2 == 0:",
      "mutated_line": "if len(numbers) % -2 == 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % -2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] - max_heap.list[0]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] - max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return min_heap.list[0] * max_heap.list[0] / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return min_heap.list[0] * max_heap.list[0] / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) / 3",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 3\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) / 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 1\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) / 0",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 0\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) / 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 1\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[0]) / -2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / -2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max_heap.list[0]",
      "mutated_line": "return max_heap.list[1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max_heap.list[0]",
      "mutated_line": "return max_heap.list[-1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max_heap.list[0]",
      "mutated_line": "return max_heap.list[1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) - 2)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 2)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) - 0)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 0)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) - 0)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 0)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.heapify_up(len(self.list) - 1)",
      "mutated_line": "self.heapify_up(len(self.list) - -1)",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - -1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) - 2]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 2]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) - 0]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 0]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) - 0]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 0]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.list[0] = self.list[len(self.list) - 1]",
      "mutated_line": "self.list[0] = self.list[len(self.list) - -1]",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - -1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index + 1) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index + 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = index * 1 // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = index * 1 // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) // 3",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 3\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) // 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 1\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) // 0",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 0\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) // 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 1\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 1) // -2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // -2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) < 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 1:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) < -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < -1:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if self.cmp_func(self.list[index], self.list[parent]) < 0:",
      "mutated_line": "if self.cmp_func(self.list[index], self.list[parent]) < 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 1:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index / 2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index / 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index + 2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index + 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index ** 2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index ** 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 2\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 + 0",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 0\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 + 0",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 0\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 2 + -1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + -1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index / 2 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index / 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index + 2 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index + 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index ** 2 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index ** 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 + 3",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 3\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 1\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 + 0",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 0\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 1\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 2 + -2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + -2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left <= len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left <= len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left >= len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left >= len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left != len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left != len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) >= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) >= 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) <= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) <= 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) != 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right <= len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right <= len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right >= len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right >= len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right != len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right != len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) >= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) >= 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) <= 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) <= 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) != 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) != 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 1 or cmp_func(num, max_heap.list[0]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 1 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == -1 or cmp_func(num, max_heap.list[0]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == -1 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 1 or cmp_func(num, max_heap.list[0]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 1 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 1:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < -1:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 1:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) - 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) - 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) * 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) * 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 2) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 2) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 0) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 0) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - 0) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 0) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "parent = (index - 1) // 2",
      "mutated_line": "parent = (index - -1) // 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - -1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 3 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 3 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 1 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 1 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 0 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 0 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * 1 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 1 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = index * 2 + 1",
      "mutated_line": "left = index * -2 + 1",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * -2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 3 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 3 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 1 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 1 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 0 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 0 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * 1 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 1 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = index * 2 + 2",
      "mutated_line": "right = index * -2 + 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * -2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 1:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > -1:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:",
      "mutated_line": "if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 1:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 1:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > -1:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:",
      "mutated_line": "if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 1:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) + 2:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 2:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) + 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 0:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) + 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 0:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "elif len(max_heap.list) > len(min_heap.list) + 1:",
      "mutated_line": "elif len(max_heap.list) > len(min_heap.list) + -1:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + -1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[1] + max_heap.list[0]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[1] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[-1] + max_heap.list[0]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[-1] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[1] + max_heap.list[0]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[1] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[1]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[1]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[-1]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[-1]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return (min_heap.list[0] + max_heap.list[0]) / 2",
      "mutated_line": "return (min_heap.list[0] + max_heap.list[1]) / 2",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[1]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[1]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[1]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[-1]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[-1]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[0]) < 0:",
      "mutated_line": "if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[1]) < 0:",
      "code": "class Heap:\n\n    def __init__(self, cmp_func):\n        self.list = []\n        self.cmp_func = cmp_func\n\n    def push(self, value):\n        self.list.append(value)\n        self.heapify_up(len(self.list) - 1)\n\n    def pop(self):\n        value = self.list[0]\n        self.list[0] = self.list[len(self.list) - 1]\n        self.list.pop()\n        self.heapify_down(0)\n        return value\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.cmp_func(self.list[index], self.list[parent]) < 0:\n                (self.list[parent], self.list[index]) = (self.list[index], self.list[parent])\n                index = parent\n            else:\n                break\n\n    def heapify_down(self, index):\n        while index < len(self.list):\n            left = index * 2 + 1\n            right = index * 2 + 2\n            smallest = index\n            if left < len(self.list) and self.cmp_func(self.list[smallest], self.list[left]) > 0:\n                smallest = left\n            if right < len(self.list) and self.cmp_func(self.list[smallest], self.list[right]) > 0:\n                smallest = right\n            if smallest != index:\n                (self.list[smallest], self.list[index]) = (self.list[index], self.list[smallest])\n                index = smallest\n            else:\n                break\n\ndef median(numbers, cmp_func):\n    min_heap = Heap(cmp_func)\n    max_heap = Heap(lambda a, b: -cmp_func(a, b))\n    for num in numbers:\n        if len(max_heap.list) == 0 or cmp_func(num, max_heap.list[1]) < 0:\n            max_heap.push(num)\n        else:\n            min_heap.push(num)\n        if len(min_heap.list) > len(max_heap.list):\n            max_heap.push(min_heap.pop())\n        elif len(max_heap.list) > len(min_heap.list) + 1:\n            min_heap.push(max_heap.pop())\n    if len(numbers) % 2 == 0:\n        return (min_heap.list[0] + max_heap.list[0]) / 2\n    else:\n        return max_heap.list[0]"
    }
  ]
}