{
  "task_id": "cf_71279",
  "entry_point": "operate_on_dicts",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if not dict1 and not dict2:",
      "mutated_line": "return 'Error: The first two dictionaries are empty.'",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 or not dict2:\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return \"Error: The first two dictionaries are empty.\"",
      "mutated_line": "return ''",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return ''\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'merge': lambda d1, d2: {**d1, **d2},",
      "mutated_line": "functions = {'': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, '': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, '': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, '': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, '': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'sort_by_value': lambda d1, d2: {k: v for k, v in sorted(d1.items(), key=lambda item: item[1])},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, '': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, '': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, '': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, '': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'key_length': lambda d1, d2: {k: len(k) for k in d1}",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, '': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, '': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if operation in functions:",
      "mutated_line": "if operation not in functions:",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation not in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f\"Error: Undefined operation '{operation}'.\"",
      "mutated_line": "return f\"{operation}'.\"",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return f\"Error: Undefined operation '{operation}'.\"",
      "mutated_line": "return f\"Error: Undefined operation '{operation}\"",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) + d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) + d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) * d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) * d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) & set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) & set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) ^ set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) ^ set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"",
      "mutated_line": "return f\"{operation}'. {str(e)}\"",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"",
      "mutated_line": "return f\"Error: An error occured when performing the operation '{operation}{str(e)}\"",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}{str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, -1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, -1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 1) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, -1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, -1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 1)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'sort_by_value': lambda d1, d2: {k: v for k, v in sorted(d1.items(), key=lambda item: item[1])},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[2])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[2])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'sort_by_value': lambda d1, d2: {k: v for k, v in sorted(d1.items(), key=lambda item: item[1])},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[0])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[0])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'sort_by_value': lambda d1, d2: {k: v for k, v in sorted(d1.items(), key=lambda item: item[1])},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[0])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[0])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'sort_by_value': lambda d1, d2: {k: v for k, v in sorted(d1.items(), key=lambda item: item[1])},",
      "mutated_line": "functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[-1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}",
      "code": "def operate_on_dicts(dict1, dict2, operations_dict):\n    if not dict1 and (not dict2):\n        return 'Error: The first two dictionaries are empty.'\n    if not operations_dict:\n        return (dict1, dict2)\n    functions = {'merge': lambda d1, d2: {**d1, **d2}, 'common_keys': lambda d1, d2: {k: d1[k] for k in d1 if k in d2}, 'unique_keys': lambda d1, d2: {k: d1[k] for k in d1 if k not in d2}, 'sort_by_value': lambda d1, d2: {k: v for (k, v) in sorted(d1.items(), key=lambda item: item[-1])}, 'value_difference': lambda d1, d2: {k: abs(d1.get(k, 0) - d2.get(k, 0)) for k in set(d1) | set(d2)}, 'key_length': lambda d1, d2: {k: len(k) for k in d1}}\n    result = dict1\n    for operation in operations_dict:\n        if operation in functions:\n            try:\n                result = functions[operation](result, dict2)\n            except Exception as e:\n                return f\"Error: An error occured when performing the operation '{operation}'. {str(e)}\"\n        else:\n            return f\"Error: Undefined operation '{operation}'.\"\n    return dict(sorted(result.items()))"
    }
  ]
}