{
  "task_id": "cf_4698",
  "entry_point": "combinationSum",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if current_target == 0:",
      "mutated_line": "if current_target != 0:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target != 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target <= 0:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target <= 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target >= 0:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target >= 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target != 0:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target != 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(current_combination) == max_items:",
      "mutated_line": "if len(current_combination) != max_items:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) != max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack(0, [], target)",
      "mutated_line": "backtrack(1, [], target)",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(1, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack(0, [], target)",
      "mutated_line": "backtrack(-1, [], target)",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(-1, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "backtrack(0, [], target)",
      "mutated_line": "backtrack(1, [], target)",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(1, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if current_target == 0:",
      "mutated_line": "if current_target == 1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 1:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if current_target == 0:",
      "mutated_line": "if current_target == -1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == -1:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if current_target == 0:",
      "mutated_line": "if current_target == 1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 1:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target < 1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 1:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target < -1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < -1:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if current_target < 0:",
      "mutated_line": "if current_target < 1:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 1:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start or nums[i] == nums[i - 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start or nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i >= start and nums[i] == nums[i - 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i >= start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i <= start and nums[i] == nums[i - 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i <= start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i != start and nums[i] == nums[i - 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i != start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] != nums[i - 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] != nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i - 1, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i - 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i * 1, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i * 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + 1, current_combination, current_target + nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target + nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + 1, current_combination, current_target * nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target * nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + 2, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 2, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + 0, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 0, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + 0, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 0, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtrack(i+1, current_combination, current_target - nums[i])",
      "mutated_line": "backtrack(i + -1, current_combination, current_target - nums[i])",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + -1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i + 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i + 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i * 1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i * 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 2]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 2]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - -1]:",
      "code": "def combinationSum(nums, target, max_items):\n\n    def backtrack(start, current_combination, current_target):\n        if current_target == 0:\n            combinations.append(current_combination[:])\n            return\n        if current_target < 0:\n            return\n        if len(current_combination) == max_items:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - -1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_combination, current_target - nums[i])\n            current_combination.pop()\n    nums.sort()\n    combinations = []\n    backtrack(0, [], target)\n    return combinations"
    }
  ]
}