{
  "task_id": "cf_12210",
  "entry_point": "nearest_neighbor_tsp",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "current_city = 0",
      "mutated_line": "current_city = 1",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 1\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "current_city = 0",
      "mutated_line": "current_city = -1",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = -1\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "current_city = 0",
      "mutated_line": "current_city = 1",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 1\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited = [False] * len(distance_matrix)",
      "mutated_line": "visited = [False] / len(distance_matrix)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] / len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited = [False] * len(distance_matrix)",
      "mutated_line": "visited = [False] + len(distance_matrix)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] + len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited = [False] * len(distance_matrix)",
      "mutated_line": "visited = [False] ** len(distance_matrix)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] ** len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited[current_city] = True",
      "mutated_line": "visited[current_city] = False",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = False\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while False in visited:",
      "mutated_line": "while False not in visited:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False not in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while False in visited:",
      "mutated_line": "while True in visited:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while True in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited[next_city] = True",
      "mutated_line": "visited[next_city] = False",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = False\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited = [False] * len(distance_matrix)",
      "mutated_line": "visited = [True] * len(distance_matrix)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [True] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_distance = float('inf')",
      "mutated_line": "min_distance = float('')",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not visited[i] and distance_matrix[current_city][i] < min_distance:",
      "mutated_line": "if not visited[i] or distance_matrix[current_city][i] < min_distance:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] or distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tour.append(tour[0])",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[1])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tour.append(tour[0])",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[-1])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tour.append(tour[0])",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[1])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not visited[i] and distance_matrix[current_city][i] < min_distance:",
      "mutated_line": "if not visited[i] and distance_matrix[current_city][i] <= min_distance:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] <= min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not visited[i] and distance_matrix[current_city][i] < min_distance:",
      "mutated_line": "if not visited[i] and distance_matrix[current_city][i] >= min_distance:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] >= min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not visited[i] and distance_matrix[current_city][i] < min_distance:",
      "mutated_line": "if not visited[i] and distance_matrix[current_city][i] != min_distance:",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] != min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i - 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i * 1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) + 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) * 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 2]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 0]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 0]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + -1]] for i in range(len(tour) - 1)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 2)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 0)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 0)))\n    return (tour, total_distance)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "total_distance = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))",
      "mutated_line": "return (tour, total_distance)",
      "code": "def nearest_neighbor_tsp(distance_matrix):\n    \"\"\"\n    This function solves the Traveling Salesman Problem using the Nearest Neighbor Algorithm.\n    \n    Args:\n    distance_matrix (list): A 2D list representing the distances between cities.\n    \n    Returns:\n    list: A list of city indices representing the order in which the cities should be visited.\n    int: The total distance of the tour.\n    \"\"\"\n    current_city = 0\n    visited = [False] * len(distance_matrix)\n    visited[current_city] = True\n    tour = [current_city]\n    while False in visited:\n        min_distance = float('inf')\n        next_city = None\n        for i in range(len(distance_matrix)):\n            if not visited[i] and distance_matrix[current_city][i] < min_distance:\n                min_distance = distance_matrix[current_city][i]\n                next_city = i\n        tour.append(next_city)\n        visited[next_city] = True\n        current_city = next_city\n    tour.append(tour[0])\n    total_distance = sum((distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - -1)))\n    return (tour, total_distance)"
    }
  ]
}