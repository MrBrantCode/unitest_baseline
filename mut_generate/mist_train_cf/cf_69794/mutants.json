{
  "task_id": "cf_69794",
  "entry_point": "find_min_disparity",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_min_disparity(arr):\n    \"\"\"\"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) <= 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) >= 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) != 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 3:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 1:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 0:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 1:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(valid) < 2:",
      "mutated_line": "if valid[i] - valid[i - 1] < min_disparity:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < -2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"Array must have at least two numeric elements\"",
      "mutated_line": "min_disparity = valid[i] - valid[i - 1]",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return ''\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "min_disparity = float('inf')",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(1, len(valid)):",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(2, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(1, len(valid)):",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(0, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(1, len(valid)):",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(0, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(1, len(valid)):",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(-1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] <= min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] >= min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] != min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] + valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] * valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] + valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] * valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i + 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i * 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i + 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i * 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i + 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i * 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 2] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 0] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 0] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if valid[i] - valid[i-1] < min_disparity:",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - -1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 2]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 0]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 0]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "min_disparity = valid[i] - valid[i-1]",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - -1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 2], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 0], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 0], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pair = (valid[i-1], valid[i])",
      "mutated_line": "return (min_disparity, pair)",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - -1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 'j' in item:",
      "mutated_line": "except ValueError:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if 'j' not in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 'j' in item:",
      "mutated_line": "except ValueError:",
      "code": "def find_min_disparity(arr):\n    \"\"\"\n  This function takes an input list of multiple element types, isolates valid numerical values, \n  sorts them, and finds the two elements with the smallest difference (disparity).\n  \n  Args:\n  arr (list): A list containing multiple element types.\n\n  Returns:\n  tuple: A tuple containing the minimum disparity and the pair of numbers that achieve this disparity.\n         If the input list contains less than two numeric elements, return a message indicating this.\n  \"\"\"\n    flattened = []\n    for item in arr:\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                if isinstance(x, (list, tuple)):\n                    flattened.extend(find_min_disparity(x))\n                else:\n                    flattened.append(x)\n        else:\n            flattened.append(item)\n    valid = []\n    for item in flattened:\n        if isinstance(item, bool):\n            valid.append(int(item))\n        elif isinstance(item, complex):\n            valid.append(abs(item))\n        elif isinstance(item, (int, float)):\n            valid.append(item)\n        elif isinstance(item, str):\n            try:\n                if '' in item:\n                    valid.append(abs(complex(item)))\n                else:\n                    valid.append(float(item))\n            except ValueError:\n                pass\n    if len(valid) < 2:\n        return 'Array must have at least two numeric elements'\n    valid.sort()\n    min_disparity = float('inf')\n    pair = (None, None)\n    for i in range(1, len(valid)):\n        if valid[i] - valid[i - 1] < min_disparity:\n            min_disparity = valid[i] - valid[i - 1]\n            pair = (valid[i - 1], valid[i])\n    return (min_disparity, pair)"
    }
  ]
}