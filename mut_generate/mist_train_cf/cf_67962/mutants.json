{
  "task_id": "cf_67962",
  "entry_point": "shortest_path",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current != end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(1, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(-1, start)]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(-1, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "heap = [(0, start)]",
      "mutated_line": "heap = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(1, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = {start: (None, 0)}",
      "mutated_line": "paths = {start: (None, 1)}",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 1)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = {start: (None, 0)}",
      "mutated_line": "paths = {start: (None, -1)}",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, -1)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = {start: (None, 0)}",
      "mutated_line": "paths = {start: (None, 1)}",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 1)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while current is not None:",
      "mutated_line": "while current is None:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) or 0 <= y < len(grid[0]) or grid[x][y] != 1:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) or 0 <= y < len(grid[0]) or grid[x][y] != 1:\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] - dx, current[1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] - dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] * dx, current[1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] * dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[1] - dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] - dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[1] * dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] * dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 < x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 < x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 > x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 > x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 == x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 == x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 < y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 < y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 > y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 > y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 == y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 == y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] == 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] == 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost - 1",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost - 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost * 1",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost * 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths and new_cost < paths[next_node][1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths and new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "current = paths[current][0]",
      "mutated_line": "current = paths[current][1]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][1]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "current = paths[current][0]",
      "mutated_line": "current = paths[current][-1]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][-1]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "current = paths[current][0]",
      "mutated_line": "current = paths[current][1]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][1]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::+1]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::+1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if -1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if -1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and -1 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and -1 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 2):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 2):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 0):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 0):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 0):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 0):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != -1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != -1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost + 2",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 2\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost + 0",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 0\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost + 0",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 0\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "new_cost = cost + 1",
      "mutated_line": "new_cost = cost + -1",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + -1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node in paths or new_cost < paths[next_node][1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost <= paths[next_node][1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost <= paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost >= paths[next_node][1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost >= paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost != paths[next_node][1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost != paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-2]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-2]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-0]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::-0]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-0]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return path[::-1]",
      "mutated_line": "return path[::--1]",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::--1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[1] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[-1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[-1] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[1] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[2] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[2] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[0] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[0] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x, y = current[0] + dx, current[1] + dy",
      "mutated_line": "(x, y) = (current[0] + dx, current[-1] + dy)",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[-1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[-1]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[-1]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 1:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (grid[x][y] != 1):",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost < paths[next_node][2]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][2]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost < paths[next_node][0]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][0]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost < paths[next_node][0]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][0]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if next_node not in paths or new_cost < paths[next_node][1]:",
      "mutated_line": "if next_node not in paths or new_cost < paths[next_node][-1]:",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][-1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) - abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) - abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, ((new_cost + abs(x - end[0])) * abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, ((new_cost + abs(x - end[0])) * abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost - abs(x - end[0]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost - abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost * abs(x - end[0]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost * abs(x - end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y + end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y + end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y * end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y * end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x + end[0]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x + end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x * end[0]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x * end[0]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[2]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[2]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[0]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[0]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[0]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[0]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[-1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[-1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[1]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[1]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[-1]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[-1]) + abs(y - end[1]), next_node))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heapq.heappush(heap, (new_cost + abs(x - end[0]) + abs(y - end[1]), next_node))",
      "mutated_line": "heapq.heappush(heap, (new_cost + abs(x - end[1]) + abs(y - end[1]), next_node))",
      "code": "import heapq\n\ndef shortest_path(grid, start, end):\n    heap = [(0, start)]\n    paths = {start: (None, 0)}\n    while heap:\n        (cost, current) = heapq.heappop(heap)\n        if current == end:\n            path = []\n            while current is not None:\n                path.append(current)\n                current = paths[current][0]\n            return path[::-1]\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (x, y) = (current[0] + dx, current[1] + dy)\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (grid[x][y] != 1):\n                next_node = (x, y)\n                new_cost = cost + 1\n                if next_node not in paths or new_cost < paths[next_node][1]:\n                    paths[next_node] = (current, new_cost)\n                    heapq.heappush(heap, (new_cost + abs(x - end[1]) + abs(y - end[1]), next_node))\n    return None"
    }
  ]
}