{
  "task_id": "cf_82041",
  "entry_point": "kruskal_algo",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = 1",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 1\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = -1",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = -1\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = 1",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 1\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [0] / vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] / vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [0] + vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] + vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [0] ** vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] ** vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if parent[i] == i:",
      "mutated_line": "if parent[i] != i:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] != i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if rank[xroot] < rank[yroot]:",
      "mutated_line": "if rank[xroot] <= rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] <= rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if rank[xroot] < rank[yroot]:",
      "mutated_line": "if rank[xroot] >= rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] >= rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if rank[xroot] < rank[yroot]:",
      "mutated_line": "if rank[xroot] != rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] != rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if x != y:",
      "mutated_line": "if x == y:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x == y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ASR",
      "lineno": 58,
      "original_line": "total_weight += w",
      "mutated_line": "return (mst, total_weight)",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight -= w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [1] * vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [1] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [-1] * vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [-1] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rank = [0] * vertices",
      "mutated_line": "rank = [1] * vertices",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [1] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif rank[xroot] > rank[yroot]:",
      "mutated_line": "elif rank[xroot] >= rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] >= rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif rank[xroot] > rank[yroot]:",
      "mutated_line": "elif rank[xroot] <= rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] <= rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif rank[xroot] > rank[yroot]:",
      "mutated_line": "elif rank[xroot] != rank[yroot]:",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] != rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "rank[xroot] += 1",
      "mutated_line": "rank[xroot] -= 1",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] -= 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank[xroot] += 1",
      "mutated_line": "rank[xroot] += 2",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 2\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank[xroot] += 1",
      "mutated_line": "rank[xroot] += 0",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 0\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank[xroot] += 1",
      "mutated_line": "rank[xroot] += 0",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 0\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank[xroot] += 1",
      "mutated_line": "rank[xroot] += -1",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += -1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "edges.sort(key=lambda item: item[2])",
      "mutated_line": "edges.sort(key=lambda item: item[3])",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[3])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "edges.sort(key=lambda item: item[2])",
      "mutated_line": "edges.sort(key=lambda item: item[1])",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[1])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "edges.sort(key=lambda item: item[2])",
      "mutated_line": "edges.sort(key=lambda item: item[0])",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[0])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "edges.sort(key=lambda item: item[2])",
      "mutated_line": "edges.sort(key=lambda item: item[1])",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[1])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "edges.sort(key=lambda item: item[2])",
      "mutated_line": "edges.sort(key=lambda item: item[-2])",
      "code": "def kruskal_algo(edges, vertices):\n    \"\"\"\n    This function implements Kruskal's algorithm to find the Minimum Spanning Tree of a graph.\n\n    Args:\n    edges (list): A list of edges, where each edge is a list containing two vertices and a weight.\n    vertices (int): The number of vertices in the graph.\n\n    Returns:\n    list: The edges in the Minimum Spanning Tree and the total weight of the tree.\n    \"\"\"\n    edges.sort(key=lambda item: item[-2])\n    mst = []\n    total_weight = 0\n    parent = list(range(vertices))\n    rank = [0] * vertices\n\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    for (u, v, w) in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            mst.append([u, v, w])\n            union(parent, rank, x, y)\n            total_weight += w\n    return (mst, total_weight)"
    }
  ]
}