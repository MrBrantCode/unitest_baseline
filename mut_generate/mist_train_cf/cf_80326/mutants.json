{
  "task_id": "cf_80326",
  "entry_point": "square_rooting_and_conversion",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 and base < 2 and (base > 16) and (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 and base < 2 and (base > 16) and (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if complexity == \"squareroot\":",
      "mutated_line": "if complexity != 'squareroot':",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity != 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n <= 1 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n <= 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n >= 1 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n >= 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n != 1 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n != 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base <= 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base <= 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base >= 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base >= 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base != 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base != 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base >= 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base >= 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base <= 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base <= 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base != 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base != 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision <= 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision <= 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision >= 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision >= 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision != 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision != 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return +1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if complexity == \"squareroot\":",
      "mutated_line": "if complexity == '':",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == '':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif complexity == \"root\":",
      "mutated_line": "elif complexity != 'root':",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity != 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "chars = \"0123456789ABCDEF\"",
      "mutated_line": "chars = ''",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = ''\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if num < base:",
      "mutated_line": "if num <= base:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num <= base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if num < base:",
      "mutated_line": "if num >= base:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num >= base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if num < base:",
      "mutated_line": "if num != base:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num != base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "chars = \"0123456789ABCDEF\"",
      "mutated_line": "chars = ''",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = ''\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result = \"\"",
      "mutated_line": "result = 'MUTATED'",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = 'MUTATED'\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "result += chars[digit]",
      "mutated_line": "result -= chars[digit]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result -= chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "num -= digit",
      "mutated_line": "num += digit",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num += digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) * 10 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) * 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) // 10 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) // 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 2 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 2 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 0 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 0 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 0 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 0 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < -1 or base < 2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < -1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 3 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 3 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 1 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 1 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 0 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 0 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 1 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 1 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < -2 or base > 16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < -2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 17 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 17 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 15 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 15 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 0 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 0 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 1 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 1 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > -16 or (precision < 0):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > -16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision < 1):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 1):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision < -1):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < -1):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 1 or base < 2 or base > 16 or precision < 0:",
      "mutated_line": "if n < 1 or base < 2 or base > 16 or (precision < 1):",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 1):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -2\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -0\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -0\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return --1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n + l - 1))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l - 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, (n + l) * 1))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, (n + l) * 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif complexity == \"root\":",
      "mutated_line": "elif complexity == '':",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == '':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l <= 1:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l <= 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l >= 1:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l >= 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l != 1:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l != 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return +1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num // base, base) - chars[num % base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) - chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num // base, base) * chars[num % base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) * chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "num = num * base",
      "mutated_line": "num = num / base",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num / base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "num = num * base",
      "mutated_line": "num = num + base",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num + base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "num = num * base",
      "mutated_line": "num = num ** base",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num ** base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "integer_part, fraction_part = str(decimal).split('.')",
      "mutated_line": "(integer_part, fraction_part) = str(decimal).split('')",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / (10 * len(str(fraction_part)))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / (10 * len(str(fraction_part)))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / (10 + len(str(fraction_part)))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / (10 + len(str(fraction_part)))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('0b' + str(integer_part) + '.' - str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' - str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append(('0b' + str(integer_part) + '.') * str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append(('0b' + str(integer_part) + '.') * str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n - l + 1))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n - l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n * l + 1))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n * l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n + l + 2))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 2))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n + l + 0))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 0))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n + l + 0))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 0))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "numbers = list(range(n, n+l+1))",
      "mutated_line": "numbers = list(range(n, n + l + -1))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + -1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l < 2:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 2:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l < 0:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 0:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l < 0:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 0:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l < 1:",
      "mutated_line": "if l < -1:",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < -1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return +1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -2\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -0\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -0\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return --1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / 11 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 11 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / 9 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 9 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / 0 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 0 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / 1 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 1 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "fraction_part = int(fraction_part) / (10 ** len(str(fraction_part)))",
      "mutated_line": "fraction_part = int(fraction_part) / -10 ** len(str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / -10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('0b' + str(integer_part) - '.' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) - '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append(('0b' + str(integer_part)) * '.' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append(('0b' + str(integer_part)) * '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -2\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -0\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -0\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return --1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, 1 * l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 * l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, 1 // l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 // l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num / base, base) + chars[num % base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num / base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num * base, base) + chars[num % base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num * base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num // base, base) + chars[num * base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num * base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return decimal_to_base(num // base, base) + chars[num % base]",
      "mutated_line": "return decimal_to_base(num // base, base) + chars[num + base]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num + base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('0b' - str(integer_part) + '.' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' - str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('0b' * str(integer_part) + '.' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' * str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('0b' + str(integer_part) + '' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, 2 / l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 2 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, 0 / l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 0 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, 0 / l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 0 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "operations = [math.pow(num, 1/l) for num in numbers]",
      "mutated_line": "operations = [math.pow(num, -1 / l) for num in numbers]",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, -1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('0b' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "result.append(\"0b\" + str(integer_part) + \".\" + str(fraction_part))",
      "mutated_line": "result.append('' + str(integer_part) + '.' + str(fraction_part))",
      "code": "import math\n\ndef square_rooting_and_conversion(n, l, base, precision, complexity):\n    if n < 1 or base < 2 or base > 16 or (precision < 0):\n        return -1\n    numbers = list(range(n, n + l + 1))\n    result = []\n    if complexity == 'squareroot':\n        operations = [math.sqrt(num) for num in numbers]\n    elif complexity == 'root':\n        if l < 1:\n            return -1\n        operations = [math.pow(num, 1 / l) for num in numbers]\n    else:\n        return -1\n\n    def decimal_to_base(num, base):\n        chars = '0123456789ABCDEF'\n        if num < base:\n            return chars[num]\n        else:\n            return decimal_to_base(num // base, base) + chars[num % base]\n\n    def fraction_to_base_n(num, base, precision):\n        chars = '0123456789ABCDEF'\n        result = ''\n        for _ in range(precision):\n            num = num * base\n            digit = int(num)\n            result += chars[digit]\n            num -= digit\n        return result\n    for operation in operations:\n        decimal = round(operation, precision)\n        (integer_part, fraction_part) = str(decimal).split('.')\n        integer_part = int(integer_part)\n        fraction_part = int(fraction_part) / 10 ** len(str(fraction_part))\n        integer_part = decimal_to_base(integer_part, base)\n        fraction_part = fraction_to_base_n(fraction_part, base, precision)\n        result.append('' + str(integer_part) + '.' + str(fraction_part))\n    return result"
    }
  ]
}