{
  "task_id": "cf_60493",
  "entry_point": "lazy_propagation",
  "mutant_count": 438,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] / (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] / (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] + 4 * self.n",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] + 4 * self.n\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] ** (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] ** (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] / (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] / (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] + 4 * self.n",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] + 4 * self.n\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] ** (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] ** (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if start == end:",
      "mutated_line": "if start != end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start != end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end and end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end and end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] == 0:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] == 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] -= self.lazy[node] * (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] -= self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start or end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start or end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] -= (end - start + 1) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] -= (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end and end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end and end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] == 0:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] == 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] -= self.lazy[node] * (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] -= self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start or end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start or end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) / 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) / 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) * 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) * 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) - self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) - self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) * self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) * self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(1, 0, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(1, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(-1, 0, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(-1, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(1, 0, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(1, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 1, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 1, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, -1, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, -1, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 1, len(arr) - 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 1, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) + 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) + 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) * 1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) * 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(1, 0, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(1, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(-1, 0, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(-1, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(1, 0, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(1, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 1, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 1, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, -1, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, -1, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 1, len(arr) - 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 1, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) + 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) + 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) * 1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) * 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (4 / self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 / self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (4 + self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 + self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * 4 ** self.n",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * 4 ** self.n\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (4 / self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 / self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (4 + self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 + self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * 4 ** self.n",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * 4 ** self.n\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 1, 0, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 1, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, -1, 0, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, -1, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 1, 0, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 1, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 1, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 1, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, -1, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, -1, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 1, self.n - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 1, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n + 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n * 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n * 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) / 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) / 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) * 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) * 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] - self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] - self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] * self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] * self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start >= range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start >= range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start <= range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start <= range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start != range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start != range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end <= range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end <= range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end >= range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end >= range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end != range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end != range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != 1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != -1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != -1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != 1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] / (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] / (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] + (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] + (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] ** (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] ** (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if start != end:",
      "mutated_line": "if start == end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start == end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] -= self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] -= self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 2] -= self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] -= self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 1\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = -1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = -1\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 1\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start > range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start > range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start < range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start < range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start == range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start == range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end < range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end < range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end > range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end > range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end == range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end == range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + 1) / val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) / val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += end - start + 1 + val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += end - start + 1 + val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + 1) ** val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) ** val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if start != end:",
      "mutated_line": "if start == end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start == end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node + 1] -= val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] -= val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + 2] -= val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] -= val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) / 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) / 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) * 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) * 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] - self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] - self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] * self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] * self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start >= range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start >= range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start <= range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start <= range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start != range_end or end < range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start != range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end <= range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end <= range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end >= range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end >= range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if start > range_end or end < range_start:",
      "mutated_line": "if start > range_end or end != range_start:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end != range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 1\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return -1\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 1\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != 1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != -1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != -1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if self.lazy[node] != 0:",
      "mutated_line": "if self.lazy[node] != 1:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 1:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] / (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] / (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] + (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] + (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] ** (end - start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] ** (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if start != end:",
      "mutated_line": "if start == end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start == end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] -= self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] -= self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 2] -= self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] -= self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 1\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = -1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = -1\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "self.lazy[node] = 0",
      "mutated_line": "self.lazy[node] = 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 1\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start > range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start > range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start < range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start < range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start == range_start and end <= range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start == range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end < range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end < range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end > range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end > range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if start >= range_start and end <= range_end:",
      "mutated_line": "if start >= range_start and end == range_end:",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end == range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start - end) // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start - end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = start * end // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = start * end // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 3",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 3\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 1\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 0",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 0\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 1\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // -2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // -2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) - 2, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 2, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) - 0, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 0, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) - 0, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 0, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)",
      "mutated_line": "segment_tree.update_range(0, 0, len(arr) - -1, start, end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - -1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) - 2, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 2, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) - 0, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 0, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) - 0, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 0, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)",
      "mutated_line": "return segment_tree.query(0, 0, len(arr) - -1, q_start, q_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - -1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [1] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [-1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [-1] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [1] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (5 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (5 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (3 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (3 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (0 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (0 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (1 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (1 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (4 * self.n)",
      "mutated_line": "self.tree = [0] * (-4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (-4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [1] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [-1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [-1] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [1] * (4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [1] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (5 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (5 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (3 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (3 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (0 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (0 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (1 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (1 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.lazy = [0] * (4 * self.n)",
      "mutated_line": "self.lazy = [0] * (-4 * self.n)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (-4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n - 2)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 2)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n - 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 0)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n - 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 0)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.build_tree(arr, 0, 0, self.n - 1)",
      "mutated_line": "self.build_tree(arr, 0, 0, self.n - -1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - -1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start - end) // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start - end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = start * end // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = start * end // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 3",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 3\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 1\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 0",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 0\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 1\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // -2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // -2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node - 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node - 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node * 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node * 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node - 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node - 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node * 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node * 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid - 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid - 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid * 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid * 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start - 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * ((end - start) * 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * ((end - start) * 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start - 1) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start - 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start) * 1 * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start) * 1 * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start - end) // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start - end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = start * end // 2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = start * end // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 3",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 3\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 1\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 0",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 0\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 1\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // -2",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // -2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node - 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node - 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node * 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node * 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node - 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node - 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node * 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node * 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid - 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid - 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid * 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid * 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start - 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start - 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * ((end - start) * 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * ((end - start) * 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node - 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node - 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node * 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node * 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node - 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node - 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node * 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node * 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid - 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid - 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid * 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid * 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 / node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 / node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 + node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 + node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 ** node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 ** node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 2, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node + 0, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 0, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node + 0, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 0, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 2 * node + -1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + -1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 / node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 / node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 + node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 + node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 ** node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 ** node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 3, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 3, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 1, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 0, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 0, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 1, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + -2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + -2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid + 2, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 2, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid + 0, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 0, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid + 0, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 0, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 2 * node + 2, mid + -1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + -1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node - 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node - 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node * 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node * 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node - 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node - 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node * 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node * 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end + start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end + start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end * start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end * start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 2)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 2)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 0)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 0)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + -1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + -1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node - 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node - 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node * 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node * 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node - 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node - 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node * 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node * 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end + start + 1) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end + start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end * start + 1) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end * start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + 2) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 2) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + 0) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 0) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + 0) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 0) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.tree[node] += (end - start + 1) * val",
      "mutated_line": "self.tree[node] += (end - start + -1) * val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + -1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node - 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node - 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node * 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node * 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node - 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node - 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node * 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node * 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 / node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 / node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 + node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 + node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 ** node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 ** node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 2, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 0, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 0, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 0, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 0, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + -1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + -1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 / node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 / node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 + node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 + node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 ** node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 ** node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 3, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 3, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 1, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 1, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 0, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 0, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 1, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 1, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + -2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + -2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid + 2, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 2, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid + 0, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 0, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid + 0, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 0, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(2 * node + 2, mid + -1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + -1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node - 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node - 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node * 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node * 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node - 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node - 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node * 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node * 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end + start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end + start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end * start + 1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end * start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 2)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 2)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 0)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + 0)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 0)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "self.tree[node] += self.lazy[node] * (end - start + 1)",
      "mutated_line": "self.tree[node] += self.lazy[node] * (end - start + -1)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + -1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node - 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node - 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node * 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node * 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node - 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node - 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node * 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node * 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 / node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 / node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 + node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 + node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 ** node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 ** node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 2, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 2, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 0, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 0, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 0, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 0, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + -1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + -1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 / node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 / node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 + node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 + node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 ** node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 ** node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 3, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 3, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 1, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 1, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 0, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 0, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 1, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 1, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + -2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + -2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 2, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 2, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 0, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 0, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 0, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 0, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + -1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + -1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 3 * node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 3 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 1 * node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 1 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 0 * node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 0 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, 1 * node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 1 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.build_tree(arr, 2 * node + 1, start, mid)",
      "mutated_line": "self.build_tree(arr, -2 * node + 1, start, mid)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, -2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 3 * node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 3 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 1 * node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 1 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 0 * node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 0 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, 1 * node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 1 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.build_tree(arr, 2 * node + 2, mid + 1, end)",
      "mutated_line": "self.build_tree(arr, -2 * node + 2, mid + 1, end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, -2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 / node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 / node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 + node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 + node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 ** node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 ** node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 2] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 2] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + -1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + -1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 / node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 / node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 + node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 + node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 ** node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 ** node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 3]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 3]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 0]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 0]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + -2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + -2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 / node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 / node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 + node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 + node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 ** node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 ** node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 2] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 0] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 0] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + -1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + -1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 / node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 / node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 + node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 + node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 ** node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 ** node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 3] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 3] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 0] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + -2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + -2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 / node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 / node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 + node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 + node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 ** node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 ** node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 2] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node + 0] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 0] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node + 0] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 0] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[2 * node + -1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + -1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 / node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 / node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 + node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 + node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 ** node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 ** node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + 3] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 3] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 1] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + 0] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 0] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 1] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[2 * node + -2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + -2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(3 * node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(3 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(1 * node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(1 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(0 * node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(0 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(1 * node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(1 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "self.update_range(2 * node + 1, start, mid, range_start, range_end, val)",
      "mutated_line": "self.update_range(-2 * node + 1, start, mid, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(-2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(3 * node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(3 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(1 * node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(1 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(0 * node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(0 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(1 * node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(1 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "mutated_line": "self.update_range(-2 * node + 2, mid + 1, end, range_start, range_end, val)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(-2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 / node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 / node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 + node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 + node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 ** node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 ** node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 2] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 2] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 0] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + -1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + -1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 / node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 / node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 + node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 + node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 ** node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 ** node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 3]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 3]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 0]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 0]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 1]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + -2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + -2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 / node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 / node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 + node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 + node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 ** node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 ** node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 2] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 0] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 0] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + -1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + -1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 / node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 / node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 + node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 + node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 ** node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 ** node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 3] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 3] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 0] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 0] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 1] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[2 * node + -2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + -2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(3 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(3 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(1 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(1 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(0 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(0 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(1 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(1 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(-2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(-2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(3 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(3 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(1 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(1 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(0 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(0 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(1 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(1 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)",
      "mutated_line": "return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(-2 * node + 2, mid + 1, end, range_start, range_end)",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(-2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[3 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[3 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[0 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[0 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[-2 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[-2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[3 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[3 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[0 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[0 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[-2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[-2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[3 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[3 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[1 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[0 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[0 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[1 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[-2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[-2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[3 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[3 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[1 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[0 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[0 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[1 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[-2 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[-2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[3 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[3 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[1 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[1 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[0 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[0 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[1 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[1 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.lazy[2 * node + 1] += val",
      "mutated_line": "self.lazy[-2 * node + 1] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[-2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[3 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[3 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[1 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[1 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[0 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[0 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[1 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[1 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "self.lazy[2 * node + 2] += val",
      "mutated_line": "self.lazy[-2 * node + 2] += val",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[-2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[3 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[3 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[0 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[0 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[1 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[-2 * node + 1] + self.tree[2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[-2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[3 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[3 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[0 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[0 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[1 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]",
      "mutated_line": "self.tree[node] = self.tree[2 * node + 1] + self.tree[-2 * node + 2]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[-2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[3 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[3 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[1 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[0 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[0 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[1 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.lazy[2 * node + 1] += self.lazy[node]",
      "mutated_line": "self.lazy[-2 * node + 1] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[-2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[3 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[3 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[1 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[0 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[0 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[1 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[1 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "self.lazy[2 * node + 2] += self.lazy[node]",
      "mutated_line": "self.lazy[-2 * node + 2] += self.lazy[node]",
      "code": "class SegmentTree:\n\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self.build_tree(arr, 0, 0, self.n - 1)\n\n    def build_tree(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_tree(arr, 2 * node + 1, start, mid)\n            self.build_tree(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def update_range(self, node, start, end, range_start, range_end, val):\n        if start > range_end or end < range_start:\n            return\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            self.tree[node] += (end - start + 1) * val\n            if start != end:\n                self.lazy[2 * node + 1] += val\n                self.lazy[2 * node + 2] += val\n        else:\n            mid = (start + end) // 2\n            self.update_range(2 * node + 1, start, mid, range_start, range_end, val)\n            self.update_range(2 * node + 2, mid + 1, end, range_start, range_end, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, node, start, end, range_start, range_end):\n        if start > range_end or end < range_start:\n            return 0\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node] * (end - start + 1)\n            if start != end:\n                self.lazy[2 * node + 1] += self.lazy[node]\n                self.lazy[-2 * node + 2] += self.lazy[node]\n            self.lazy[node] = 0\n        if start >= range_start and end <= range_end:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, range_start, range_end) + self.query(2 * node + 2, mid + 1, end, range_start, range_end)\n\ndef lazy_propagation(arr, start, end, val, q_start, q_end):\n    segment_tree = SegmentTree(arr)\n    segment_tree.update_range(0, 0, len(arr) - 1, start, end, val)\n    return segment_tree.query(0, 0, len(arr) - 1, q_start, q_end)"
    }
  ]
}