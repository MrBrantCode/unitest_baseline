{
  "task_id": "cf_88365",
  "entry_point": "weighted_binary_cross_entropy",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "loss = 0.0",
      "mutated_line": "loss = 1.0",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 1.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "loss = 0.0",
      "mutated_line": "loss = -1.0",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = -1.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "loss = 0.0",
      "mutated_line": "loss = 1",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 1\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "accumulated_weight = 0",
      "mutated_line": "accumulated_weight = 1",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 1\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "accumulated_weight = 0",
      "mutated_line": "accumulated_weight = -1",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = -1\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "accumulated_weight = 0",
      "mutated_line": "accumulated_weight = 1",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 1\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss -= weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss -= weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "accumulated_weight += weight",
      "mutated_line": "accumulated_weight -= weight",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight -= weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return -loss / total_weight",
      "mutated_line": "return -loss * total_weight",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss * total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return -loss / total_weight",
      "mutated_line": "return -loss // total_weight",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss // total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight / (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight / (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight + (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight + (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight ** (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight ** (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if accumulated_weight == total_weight:",
      "mutated_line": "if accumulated_weight != total_weight:",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight != total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return -loss / total_weight",
      "mutated_line": "return +loss / total_weight",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return +loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) - (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) - (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) * ((1 - y) * np.log(1 - y + 1e-15)))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) * ((1 - y) * np.log(1 - y + 1e-15)))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y / np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y / np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y + np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y + np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y ** np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y ** np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) / np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) / np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y + np.log(1 - y + 1e-15)))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y + np.log(1 - y + 1e-15)))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) ** np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) ** np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 + y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 + y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + 1 * y * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + 1 * y * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y - 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y - 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y * 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y * 1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (2 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (2 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (0 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (0 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (0 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (0 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (-1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (-1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y - 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y - 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log((1 - y) * 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log((1 - y) * 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1.000000000000001) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1.000000000000001) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + -0.999999999999999) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + -0.999999999999999) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 0) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 0) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + -1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + -1e-15) + (1 - y) * np.log(1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 + y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 + y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 * y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 * y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1.000000000000001))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1.000000000000001))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + -0.999999999999999))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + -0.999999999999999))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 0))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 0))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + -1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + -1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(2 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(2 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(0 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(0 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(0 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(0 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(1 - y + 1e-15))",
      "mutated_line": "loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(-1 - y + 1e-15))",
      "code": "import numpy as np\n\ndef weighted_binary_cross_entropy(y_true, y_pred, weights):\n    sorted_indices = np.argsort(weights)\n    sorted_weights = np.array(weights)[sorted_indices]\n    sorted_y_pred = np.array(y_pred)[sorted_indices]\n    loss = 0.0\n    accumulated_weight = 0\n    total_weight = np.sum(weights)\n    for (weight, y) in zip(sorted_weights, sorted_y_pred):\n        loss += weight * (y * np.log(y + 1e-15) + (1 - y) * np.log(-1 - y + 1e-15))\n        accumulated_weight += weight\n        if accumulated_weight == total_weight:\n            break\n    return -loss / total_weight"
    }
  ]
}