{
  "task_id": "cf_49471",
  "entry_point": "shortestPathBinaryMatrix",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] and grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] and grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return +1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return +1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1  # if start or end is blocked",
      "mutated_line": "return +1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return +1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x != y == n - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x != y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1  # If no path found",
      "mutated_line": "return --1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][1] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][1] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][-1] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][-1] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][1] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][1] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n + 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n + 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n * 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n * 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1  # if start or end is blocked",
      "mutated_line": "return -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -2\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1  # if start or end is blocked",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -0\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1  # if start or end is blocked",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -0\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1  # if start or end is blocked",
      "mutated_line": "return --1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return --1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n + 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n + 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n * 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n * 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n or 0 <= ny < n or (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n or 0 <= ny < n or (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[1][0] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[1][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[-1][0] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[-1][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[1][0] or grid[n - 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[1][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n + 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n + 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n * 1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n * 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n - 2]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 2]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n - 0]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 0]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n - 0]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 0]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 1][n - -1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - -1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(1, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(-1, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(1, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 1, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, -1, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 1, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 2)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 0)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 0)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = deque([(0, 0, 1)])  # queue for BFS, storing (row, col, path length)",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, -1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (-1,-1), (1,-1), (-1,1)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n - 2:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 2:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n - 0:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 0:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n - 0:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 0:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == y == n - 1:  # If reached end, return path length",
      "mutated_line": "if x == y == n - -1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - -1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 < nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 > nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 == nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and 0 < ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 < ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and 0 > ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 > ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and 0 == ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 == ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "grid[nx][ny] = 1  # Mark as visited",
      "mutated_line": "grid[nx][ny] = 2",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "grid[nx][ny] = 1  # Mark as visited",
      "mutated_line": "grid[nx][ny] = 0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "grid[nx][ny] = 1  # Mark as visited",
      "mutated_line": "grid[nx][ny] = 0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "grid[nx][ny] = 1  # Mark as visited",
      "mutated_line": "grid[nx][ny] = -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 2][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 2][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 0][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 0][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - 0][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 0][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if grid[0][0] or grid[n - 1][n - 1]:",
      "mutated_line": "if grid[0][0] or grid[n - -1][n - 1]:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - -1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if -1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and -1 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and -1 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < n and 0 <= ny < n and not grid[nx][ny]:  # If cell is available",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < n and (not grid[nx][ny]):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length - 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length * 1))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 2))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 0))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + 0))\n                grid[nx][ny] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((nx, ny, length + 1))",
      "mutated_line": "return -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]:\n        return -1\n    q = deque([(0, 0, 1)])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    while q:\n        (x, y, length) = q.popleft()\n        if x == y == n - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and (not grid[nx][ny]):\n                q.append((nx, ny, length + -1))\n                grid[nx][ny] = 1\n    return -1"
    }
  ]
}