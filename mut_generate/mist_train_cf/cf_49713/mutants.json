{
  "task_id": "cf_49713",
  "entry_point": "minPath",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(path) == k:",
      "mutated_line": "if len(path) != k:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) != k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 1, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], -1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], -1, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 1, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 1, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 1, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, -1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, -1, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 1, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 1, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(1, 0): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(1, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(-1, 0): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(-1, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(1, 0): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(1, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 1): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 1): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, -1): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, -1): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 1): grid[0][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 1): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[0][1]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][1]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[0][-1]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][-1]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[0][1]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][1]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 and nx >= m and (ny < 0) and (ny >= n) and ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 and nx >= m and (ny < 0) and (ny >= n) and ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited[nx, ny] = sum_ + grid[nx][ny]",
      "mutated_line": "visited[nx, ny] = sum_ - grid[nx][ny]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ - grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited[nx, ny] = sum_ + grid[nx][ny]",
      "mutated_line": "visited[nx, ny] = sum_ * grid[nx][ny]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ * grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[1]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[-1]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[1]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][1], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][-1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][-1], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][1], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][1], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[1][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[1][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[-1][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[-1][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = {(0, 0): grid[0][0]}",
      "mutated_line": "visited = {(0, 0): grid[1][0]}",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[1][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx <= 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx <= 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx >= 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx >= 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx != 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx != 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx > m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx > m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx < m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx < m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx == m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx == m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny <= 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny <= 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny >= 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny >= 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny != 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny != 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny > n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny > n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny < n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny < n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny == n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny == n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited or visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited or visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[1][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[-1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[-1][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[1][0], 0, 0, [grid[0][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[1][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][1]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][-1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][-1]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][1]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][1]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < -1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < -1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 1 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < -1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < -1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 1 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) not in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) not in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] < sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] < sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] > sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] > sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] == sum_ + grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] == sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "mutated_line": "heapq.heappush(heap_queue, (sum_ - grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ - grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "mutated_line": "heapq.heappush(heap_queue, (sum_ * grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ * grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "mutated_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path - [grid[nx][ny]]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path - [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))",
      "mutated_line": "heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path * [grid[nx][ny]]))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path * [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[1][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[-1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[-1][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]",
      "mutated_line": "heap_queue = [(grid[0][0], 0, 0, [grid[1][0]])]",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[1][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ - grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ - grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if nx < 0 or nx >= m or ny < 0 or ny >= n or (nx, ny) in visited and visited[nx, ny] <= sum_ + grid[nx][ny]:",
      "mutated_line": "if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ * grid[nx][ny]):",
      "code": "import heapq\n\ndef minPath(grid, k):\n    (m, n) = (len(grid), len(grid[0]))\n    heap_queue = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap_queue:\n        (sum_, x, y, path) = heapq.heappop(heap_queue)\n        if len(path) == k:\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if nx < 0 or nx >= m or ny < 0 or (ny >= n) or ((nx, ny) in visited and visited[nx, ny] <= sum_ * grid[nx][ny]):\n                continue\n            heapq.heappush(heap_queue, (sum_ + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n            visited[nx, ny] = sum_ + grid[nx][ny]\n    return []"
    }
  ]
}