{
  "task_id": "cf_63051",
  "entry_point": "monotonic_extended",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def monotonic_extended(l: list, strict: bool = False, ignore_negative: bool = False, ignore_zero: bool = False):",
      "mutated_line": "def monotonic_extended(l: list, strict: bool=True, ignore_negative: bool=False, ignore_zero: bool=False):",
      "code": "def monotonic_extended(l: list, strict: bool=True, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def monotonic_extended(l: list, strict: bool = False, ignore_negative: bool = False, ignore_zero: bool = False):",
      "mutated_line": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=True, ignore_zero: bool=False):",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=True, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def monotonic_extended(l: list, strict: bool = False, ignore_negative: bool = False, ignore_zero: bool = False):",
      "mutated_line": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=True):",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=True):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) and all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) and all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) and all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) and all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i > 0]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i > 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i < 0]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i < 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i == 0]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i == 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "l = [i for i in l if i != 0]",
      "mutated_line": "l = [i for i in l if i == 0]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i == 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i >= 1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 1]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i >= -1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= -1]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "l = [i for i in l if i >= 0]",
      "mutated_line": "l = [i for i in l if i >= 1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 1]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = [i for i in l if i != 0]",
      "mutated_line": "l = [i for i in l if i != 1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 1]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = [i for i in l if i != 0]",
      "mutated_line": "l = [i for i in l if i != -1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != -1]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = [i for i in l if i != 0]",
      "mutated_line": "l = [i for i in l if i != 1]",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 1]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i >= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i >= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i != j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i != j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i <= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i <= j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i != j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i != j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i > j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i > j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i == j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i == j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i < j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i < j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i == j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i == j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[2:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[2:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[0:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[0:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[0:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[0:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[-1:]))) or all((i > j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[-1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[2:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[2:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[0:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[0:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[0:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[0:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return all(i < j for i, j in zip(l, l[1:])) or all(i > j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[-1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[-1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[2:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[2:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[0:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[0:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[0:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[0:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[-1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[-1:]))) or all((i >= j for (i, j) in zip(l, l[1:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[2:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[2:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[0:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[0:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[0:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[0:])))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return all(i <= j for i, j in zip(l, l[1:])) or all(i >= j for i, j in zip(l, l[1:]))",
      "mutated_line": "return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[-1:])))",
      "code": "def monotonic_extended(l: list, strict: bool=False, ignore_negative: bool=False, ignore_zero: bool=False):\n    \"\"\"\n    This function checks if the numerical array adheres to a monotonically ascending or descending pattern, considering the strictness and ignore_negative parameter. If strict is set to True, consecutive elements must not be the same; otherwise, they can be equal. If ignore_negative is True, negative numbers are not considered. If ignore_zero is True, zeroes in the list will not be considered.\n    \"\"\"\n    if ignore_negative:\n        l = [i for i in l if i >= 0]\n    if ignore_zero:\n        l = [i for i in l if i != 0]\n    if strict:\n        return all((i < j for (i, j) in zip(l, l[1:]))) or all((i > j for (i, j) in zip(l, l[1:])))\n    else:\n        return all((i <= j for (i, j) in zip(l, l[1:]))) or all((i >= j for (i, j) in zip(l, l[-1:])))"
    }
  ]
}