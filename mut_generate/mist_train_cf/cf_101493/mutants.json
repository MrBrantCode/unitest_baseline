{
  "task_id": "cf_101493",
  "entry_point": "dijkstra",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 1\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = -1",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = -1\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "distances[start_node] = 0",
      "mutated_line": "distances[start_node] = 1",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 1\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if current_node == end_node:",
      "mutated_line": "if current_node != end_node:",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node != end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('')"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances[node] = float('inf')",
      "mutated_line": "distances[node] = float('')",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "unvisited = [(0, start_node)]",
      "mutated_line": "unvisited = [(1, start_node)]",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(1, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "unvisited = [(0, start_node)]",
      "mutated_line": "unvisited = [(-1, start_node)]",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(-1, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "unvisited = [(0, start_node)]",
      "mutated_line": "unvisited = [(1, start_node)]",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(1, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if neighbor in visited:",
      "mutated_line": "if neighbor not in visited:",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor not in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_distance = current_distance + distance",
      "mutated_line": "new_distance = current_distance - distance",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance - distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_distance = current_distance + distance",
      "mutated_line": "new_distance = current_distance * distance",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance * distance\n            if new_distance < distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance <= distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance >= distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance != distances[neighbor]:",
      "code": "import heapq\n\ndef dijkstra(graph, start_node, end_node):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start_node] = 0\n    visited = set()\n    unvisited = [(0, start_node)]\n    while unvisited:\n        (current_distance, current_node) = heapq.heappop(unvisited)\n        visited.add(current_node)\n        if current_node == end_node:\n            return distances[end_node]\n        for (neighbor, distance) in graph[current_node].items():\n            if neighbor in visited:\n                continue\n            new_distance = current_distance + distance\n            if new_distance != distances[neighbor]:\n                distances[neighbor] = new_distance\n                heapq.heappush(unvisited, (new_distance, neighbor))\n    return float('inf')"
    }
  ]
}