{
  "task_id": "cf_50079",
  "entry_point": "fibonacci",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n < 1:",
      "code": "def fibonacci(n):\n    if n < 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n > 1:",
      "code": "def fibonacci(n):\n    if n > 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n == 1:",
      "code": "def fibonacci(n):\n    if n == 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 2:",
      "code": "def fibonacci(n):\n    if n <= 2:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 0:",
      "code": "def fibonacci(n):\n    if n <= 0:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 0:",
      "code": "def fibonacci(n):\n    if n <= 0:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= -1:",
      "code": "def fibonacci(n):\n    if n <= -1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n != 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n + 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n + 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n * 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n * 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[0][1]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[0][-1]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[0][1]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[2, 1], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[2, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[0, 1], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[0, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[0, 1], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[0, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[-1, 1], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[-1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 2], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 2], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 0], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 0], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 0], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 0], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, -1], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, -1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [2, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [2, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [0, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [0, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [-1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [-1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [1, 1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 1]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [1, -1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, -1]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "matrix = [[1, 1], [1, 0]]",
      "mutated_line": "matrix = [[1, 1], [1, 1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 1]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 2:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 0:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 0:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == -1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif n in memo:",
      "mutated_line": "elif n not in memo:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n not in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n - 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 2, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n - 0, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 0, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n - 0, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 0, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_matrix = matrix_power(matrix, n - 1, memo)",
      "mutated_line": "result_matrix = matrix_power(matrix, n - -1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - -1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[1][0]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[-1][0]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return result_matrix[0][0]",
      "mutated_line": "return result_matrix[1][0]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[1, 0], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[1, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[-1, 0], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[-1, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[1, 0], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[1, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 1], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 1], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, -1], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, -1], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 1], [0, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 1], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [1, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [-1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [-1, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [1, 0]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [1, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [0, 1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 1]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [0, -1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, -1]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "result = [[0, 0], [0, 0]]",
      "mutated_line": "result = [[0, 0], [0, 1]]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 1]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "result[i][j] += a[i][k] * b[k][j]",
      "mutated_line": "result[i][j] -= a[i][k] * b[k][j]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] -= a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 2 != 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 != 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "result[i][j] += a[i][k] * b[k][j]",
      "mutated_line": "result[i][j] += a[i][k] / b[k][j]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] / b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "result[i][j] += a[i][k] * b[k][j]",
      "mutated_line": "result[i][j] += a[i][k] + b[k][j]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] + b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "result[i][j] += a[i][k] * b[k][j]",
      "mutated_line": "result[i][j] += a[i][k] ** b[k][j]",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] ** b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n * 2 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n * 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n + 2 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n + 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 2 == 1:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 1:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 2 == -1:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == -1:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 2 == 1:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 1:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(len(b[0])):",
      "mutated_line": "for j in range(len(b[1])):",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[1])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(len(b[0])):",
      "mutated_line": "for j in range(len(b[-1])):",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[-1])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(len(b[0])):",
      "mutated_line": "for j in range(len(b[1])):",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[1])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 3 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 3 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 1 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 1 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 0 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 0 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % 1 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 1 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif n%2 == 0:",
      "mutated_line": "elif n % -2 == 0:",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % -2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n / 2] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n / 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n * 2] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n * 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n / 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n / 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n * 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n * 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n + 1] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n + 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n * 1] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n * 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n + 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n + 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n * 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n * 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 3] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 3] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 1] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 1] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 0] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 0] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 1] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 1] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // -2] = matrix_power(matrix, n // 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // -2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n // 3, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 3, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n // 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 1, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n // 0, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 0, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n // 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 1, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "memo[n//2] = matrix_power(matrix, n//2, memo)",
      "mutated_line": "memo[n // 2] = matrix_power(matrix, n // -2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // -2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n / 2], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n / 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n * 2], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n * 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n / 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n / 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n * 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n * 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 2] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 2] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 0] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 0] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 0] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 0] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - -1] = matrix_power(matrix, n - 1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - -1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n - 2, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 2, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n - 0, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 0, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n - 0, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 0, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "memo[n-1] = matrix_power(matrix, n-1, memo)",
      "mutated_line": "memo[n - 1] = matrix_power(matrix, n - -1, memo)",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - -1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n + 1])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n + 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n * 1])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n * 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 3], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 3], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 1], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 1], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 0], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 0], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 1], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 1], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // -2], memo[n // 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // -2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n // 3])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 3])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n // 1])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 1])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n // 0])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 0])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n // 1])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 1])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return multiply_matrices(memo[n//2], memo[n//2])",
      "mutated_line": "return multiply_matrices(memo[n // 2], memo[n // -2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // -2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n - 2])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 2])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n - 0])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 0])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n - 0])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - 0])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return multiply_matrices(matrix, memo[n-1])",
      "mutated_line": "return multiply_matrices(matrix, memo[n - -1])",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    memo = {}\n    matrix = [[1, 1], [1, 0]]\n\n    def multiply_matrices(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n, memo):\n        if n == 1:\n            return matrix\n        elif n in memo:\n            return memo[n]\n        elif n % 2 == 0:\n            memo[n // 2] = matrix_power(matrix, n // 2, memo)\n            return multiply_matrices(memo[n // 2], memo[n // 2])\n        else:\n            memo[n - 1] = matrix_power(matrix, n - 1, memo)\n            return multiply_matrices(matrix, memo[n - -1])\n    result_matrix = matrix_power(matrix, n - 1, memo)\n    return result_matrix[0][0]"
    }
  ]
}