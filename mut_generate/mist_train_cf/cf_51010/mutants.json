{
  "task_id": "cf_51010",
  "entry_point": "isRobotBounded",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (1, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (-1, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (1, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 1, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, -1, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 1, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 1, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, -1, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x, y, direction, path = 0, 0, 0, set()",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 1, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for _ in range(4):",
      "mutated_line": "for _ in range(5):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(5):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for _ in range(4):",
      "mutated_line": "for _ in range(3):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(3):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for _ in range(4):",
      "mutated_line": "for _ in range(0):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(0):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for _ in range(4):",
      "mutated_line": "for _ in range(1):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(1):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for _ in range(4):",
      "mutated_line": "for _ in range(-4):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(-4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) != (0, 0):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) != (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([1, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([1, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([-1, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([-1, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([1, 1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([1, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 2, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 2, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 0, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 0, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 0, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 0, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, -1, 0, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, -1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 1, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 1, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, -1, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, -1, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 1, -1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 1, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, +1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, +1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [2, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [2, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [0, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [0, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [0, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [0, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [-1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [-1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 1, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 1, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, -1, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, -1, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 1, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 1, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, +1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, +1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 1])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 1])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, -1])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, -1])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 1])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 1])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i == 'R':",
      "mutated_line": "if i != 'R':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i != 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return False\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -2], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -2], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -0], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -0], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -0], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -0], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, --1], [1, 0, -1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, --1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -2, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -2, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -0, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -0, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, -0, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -0, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]",
      "mutated_line": "(dx, dy) = ([0, 1, 0, -1], [1, 0, --1, 0])",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, --1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i == 'R':",
      "mutated_line": "if i == '':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == '':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) * 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) * 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = direction + 1 + 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = direction + 1 + 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif i == 'L':",
      "mutated_line": "elif i != 'L':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i != 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (1, 0):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (1, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (-1, 0):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (-1, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (1, 0):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (1, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (0, 1):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 1):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (0, -1):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, -1):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (x, y) == (0, 0):",
      "mutated_line": "if (x, y) == (0, 1):",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 1):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction - 1) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction - 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = direction * 1 % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = direction * 1 % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) % 5",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 5\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) % 3",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 3\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) % 0",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 0\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) % 1",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 1\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 1) % -4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % -4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif i == 'L':",
      "mutated_line": "elif i == '':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == '':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) * 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) * 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = direction - 1 + 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = direction - 1 + 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif i == 'O':",
      "mutated_line": "elif i != 'O':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i != 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 2) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 2) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 0) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 0) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + 0) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 0) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "direction = (direction + 1) % 4",
      "mutated_line": "direction = (direction + -1) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + -1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction + 1) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction + 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = direction * 1 % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = direction * 1 % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) % 5",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 5\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) % 3",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 3\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) % 0",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 0\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) % 1",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 1\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 1) % -4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % -4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif i == 'O':",
      "mutated_line": "elif i == '':",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == '':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif (x + dx[direction], y + dy[direction]) not in path:",
      "mutated_line": "elif (x + dx[direction], y + dy[direction]) in path:",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "x += dx[direction]",
      "mutated_line": "x -= dx[direction]",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x -= dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "y += dy[direction]",
      "mutated_line": "y -= dy[direction]",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y -= dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 2) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 2) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 0) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 0) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - 0) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 0) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = (direction - 1) % 4",
      "mutated_line": "direction = (direction - -1) % 4",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - -1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif (x + dx[direction], y + dy[direction]) not in path:",
      "mutated_line": "elif (x - dx[direction], y + dy[direction]) not in path:",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x - dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif (x + dx[direction], y + dy[direction]) not in path:",
      "mutated_line": "elif (x * dx[direction], y + dy[direction]) not in path:",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x * dx[direction], y + dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif (x + dx[direction], y + dy[direction]) not in path:",
      "mutated_line": "elif (x + dx[direction], y - dy[direction]) not in path:",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y - dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif (x + dx[direction], y + dy[direction]) not in path:",
      "mutated_line": "elif (x + dx[direction], y * dy[direction]) not in path:",
      "code": "def isRobotBounded(instructions: str) -> bool:\n    (x, y, direction, path) = (0, 0, 0, set())\n    (dx, dy) = ([0, 1, 0, -1], [1, 0, -1, 0])\n    for _ in range(4):\n        for i in instructions:\n            if i == 'R':\n                direction = (direction + 1) % 4\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'O':\n                path.add((x, y))\n            elif (x + dx[direction], y * dy[direction]) not in path:\n                x += dx[direction]\n                y += dy[direction]\n        if (x, y) == (0, 0):\n            return True\n    return False"
    }
  ]
}