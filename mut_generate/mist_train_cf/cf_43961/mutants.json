{
  "task_id": "cf_43961",
  "entry_point": "set_intersection",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if bst.in_bst(bst.root, elem) and elem not in intersection:",
      "mutated_line": "if bst.in_bst(bst.root, elem) or elem not in intersection:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) or elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if self.root is None:",
      "mutated_line": "if self.root is not None:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is not None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if value < current_node.value:",
      "mutated_line": "if value <= current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value <= current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if value < current_node.value:",
      "mutated_line": "if value >= current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value >= current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if value < current_node.value:",
      "mutated_line": "if value != current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value != current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if current_node is None:",
      "mutated_line": "if current_node is not None:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is not None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if current_node.value == value:",
      "mutated_line": "if current_node.value != value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value != value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if bst.in_bst(bst.root, elem) and elem not in intersection:",
      "mutated_line": "if bst.in_bst(bst.root, elem) and elem in intersection:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif value > current_node.value:",
      "mutated_line": "elif value >= current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value >= current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif value > current_node.value:",
      "mutated_line": "elif value <= current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value <= current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif value > current_node.value:",
      "mutated_line": "elif value != current_node.value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value != current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return True\n            if current_node.value == value:\n                return True\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return False\n            elif current_node.value > value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif current_node.value > value:",
      "mutated_line": "elif current_node.value >= value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value >= value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif current_node.value > value:",
      "mutated_line": "elif current_node.value <= value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value <= value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif current_node.value > value:",
      "mutated_line": "elif current_node.value != value:",
      "code": "def set_intersection(s1, s2):\n\n    class BSTNode:\n\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    class BinarySearchTree:\n\n        def __init__(self):\n            self.root = None\n\n        def insert(self, value):\n            if self.root is None:\n                self.root = BSTNode(value)\n            else:\n                self.insert_node(self.root, value)\n\n        def insert_node(self, current_node, value):\n            if value < current_node.value:\n                if current_node.left:\n                    self.insert_node(current_node.left, value)\n                else:\n                    current_node.left = BSTNode(value)\n            elif value > current_node.value:\n                if current_node.right:\n                    self.insert_node(current_node.right, value)\n                else:\n                    current_node.right = BSTNode(value)\n\n        def in_bst(self, current_node, value):\n            if current_node is None:\n                return False\n            if current_node.value == value:\n                return True\n            elif current_node.value != value:\n                return self.in_bst(current_node.left, value)\n            else:\n                return self.in_bst(current_node.right, value)\n    bst = BinarySearchTree()\n    for elem in s1:\n        bst.insert(elem)\n    intersection = []\n    for elem in s2:\n        if bst.in_bst(bst.root, elem) and elem not in intersection:\n            intersection.append(elem)\n    intersection.sort()\n    return intersection"
    }
  ]
}