{
  "task_id": "cf_30024",
  "entry_point": "single_generator",
  "mutant_count": 8,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if state == goal:",
      "mutated_line": "if state != goal:",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state != goal:\n            yield (path + [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if state not in visited:",
      "mutated_line": "if state in visited:",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path + [state])\n            return\n        if state in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "yield path + [state]  # Yield the path to the goal state",
      "mutated_line": "yield (path - [state])",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path - [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "yield path + [state]  # Yield the path to the goal state",
      "mutated_line": "yield (path * [state])",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path * [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if new_state is not None and successors(new_state):",
      "mutated_line": "if new_state is not None or successors(new_state):",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path + [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None or successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if new_state is not None and successors(new_state):",
      "mutated_line": "if new_state is None and successors(new_state):",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path + [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is None and successors(new_state):\n                    stack.append((new_state, path + [state]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack.append((new_state, path + [state]))  # Add the new state and its path to the stack",
      "mutated_line": "stack.append((new_state, path - [state]))",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path + [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path - [state]))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack.append((new_state, path + [state]))  # Add the new state and its path to the stack",
      "mutated_line": "stack.append((new_state, path * [state]))",
      "code": "def single_generator(initial, goal, operators, successors):\n    visited = set()\n    stack = [(initial, [])]\n    while stack:\n        (state, path) = stack.pop()\n        if state == goal:\n            yield (path + [state])\n            return\n        if state not in visited:\n            visited.add(state)\n            for operator in operators:\n                new_state = operator(state)\n                if new_state is not None and successors(new_state):\n                    stack.append((new_state, path * [state]))"
    }
  ]
}