{
  "task_id": "cf_98593",
  "entry_point": "entrance",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 1\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = -1\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 1\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if current_vertex == end:",
      "mutated_line": "if current_vertex != end:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex != end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {vertex: float('inf') for vertex in graph}",
      "mutated_line": "distances = {vertex: float('') for vertex in graph}",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vertices_queue = [(0, start)]",
      "mutated_line": "vertices_queue = [(1, start)]",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(1, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vertices_queue = [(0, start)]",
      "mutated_line": "vertices_queue = [(-1, start)]",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(-1, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vertices_queue = [(0, start)]",
      "mutated_line": "vertices_queue = [(1, start)]",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(1, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while current_vertex is not None:",
      "mutated_line": "while current_vertex is None:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:",
      "mutated_line": "if (current_vertex, neighbor) in streets and (neighbor, current_vertex) in streets:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets and (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:",
      "mutated_line": "if (current_vertex, neighbor) not in streets or (neighbor, current_vertex) in streets:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) not in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:",
      "mutated_line": "if (current_vertex, neighbor) in streets or (neighbor, current_vertex) not in streets:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) not in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_distance = current_distance + distance",
      "mutated_line": "new_distance = current_distance - distance",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance - distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_distance = current_distance + distance",
      "mutated_line": "new_distance = current_distance * distance",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance * distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance <= distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance >= distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_distance < distances[neighbor]:",
      "mutated_line": "if new_distance != distances[neighbor]:",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance != distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ''.join(path[::-1])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ''.join(path[::-1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ' -> '.join(path[::+1])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::+1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ' -> '.join(path[::-2])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-2])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ' -> '.join(path[::-0])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-0])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ' -> '.join(path[::-0])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::-0])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return ' -> '.join(path[::-1])",
      "mutated_line": "return ' -> '.join(path[::--1])",
      "code": "import heapq\n\ndef entrance(graph, start, end, streets):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    previous_vertices = {vertex: None for vertex in graph}\n    vertices_queue = [(0, start)]\n    while vertices_queue:\n        (current_distance, current_vertex) = heapq.heappop(vertices_queue)\n        if current_vertex == end:\n            path = []\n            while current_vertex is not None:\n                path.append(current_vertex)\n                current_vertex = previous_vertices[current_vertex]\n            return ' -> '.join(path[::--1])\n        for (neighbor, distance) in graph[current_vertex]:\n            if (current_vertex, neighbor) in streets or (neighbor, current_vertex) in streets:\n                new_distance = current_distance + distance\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous_vertices[neighbor] = current_vertex\n                    heapq.heappush(vertices_queue, (new_distance, neighbor))\n    return None"
    }
  ]
}