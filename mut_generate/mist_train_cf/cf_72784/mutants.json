{
  "task_id": "cf_72784",
  "entry_point": "minCost",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cost = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "cost = [[float('inf')] / n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] / n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cost = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "cost = [[float('inf')] + n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] + n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cost = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "cost = [[float('inf')] ** n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] ** n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 or y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 or y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(-1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(-1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(1, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 2, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 2, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 0, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 0, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 0, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 0, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, -1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, -1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 2), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 2), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 0), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 0), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 0), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 0), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, -1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, -1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (1, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (1, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (-1, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (-1, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (1, -1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (1, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, +1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, +1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 3), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 3), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 1), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 1), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 0), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 0), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 1), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 1), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, -2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, -2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (2, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (2, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (0, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (0, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (0, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (0, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (-1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (-1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 1, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 1, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, -1, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, -1, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 1, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 1, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 4), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 4), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 2), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 2), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 0), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 0), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 1), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 1), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, -3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, -3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (+1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (+1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 1, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 1, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, -1, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, -1, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 1, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 1, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 5)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 5)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 3)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 3)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 0)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 0)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 1)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 1)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, -4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, -4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x != m - 1 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x != m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y != n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y != n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or cost[nx][ny] > nc:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m or 0 <= ny < n or cost[nx][ny] > nc:\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[1]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[-1]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[1]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -2, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -2, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -0, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -0, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -0, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -0, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, --1, 2), (1, 0, 3), (-1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, --1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-2, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-2, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-0, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-0, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-0, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-0, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves = [(0,1,1),(0,-1,2),(1,0,3),(-1,0,4)]",
      "mutated_line": "moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (--1, 0, 4)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (--1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(1, 0, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(1, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(-1, 0, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(-1, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(1, 0, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(1, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, 1, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 1, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, -1, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, -1, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, 1, 0)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 1, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, 0, 1)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 1)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, 0, -1)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, -1)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cells = deque([(0,0,0)])",
      "mutated_line": "cells = deque([(0, 0, 1)])",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 1)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m + 1 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m + 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m * 1 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m * 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n + 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n + 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n * 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n * 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x - dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x * dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y - dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y * dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m or 0 <= ny < n or grid[x][y] == v else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m or 0 <= ny < n or grid[x][y] == v else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c - 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c - 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c * 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c * 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 < nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 > nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 == nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 < ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 > ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 == ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] >= nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] >= nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] <= nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] <= nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] != nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] != nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (grid[x][y] == v):",
      "mutated_line": "if grid[x][y] != v:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] != v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cost = [[float('inf')]*n for _ in range(m)]",
      "mutated_line": "cost = [[float('')] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 2 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 2 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 0 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 0 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 0 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 0 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - -1 and y == n - 1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - -1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n - 2:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 2:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n - 0:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 0:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n - 0:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 0:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if x == m - 1 and y == n - 1:",
      "mutated_line": "if x == m - 1 and y == n - -1:",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - -1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 < nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 < nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 > nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 > nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 == nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 == nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 < ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 < ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 > ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 > ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 == ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 == ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] != v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] != v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 2",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 2\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 0",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 0\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 0",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 0\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + -1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + -1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if -1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 1 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 1 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and -1 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and cost[nx][ny] > nc:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (cost[nx][ny] > nc):",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 1 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if -1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if -1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 1 <= nx < m and 0 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 1 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 1 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and -1 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and -1 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "nc = c if 0 <= nx < m and 0 <= ny < n and grid[x][y] == v else c+1",
      "mutated_line": "nc = c if 0 <= nx < m and 1 <= ny < n and (grid[x][y] == v) else c + 1",
      "code": "from collections import deque\n\ndef minCost(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    moves = [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]\n    cost = [[float('inf')] * n for _ in range(m)]\n    cells = deque([(0, 0, 0)])\n    while cells:\n        (x, y, c) = cells.popleft()\n        if x == m - 1 and y == n - 1:\n            return c\n        for (dx, dy, v) in moves:\n            (nx, ny) = (x + dx, y + dy)\n            nc = c if 0 <= nx < m and 1 <= ny < n and (grid[x][y] == v) else c + 1\n            if 0 <= nx < m and 0 <= ny < n and (cost[nx][ny] > nc):\n                cost[nx][ny] = nc\n                if grid[x][y] == v:\n                    cells.appendleft((nx, ny, nc))\n                else:\n                    cells.append((nx, ny, nc))\n    return -1"
    }
  ]
}