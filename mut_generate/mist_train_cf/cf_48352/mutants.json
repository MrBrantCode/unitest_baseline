{
  "task_id": "cf_48352",
  "entry_point": "beneficial_partitions",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "beneficial_divisions = 0",
      "mutated_line": "beneficial_divisions = 1",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 1\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "beneficial_divisions = 0",
      "mutated_line": "beneficial_divisions = -1",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = -1\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "beneficial_divisions = 0",
      "mutated_line": "beneficial_divisions = 1",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 1\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] / n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] + n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] ** n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] / n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] / n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] + n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] + n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] ** n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] ** n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not s: return 0",
      "mutated_line": "if not s:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 1\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not s: return 0",
      "mutated_line": "if not s:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return -1\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if not s: return 0",
      "mutated_line": "if not s:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 1\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n + 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n * 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] != suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] != suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "beneficial_divisions += 1",
      "mutated_line": "beneficial_divisions -= 1",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions -= 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [1] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [-1] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_ways = [0]*n",
      "mutated_line": "suffix_ways = [0] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [1] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [1] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [1] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [-1] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [-1] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "suffix_ways = [0]*n",
      "mutated_line": "suffix_ways = [1] * n",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [1] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 1 <= n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 <= n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 1 >= n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 >= n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 1 != n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 != n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 2):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 0):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 0):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(n-1):",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - -1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "beneficial_divisions += 1",
      "mutated_line": "beneficial_divisions += 2",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 2\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "beneficial_divisions += 1",
      "mutated_line": "beneficial_divisions += 0",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 0\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "beneficial_divisions += 1",
      "mutated_line": "beneficial_divisions += 0",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 0\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "beneficial_divisions += 1",
      "mutated_line": "beneficial_divisions += -1",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += -1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i - 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i - 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i * 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i * 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i - 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i - 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i * 1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i * 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 2 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 2 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 0 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 0 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + 0 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 0 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 1].copy() if i + -1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + -1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 2]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 2]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 0]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 0]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + 0]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 0]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if prefix_ways[i] == suffix_ways[i+1]:",
      "mutated_line": "if prefix_ways[i] == suffix_ways[i + -1]:",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + -1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i - 1].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i - 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i * 1].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i * 1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 2].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 2].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 0].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 0].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + 0].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + 0].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "suffix_set[i] = suffix_set[i+1].copy() if i+1 < n else set()",
      "mutated_line": "suffix_set[i] = suffix_set[i + -1].copy() if i + 1 < n else set()",
      "code": "def beneficial_partitions(s):\n    if not s:\n        return 0\n    n = len(s)\n    beneficial_divisions = 0\n    prefix_ways = [0] * n\n    suffix_ways = [0] * n\n    prefix_set = set()\n    suffix_set = [set() for _ in range(n)]\n    for i in range(n):\n        prefix_set.add(s[i])\n        prefix_ways[i] = len(prefix_set)\n    for i in reversed(range(n)):\n        suffix_set[i] = suffix_set[i + -1].copy() if i + 1 < n else set()\n        suffix_set[i].add(s[i])\n        suffix_ways[i] = len(suffix_set[i])\n    for i in range(n - 1):\n        if prefix_ways[i] == suffix_ways[i + 1]:\n            beneficial_divisions += 1\n    return beneficial_divisions"
    }
  ]
}