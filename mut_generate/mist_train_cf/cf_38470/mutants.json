{
  "task_id": "cf_38470",
  "entry_point": "F",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 * (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 * (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 // (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 // (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 2 / (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 2 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 0 / (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 0 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 0 / (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 0 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return -1 / (1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return -1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 - np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 - np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 * np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 * np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "num_steps = int(duration / dt)",
      "mutated_line": "num_steps = int(duration * dt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration * dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "num_steps = int(duration / dt)",
      "mutated_line": "num_steps = int(duration // dt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration // dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = np.arange(0, duration, dt)",
      "mutated_line": "time = np.arange(1, duration, dt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(1, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = np.arange(0, duration, dt)",
      "mutated_line": "time = np.arange(-1, duration, dt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(-1, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = np.arange(0, duration, dt)",
      "mutated_line": "time = np.arange(1, duration, dt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(1, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for t in range(1, num_steps):",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(2, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for t in range(1, num_steps):",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(0, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for t in range(1, num_steps):",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(0, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for t in range(1, num_steps):",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(-1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) * tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) * tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) // tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) // tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) * tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) * tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) // tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) // tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 1] - dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] - dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 1] * (dt * dEdt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] * (dt * dEdt)\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 1] - dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] - dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 1] * (dt * dIdt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] * (dt * dIdt)\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (2 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (2 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (0 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (0 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (0 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (0 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (-1 + np.exp(-a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (-1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "wEE, wEI = pars['wEE'], pars['wEI']",
      "mutated_line": "(wEE, wEI) = (pars[''], pars['wEI'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars[''], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "wEE, wEI = pars['wEE'], pars['wEI']",
      "mutated_line": "(wEE, wEI) = (pars['wEE'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars[''])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wIE, wII = pars['wIE'], pars['wII']",
      "mutated_line": "(wIE, wII) = (pars[''], pars['wII'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars[''], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "wIE, wII = pars['wIE'], pars['wII']",
      "mutated_line": "(wIE, wII) = (pars['wIE'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars[''])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I_ext_E, I_ext_I = pars['I_ext_E'], pars['I_ext_I']",
      "mutated_line": "(I_ext_E, I_ext_I) = (pars[''], pars['I_ext_I'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars[''], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I_ext_E, I_ext_I = pars['I_ext_E'], pars['I_ext_I']",
      "mutated_line": "(I_ext_E, I_ext_I) = (pars['I_ext_E'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars[''])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a_E, a_I = pars['a_E'], pars['a_I']",
      "mutated_line": "(a_E, a_I) = (pars[''], pars['a_I'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars[''], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a_E, a_I = pars['a_E'], pars['a_I']",
      "mutated_line": "(a_E, a_I) = (pars['a_E'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars[''])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "theta_E, theta_I = pars['theta_E'], pars['theta_I']",
      "mutated_line": "(theta_E, theta_I) = (pars[''], pars['theta_I'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars[''], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "theta_E, theta_I = pars['theta_E'], pars['theta_I']",
      "mutated_line": "(theta_E, theta_I) = (pars['theta_E'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars[''])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tau_E, tau_I = pars['tau_E'], pars['tau_I']",
      "mutated_line": "(tau_E, tau_I) = (pars[''], pars['tau_I'])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars[''], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tau_E, tau_I = pars['tau_E'], pars['tau_I']",
      "mutated_line": "(tau_E, tau_I) = (pars['tau_E'], pars[''])",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars[''])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] - F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] - F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = -E[t - 1] * F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = -E[t - 1] * F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] - F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] - F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = -I[t - 1] * F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = -I[t - 1] * F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 1] + dt / dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt / dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 1] + (dt + dEdt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + (dt + dEdt)\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 1] + dt ** dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt ** dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 1] + dt / dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt / dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 1] + (dt + dIdt)",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + (dt + dIdt)\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 1] + dt ** dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt ** dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp(-a / (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a / (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp(-a + (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a + (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp((-a) ** (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp((-a) ** (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (+E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (+E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (+I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (+I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t + 1] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t + 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t * 1] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t * 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t + 1] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t + 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t * 1] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t * 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp(+a * (x - theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(+a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp(-a * (x + theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x + theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return 1 / (1 + np.exp(-a * (x - theta)))",
      "mutated_line": "return 1 / (1 + np.exp(-a * (x * theta)))",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x * theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] - I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] - I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F((wEE * E[t - 1] - wEI * I[t - 1]) * I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F((wEE * E[t - 1] - wEI * I[t - 1]) * I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] - I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] - I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F((wIE * E[t - 1] - wII * I[t - 1]) * I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F((wIE * E[t - 1] - wII * I[t - 1]) * I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 2] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 2] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 0] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 0] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - 0] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 0] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E[t] = E[t-1] + dt * dEdt",
      "mutated_line": "E[t] = E[t - -1] + dt * dEdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - -1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 2] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 2] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 0] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 0] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - 0] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 0] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "I[t] = I[t-1] + dt * dIdt",
      "mutated_line": "I[t] = I[t - -1] + dt * dIdt",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - -1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t + 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t + 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t * 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t * 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] + wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] + wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] * (wEI * I[t - 1]) + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] * (wEI * I[t - 1]) + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t + 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t + 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t * 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t * 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] + wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] + wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] * (wII * I[t - 1]) + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] * (wII * I[t - 1]) + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 2] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 2] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 0] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 0] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 0] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 0] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - -1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - -1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE / E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE / E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE + E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE + E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE ** E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE ** E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI / I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI / I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - (wEI + I[t - 1]) + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - (wEI + I[t - 1]) + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI ** I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI ** I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 2] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 2] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 0] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 0] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 0] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 0] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - -1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - -1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE / E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE / E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE + E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE + E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE ** E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE ** E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII / I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII / I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - (wII + I[t - 1]) + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - (wII + I[t - 1]) + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII ** I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII ** I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t + 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t + 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t * 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t * 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t + 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t + 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t * 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t * 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t + 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t + 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t * 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t * 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t + 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t + 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t * 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t * 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 2] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 2] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 0] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 0] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 0] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 0] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - -1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - -1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 2] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 2] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 0] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 0] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 0] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 0] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dEdt = (-E[t-1] + F(wEE*E[t-1] - wEI*I[t-1] + I_ext_E, a_E, theta_E)) / tau_E",
      "mutated_line": "dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - -1] + I_ext_E, a_E, theta_E)) / tau_E",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - -1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 2] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 2] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 0] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 0] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 0] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 0] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - -1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - -1] - wII * I[t - 1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 2] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 2] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 0] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 0] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 0] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - 0] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dIdt = (-I[t-1] + F(wIE*E[t-1] - wII*I[t-1] + I_ext_I, a_I, theta_I)) / tau_I",
      "mutated_line": "dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - -1] + I_ext_I, a_I, theta_I)) / tau_I",
      "code": "import numpy as np\n\ndef F(x, a, theta):\n    return 1 / (1 + np.exp(-a * (x - theta)))\n\ndef simulate_network(pars, duration, dt):\n    (wEE, wEI) = (pars['wEE'], pars['wEI'])\n    (wIE, wII) = (pars['wIE'], pars['wII'])\n    (I_ext_E, I_ext_I) = (pars['I_ext_E'], pars['I_ext_I'])\n    (a_E, a_I) = (pars['a_E'], pars['a_I'])\n    (theta_E, theta_I) = (pars['theta_E'], pars['theta_I'])\n    (tau_E, tau_I) = (pars['tau_E'], pars['tau_I'])\n    num_steps = int(duration / dt)\n    time = np.arange(0, duration, dt)\n    E = np.zeros(num_steps)\n    I = np.zeros(num_steps)\n    for t in range(1, num_steps):\n        dEdt = (-E[t - 1] + F(wEE * E[t - 1] - wEI * I[t - 1] + I_ext_E, a_E, theta_E)) / tau_E\n        dIdt = (-I[t - 1] + F(wIE * E[t - 1] - wII * I[t - -1] + I_ext_I, a_I, theta_I)) / tau_I\n        E[t] = E[t - 1] + dt * dEdt\n        I[t] = I[t - 1] + dt * dIdt\n    return (time, E, I)"
    }
  ]
}