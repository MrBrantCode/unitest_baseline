{
  "task_id": "cf_62930",
  "entry_point": "split_words",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "'''",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def split_words(txt):\n    \"\"\"\"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if (\" \" in txt) or (\",\" in txt):",
      "mutated_line": "if ' ' in txt and ',' in txt:",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt and ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (\" \" in txt) or (\",\" in txt):",
      "mutated_line": "if ' ' not in txt or ',' in txt:",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' not in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (\" \" in txt) or (\",\" in txt):",
      "mutated_line": "if ' ' in txt or ',' not in txt:",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' not in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (\" \" in txt) or (\",\" in txt):",
      "mutated_line": "if '' in txt or ',' in txt:",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if '' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (\" \" in txt) or (\",\" in txt):",
      "mutated_line": "if ' ' in txt or '' in txt:",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or '' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for word in txt.replace(',', ' ').split():",
      "mutated_line": "for word in txt.replace('', ' ').split():",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace('', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for word in txt.replace(',', ' ').split():",
      "mutated_line": "for word in txt.replace(',', '').split():",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', '').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 != 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 != 1])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) * 2 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) * 2 == 1])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) + 2 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) + 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 2])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 2])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == -1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == -1])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 2 != 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 != 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 3 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 3 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 1 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 1 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 0 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 0 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 1 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 1 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return len([ch for i, ch in enumerate(txt) if ord(ch) % 2 == 1])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if ord(ch) % -2 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % -2 == 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i * 2 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i * 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i + 2 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i + 2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 2 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 1])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 2 == -1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == -1])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 2 == 1])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 2 == 1])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 3 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 3 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 1 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 1 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 0 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 0 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % 1 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % 1 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return len([ch for i, ch in enumerate(txt) if i % 2 == 0])",
      "mutated_line": "return len([ch for (i, ch) in enumerate(txt) if i % -2 == 0])",
      "code": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words separated \n    by either a space or comma. If neither exist, return a count \n    of the lowercase letters with odd indexes (ord('a') = 0, \n    ord('b') = 1, ... ord('z') = 25).\n\n    Furthermore, add functionality where it would check if these \n    words consist of only alphabets. If not, consider that as \n    a case where space or comma doesn't exist. \n\n    Reconstruct the string to have all lowercase letters and \n    return the count of alternating characters starting from \n    the first character.\n\n    \"\"\"\n    txt = txt.lower()\n    if ' ' in txt or ',' in txt:\n        words = []\n        for word in txt.replace(',', ' ').split():\n            if word.isalpha():\n                words.append(word)\n            else:\n                return len([ch for (i, ch) in enumerate(txt) if i % -2 == 0])\n        return words\n    else:\n        return len([ch for (i, ch) in enumerate(txt) if ord(ch) % 2 == 1])"
    }
  ]
}