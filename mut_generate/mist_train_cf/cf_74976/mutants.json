{
  "task_id": "cf_74976",
  "entry_point": "is_valid",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"This function checks if a position is within the chess board\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 and y < 0 and (x >= 8) and (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 and y < 0 and (x >= 8) and (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return False\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "\"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x <= 0 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x <= 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x >= 0 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x >= 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x != 0 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x != 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y <= 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y <= 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y >= 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y >= 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y != 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y != 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x > 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x > 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x < 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x < 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x == 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x == 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y > 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y > 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y < 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y < 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y == 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y == 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return True\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if current_pos == end:",
      "mutated_line": "if current_pos != end:",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos != end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 1 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 1 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < -1 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < -1 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 1 or y < 0 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 1 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 1 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 1 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < -1 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < -1 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 1 or x >= 8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 1 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 9 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 9 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 7 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 7 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 0 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 0 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 1 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 1 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= -8 or (y >= 8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= -8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y >= 9):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 9):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y >= 7):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 7):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y >= 0):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 0):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y >= 1):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 1):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if x < 0 or y < 0 or x >= 8 or y >= 8:",
      "mutated_line": "if x < 0 or y < 0 or x >= 8 or (y >= -8):",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= -8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(3, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(3, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(1, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(1, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(0, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(0, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(1, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(1, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(-2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(-2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 2), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 2), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 0), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 0), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 0), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 0), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, -1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, -1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (2, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (2, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (0, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (0, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (0, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (0, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 3), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 3), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 1), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 1), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 0), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 0), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 1), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 1), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, -2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, -2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (3, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (3, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (1, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (1, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (0, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (0, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (1, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (1, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (-2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (-2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, +1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, +1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (2, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (2, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (0, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (0, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (0, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (0, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (-1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (-1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, +2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, +2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (+2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (+2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 2), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 2), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 0), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 0), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 0), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 0), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, -1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, -1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (+1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (+1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 3), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 3), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 1), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 1), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 0), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 0), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 1), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 1), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (+2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (+2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, +1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, +1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (+1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (+1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, +2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, +2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if is_valid(next_pos) and next_pos not in visited:  # if the next position is valid and not visited",
      "mutated_line": "if is_valid(next_pos) or next_pos not in visited:",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) or next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -2), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -2), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -0), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -0), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -0), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -0), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, --1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, --1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -3), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -3), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -1), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -1), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -0), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -0), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -1), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -1), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, --2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, --2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-3, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-3, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-1, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-1, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-0, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-0, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-1, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-1, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (--2, 1), (-1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (--2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-2, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-2, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-0, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-0, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-0, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-0, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (--1, 2), (-2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (--1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-3, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-3, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-1, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-1, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-0, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-0, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-1, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-1, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (--2, -1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (--2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -2), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -2), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -0), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -0), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -0), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -0), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, --1), (-1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, --1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-2, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-2, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-0, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-0, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-0, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-0, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (--1, -2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (--1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -3)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -3)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -1)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -0)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -0)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -1)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -1)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "directions = [(2,1),(1,2),(2,-1),(1,-2),(-2,1),(-1,2),(-2,-1),(-1,-2)]  # all possible moves of the knight",
      "mutated_line": "directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, --2)]",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, --2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(start, 0)])  # use deque to implement a queue",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 1)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(start, 0)])  # use deque to implement a queue",
      "mutated_line": "queue = deque([(start, -1)])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, -1)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([(start, 0)])  # use deque to implement a queue",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 1)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] - direction[0], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] - direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] * direction[0], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] * direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] - direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] - direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] * direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] * direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if is_valid(next_pos) and next_pos not in visited:  # if the next position is valid and not visited",
      "mutated_line": "if is_valid(next_pos) and next_pos in visited:",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[1] + direction[0], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[1] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[-1] + direction[0], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[-1] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[1] + direction[0], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[1] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[1], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[1], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[-1], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[-1], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[1], current_pos[1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[1], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[2] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[2] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[0] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[0] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[0] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[0] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[-1] + direction[1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[-1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[2])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[2])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[0])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[0])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[0])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[0])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_x, next_y = current_pos[0] + direction[0], current_pos[1] + direction[1]  # calculate next possible positions",
      "mutated_line": "(next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[-1])",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[-1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves - 1))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves - 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves * 1))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves * 1))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves + 2))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 2))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves + 0))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 0))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves + 0))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + 0))\n                visited.add(next_pos)\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue.append((next_pos, current_moves + 1))  # append it to the right of the queue, with current moves plus 1",
      "mutated_line": "queue.append((next_pos, current_moves + -1))",
      "code": "from collections import deque\n\ndef is_valid(pos):\n    \"\"\"This function checks if a position is within the chess board\"\"\"\n    (x, y) = pos\n    if x < 0 or y < 0 or x >= 8 or (y >= 8):\n        return False\n    return True\n\ndef bfs(start, end):\n    \"\"\"This function uses BFS to find the minimum moves a knight can make from the starting position to the ending position\"\"\"\n    directions = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        (current_pos, current_moves) = queue.popleft()\n        if current_pos == end:\n            return current_moves\n        for direction in directions:\n            (next_x, next_y) = (current_pos[0] + direction[0], current_pos[1] + direction[1])\n            next_pos = (next_x, next_y)\n            if is_valid(next_pos) and next_pos not in visited:\n                queue.append((next_pos, current_moves + -1))\n                visited.add(next_pos)\n    return None"
    }
  ]
}