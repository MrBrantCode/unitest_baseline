{
  "task_id": "cf_55495",
  "entry_point": "complex_median",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 and num < -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 and num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < len(min_heap):",
      "mutated_line": "if len(max_heap) <= len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) <= len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < len(min_heap):",
      "mutated_line": "if len(max_heap) >= len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) >= len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < len(min_heap):",
      "mutated_line": "if len(max_heap) != len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) != len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > len(min_heap):",
      "mutated_line": "if len(max_heap) >= len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) >= len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > len(min_heap):",
      "mutated_line": "if len(max_heap) <= len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) <= len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(max_heap) > len(min_heap):",
      "mutated_line": "if len(max_heap) != len(min_heap):",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) != len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) != 0 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) != 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num <= -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num <= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num >= -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num >= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num != -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num != -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) >= len(min_heap) + 1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) >= len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) <= len(min_heap) + 1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) <= len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) != len(min_heap) + 1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) != len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) * 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) * 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) // 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) // 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == -1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == -1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < +max_heap[0]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < +max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "heapq.heappush(max_heap, -num)",
      "mutated_line": "heapq.heappush(max_heap, +num)",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, +num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "heapq.heappush(max_heap, -number)",
      "mutated_line": "heapq.heappush(max_heap, +number)",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, +number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) - 1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) - 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) * 1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) * 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "number = -heapq.heappop(max_heap)",
      "mutated_line": "number = +heapq.heappop(max_heap)",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = +heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return float(-max_heap[0])",
      "mutated_line": "return float(+max_heap[0])",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(+max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] + max_heap[0]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] + max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return min_heap[0] * max_heap[0] / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return min_heap[0] * max_heap[0] / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) / 3.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 3.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) / 1.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 1.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) / 0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) / 1",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 1\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[0]) / -2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / -2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 2:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 2:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 0:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 0:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "elif len(max_heap) > len(min_heap) + -1:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + -1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[1]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[-1]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[-1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[1]:",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return float(-max_heap[0])",
      "mutated_line": "return float(-max_heap[1])",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[1])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return float(-max_heap[0])",
      "mutated_line": "return float(-max_heap[-1])",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[-1])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return float(-max_heap[0])",
      "mutated_line": "return float(-max_heap[1])",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[1])\n        else:\n            return (min_heap[0] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[1] - max_heap[0]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[1] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[-1] - max_heap[0]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[-1] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[1] - max_heap[0]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[1] - max_heap[0]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[1]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[1]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[-1]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[-1]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return (min_heap[0] - max_heap[0]) / 2.0",
      "mutated_line": "return (min_heap[0] - max_heap[1]) / 2.0",
      "code": "import heapq\n\ndef complex_median(lst):\n    max_heap = []\n    min_heap = []\n\n    def add_number(num):\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n\n    def rebalance():\n        if len(max_heap) < len(min_heap):\n            number = heapq.heappop(min_heap)\n            heapq.heappush(max_heap, -number)\n        elif len(max_heap) > len(min_heap) + 1:\n            number = -heapq.heappop(max_heap)\n            heapq.heappush(min_heap, number)\n\n    def get_median():\n        if len(max_heap) > len(min_heap):\n            return float(-max_heap[0])\n        else:\n            return (min_heap[0] - max_heap[1]) / 2.0\n    for num in lst:\n        add_number(num)\n        rebalance()\n    return get_median()"
    }
  ]
}