{
  "task_id": "cf_74342",
  "entry_point": "FFT_poly",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a -= [0] * (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a -= [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b -= [0] * (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b -= [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n != 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n / 2",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n / 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n * 2",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n * 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "w_sq = w * w",
      "mutated_line": "w_sq = w / w",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w / w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "w_sq = w * w",
      "mutated_line": "w_sq = w + w",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w + w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "w_sq = w * w",
      "mutated_line": "w_sq = w ** w",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w ** w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [0] / n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] / n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [0] + n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] + n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [0] ** n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] ** n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w_i = 1",
      "mutated_line": "w_i = 2",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 2\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w_i = 1",
      "mutated_line": "w_i = 0",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 0\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w_i = 1",
      "mutated_line": "w_i = 0",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 0\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w_i = 1",
      "mutated_line": "w_i = -1",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = -1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "w_i *= w",
      "mutated_line": "w_i /= w",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i /= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [0] / (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] / (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [0] + (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] + (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [0] ** (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] ** (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [0] / (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] / (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [0] + (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] + (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [0] ** (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] ** (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 or c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 or c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 2:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 0:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 0:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == -1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n // 3",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 3\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n // 1",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 1\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n // 0",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 0\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n // 1",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 1\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "half = n // 2",
      "mutated_line": "half = n // -2",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // -2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y[i] = y_even[i] + w_i * y_odd[i]",
      "mutated_line": "y[i] = y_even[i] - w_i * y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] - w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y[i] = y_even[i] + w_i * y_odd[i]",
      "mutated_line": "y[i] = y_even[i] * (w_i * y_odd[i])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] * (w_i * y_odd[i])\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i + half] = y_even[i] + w_i * y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] + w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i + half] = y_even[i] * (w_i * y_odd[i])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] * (w_i * y_odd[i])\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 2 << (len(a) + len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 2 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 0 << (len(a) + len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 0 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 0 << (len(a) + len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 0 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = -1 << (len(a) + len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = -1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "w = cmath.exp(2j * cmath.pi / n)",
      "mutated_line": "w = cmath.exp(2j * cmath.pi * n)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi * n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "w = cmath.exp(2j * cmath.pi / n)",
      "mutated_line": "w = cmath.exp(2j * cmath.pi // n)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi // n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [0] * (n + len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n + len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [0] * (n * len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n * len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [0] * (n + len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n + len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [0] * (n * len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n * len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y_c = [y_ai * y_bi for y_ai, y_bi in zip(y_a, y_b)]",
      "mutated_line": "y_c = [y_ai / y_bi for (y_ai, y_bi) in zip(y_a, y_b)]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai / y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y_c = [y_ai * y_bi for y_ai, y_bi in zip(y_a, y_b)]",
      "mutated_line": "y_c = [y_ai + y_bi for (y_ai, y_bi) in zip(y_a, y_b)]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai + y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y_c = [y_ai * y_bi for y_ai, y_bi in zip(y_a, y_b)]",
      "mutated_line": "y_c = [y_ai ** y_bi for (y_ai, y_bi) in zip(y_a, y_b)]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai ** y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w * -1)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w * -1)\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w + -1)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w + -1)\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) >= 1 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) >= 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) <= 1 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) <= 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) != 1 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) != 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-1] != 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] != 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [1] * n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [1] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [-1] * n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [-1] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "y = [0] * n",
      "mutated_line": "y = [1] * n",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [1] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y[i] = y_even[i] + w_i * y_odd[i]",
      "mutated_line": "y[i] = y_even[i] + w_i / y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i / y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y[i] = y_even[i] + w_i * y_odd[i]",
      "mutated_line": "y[i] = y_even[i] + (w_i + y_odd[i])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + (w_i + y_odd[i])\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y[i] = y_even[i] + w_i * y_odd[i]",
      "mutated_line": "y[i] = y_even[i] + w_i ** y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i ** y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i - half] = y_even[i] - w_i * y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i - half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i * half] = y_even[i] - w_i * y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i * half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i + half] = y_even[i] - w_i / y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i / y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i + half] = y_even[i] - (w_i + y_odd[i])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - (w_i + y_odd[i])\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y[i + half] = y_even[i] - w_i * y_odd[i]",
      "mutated_line": "y[i + half] = y_even[i] - w_i ** y_odd[i]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i ** y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "w = cmath.exp(2j * cmath.pi / n)",
      "mutated_line": "w = cmath.exp(2j / cmath.pi / n)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j / cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "w = cmath.exp(2j * cmath.pi / n)",
      "mutated_line": "w = cmath.exp((2j + cmath.pi) / n)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp((2j + cmath.pi) / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "w = cmath.exp(2j * cmath.pi / n)",
      "mutated_line": "w = cmath.exp(2j ** cmath.pi / n)",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j ** cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [1] * (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [1] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [-1] * (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [-1] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a += [0] * (n - len(a))",
      "mutated_line": "a += [1] * (n - len(a))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [1] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [1] * (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [1] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [-1] * (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [-1] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b += [0] * (n - len(b))",
      "mutated_line": "b += [1] * (n - len(b))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [1] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w ** (+1))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (+1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "c = [round(abs(x) / n) for x in c]",
      "mutated_line": "c = [round(abs(x) * n) for x in c]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) * n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "c = [round(abs(x) / n) for x in c]",
      "mutated_line": "c = [round(abs(x) // n) for x in c]",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) // n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 2 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 2 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 0 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 0 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 0 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 0 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > -1 and c[-1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > -1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-1] == 1:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 1:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-1] == -1:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == -1:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-1] == 1:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 1:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::3], a[1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::3], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::1], a[1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::1], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::0], a[1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::0], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::1], a[1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::1], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::-2], a[1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::-2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[2::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[2::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[0::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[0::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[0::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[0::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[-1::2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[-1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[1::3])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::3])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[1::1])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::1])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[1::0])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::0])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[1::1])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::1])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a_even, a_odd = a[::2], a[1::2]",
      "mutated_line": "(a_even, a_odd) = (a[::2], a[1::-2])",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::-2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) + 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) + 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << ((len(a) + len(b)) * 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << ((len(a) + len(b)) * 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w ** (-2))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-2))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w ** (-0))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-0))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w ** (-0))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-0))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = FFT_poly(y_c, n, w**-1)",
      "mutated_line": "c = FFT_poly(y_c, n, w ** (--1))",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (--1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[+1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[+1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) - len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) - len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) * len(b) - 2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) * len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) - 3).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 3).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) - 1).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 1).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) - 0).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 0).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) - 1).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 1).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = 1 << (len(a) + len(b) - 2).bit_length()",
      "mutated_line": "n = 1 << (len(a) + len(b) - -2).bit_length()",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - -2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-1] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-2] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-2] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-0] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-0] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[-0] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[-0] == 0:\n        c.pop()\n    return c"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while len(c) > 1 and c[-1] == 0:",
      "mutated_line": "while len(c) > 1 and c[--1] == 0:",
      "code": "import cmath\n\ndef FFT_poly(a, n, w):\n    if n == 1:\n        return a\n    (a_even, a_odd) = (a[::2], a[1::2])\n    half = n // 2\n    w_sq = w * w\n    y_even = FFT_poly(a_even, half, w_sq)\n    y_odd = FFT_poly(a_odd, half, w_sq)\n    y = [0] * n\n    w_i = 1\n    for i in range(half):\n        y[i] = y_even[i] + w_i * y_odd[i]\n        y[i + half] = y_even[i] - w_i * y_odd[i]\n        w_i *= w\n    return y\n\ndef Schonhage_Strassen(a, b):\n    n = 1 << (len(a) + len(b) - 2).bit_length()\n    w = cmath.exp(2j * cmath.pi / n)\n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    y_a = FFT_poly(a, n, w)\n    y_b = FFT_poly(b, n, w)\n    y_c = [y_ai * y_bi for (y_ai, y_bi) in zip(y_a, y_b)]\n    c = FFT_poly(y_c, n, w ** (-1))\n    c = [round(abs(x) / n) for x in c]\n    while len(c) > 1 and c[--1] == 0:\n        c.pop()\n    return c"
    }
  ]
}