{
  "task_id": "cf_79755",
  "entry_point": "maxSumPath",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if  N == 0:",
      "mutated_line": "if N != 0:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N != 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if  N == 0:",
      "mutated_line": "if N == 1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 1:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if  N == 0:",
      "mutated_line": "if N == -1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == -1:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if  N == 0:",
      "mutated_line": "if N == 1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 1:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 and c < 0 and (r >= N) and (c >= N) and (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 and c < 0 and (r >= N) and (c >= N) and (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] == -1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] == -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 1\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = -1\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 1\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_sum, max_steps = 0, []",
      "mutated_line": "(max_sum, max_steps) = (1, [])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (1, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_sum, max_steps = 0, []",
      "mutated_line": "(max_sum, max_steps) = (-1, [])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (-1, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_sum, max_steps = 0, []",
      "mutated_line": "(max_sum, max_steps) = (1, [])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (1, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[1, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[-1, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[1, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 2], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 0], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 0], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, -1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [2, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [0, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [0, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [-1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 1], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, -1], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 1], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [+1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 1], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, -1], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 1], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [1, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [-1, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [1, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, +1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r <= 0 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r <= 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r >= 0 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r >= 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r != 0 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r != 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c <= 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c <= 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c >= 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c >= 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c != 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c != 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r > N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r > N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r < N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r < N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r == N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r == N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c > N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c > N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c < N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c < N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c == N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c == N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k < 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k < 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k > 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k > 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k == 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k == 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 1\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return -1\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 1\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] != +1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != +1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if temp_sum > max_sum:",
      "mutated_line": "if temp_sum >= max_sum:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum >= max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if temp_sum > max_sum:",
      "mutated_line": "if temp_sum <= max_sum:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum <= max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if temp_sum > max_sum:",
      "mutated_line": "if temp_sum != max_sum:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum != max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return max_steps[::-1]",
      "mutated_line": "return max_steps[::+1]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::+1]"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[+1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[+1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-2, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-0, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-0, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [--1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -2]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -0]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -0]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]",
      "mutated_line": "",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, --1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 1 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 1 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < -1 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < -1 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 1 or c < 0 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 1 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 1 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 1 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < -1 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < -1 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 1 or r >= N or (c >= N) or (k <= 0):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 1 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 1):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k <= -1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= -1):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if r < 0 or c < 0 or r >= N or c >= N or k <= 0:",
      "mutated_line": "if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 1):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 1):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] != -2:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -2:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] != -0:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -0:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] != -0:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -0:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[r][c][k] != -1:",
      "mutated_line": "if dp[r][c][k] != --1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != --1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r - offset[0], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r - offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r * offset[0], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r * offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c - offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c - offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c * offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c * offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] - getMaxSum(rr, cc, k - 1))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] - getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] * getMaxSum(rr, cc, k - 1))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] * getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k >= 1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k >= 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k <= 1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k <= 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k != 1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k != 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return max_steps[::-1]",
      "mutated_line": "return max_steps[::-2]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return max_steps[::-1]",
      "mutated_line": "return max_steps[::-0]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return max_steps[::-1]",
      "mutated_line": "return max_steps[::-0]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return max_steps[::-1]",
      "mutated_line": "return max_steps[::--1]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::--1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-2 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-2 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-0 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-0 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-0 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-0 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[--1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[--1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k > 2:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 2:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k > 0:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 0:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k > 0:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 0:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while temp_k > 1:",
      "mutated_line": "while temp_k > -1:",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > -1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k - 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k - 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k * 1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k * 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[1], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[-1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[-1], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[1], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[2])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[0])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[0])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[0])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[0])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[-1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[-1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k + 1))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k + 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k * 1))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k * 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 or cc >= 0 or rr < N or (cc < N) or (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 or cc >= 0 or rr < N or (cc < N) or (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k + 2)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 2)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k + 0)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 0)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k + 0)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 0)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [[[-1 for _ in range(k+1)] for _ in range(N)] for _ in range(N)]",
      "mutated_line": "dp = [[[-1 for _ in range(k + -1)] for _ in range(N)] for _ in range(N)]",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + -1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 2))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 2))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 0))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 0))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 0))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 0))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k-1))",
      "mutated_line": "res = max(res, grid[r][c] + getMaxSum(rr, cc, k - -1))",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - -1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r - offset[0], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r - offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r * offset[0], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r * offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c - offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c - offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c * offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c * offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr > 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr > 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr < 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr < 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr == 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr == 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc > 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc > 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc < 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc < 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc == 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc == 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr <= N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr <= N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr >= N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr >= N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr != N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr != N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc <= N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc <= N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc >= N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc >= N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc != N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc != N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] != dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] != dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= -1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= -1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 1 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= -1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= -1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 1 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] - grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] - grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] * grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] * grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k + 1)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k + 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k * 1)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k * 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[1], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[-1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[-1], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[1], c + offset[1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[1], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[2])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[2])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[0])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[0])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[0])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[0])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rr, cc = r + offset[0], c + offset[1]",
      "mutated_line": "(rr, cc) = (r + offset[0], c + offset[-1])",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[-1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k - 2)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 2)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k - 0)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 0)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k - 0)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 0)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r, c, temp_k = rr, cc, temp_k - 1",
      "mutated_line": "(r, c, temp_k) = (rr, cc, temp_k - -1)",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - -1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k + 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k + 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k * 1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k * 1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 2] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 2] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 0] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 0] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 0] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - 0] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if rr >= 0 and cc >= 0 and rr < N and cc < N and dp[rr][cc][temp_k-1] + grid[r][c] == dp[r][c][temp_k]:",
      "mutated_line": "if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - -1] + grid[r][c] == dp[r][c][temp_k]):",
      "code": "def maxSumPath(grid, k):\n    N = len(grid)\n    if N == 0:\n        return []\n    dp = [[[-1 for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    offsets = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n    def getMaxSum(r, c, k):\n        if r < 0 or c < 0 or r >= N or (c >= N) or (k <= 0):\n            return 0\n        if dp[r][c][k] != -1:\n            return dp[r][c][k]\n        res = 0\n        for offset in offsets:\n            (rr, cc) = (r + offset[0], c + offset[1])\n            res = max(res, grid[r][c] + getMaxSum(rr, cc, k - 1))\n        dp[r][c][k] = res\n        return res\n    (max_sum, max_steps) = (0, [])\n    for r in range(N):\n        for c in range(N):\n            temp_sum = getMaxSum(r, c, k)\n            if temp_sum > max_sum:\n                max_sum = temp_sum\n                max_steps = [grid[r][c]]\n                temp_k = k\n                while temp_k > 1:\n                    for offset in offsets:\n                        (rr, cc) = (r + offset[0], c + offset[1])\n                        if rr >= 0 and cc >= 0 and (rr < N) and (cc < N) and (dp[rr][cc][temp_k - -1] + grid[r][c] == dp[r][c][temp_k]):\n                            max_steps.append(grid[rr][cc])\n                            (r, c, temp_k) = (rr, cc, temp_k - 1)\n                            break\n    return max_steps[::-1]"
    }
  ]
}