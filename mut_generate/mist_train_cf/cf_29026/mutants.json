{
  "task_id": "cf_29026",
  "entry_point": "squarish",
  "mutant_count": 200,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def squarish(points, threshold=.6) -> bool:",
      "mutated_line": "def squarish(points, threshold=1.6) -> bool:",
      "code": "import math\n\ndef squarish(points, threshold=1.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def squarish(points, threshold=.6) -> bool:",
      "mutated_line": "def squarish(points, threshold=-0.4) -> bool:",
      "code": "import math\n\ndef squarish(points, threshold=-0.4) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def squarish(points, threshold=.6) -> bool:",
      "mutated_line": "def squarish(points, threshold=0) -> bool:",
      "code": "import math\n\ndef squarish(points, threshold=0) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def squarish(points, threshold=.6) -> bool:",
      "mutated_line": "def squarish(points, threshold=1) -> bool:",
      "code": "import math\n\ndef squarish(points, threshold=1) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def squarish(points, threshold=.6) -> bool:",
      "mutated_line": "def squarish(points, threshold=-0.6) -> bool:",
      "code": "import math\n\ndef squarish(points, threshold=-0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "distance_ratio = shortest / longest",
      "mutated_line": "distance_ratio = shortest * longest",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest * longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "distance_ratio = shortest / longest",
      "mutated_line": "distance_ratio = shortest // longest",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest // longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "distances_are_close_enough = distance_ratio >= threshold",
      "mutated_line": "distances_are_close_enough = distance_ratio > threshold",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio > threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "distances_are_close_enough = distance_ratio >= threshold",
      "mutated_line": "distances_are_close_enough = distance_ratio < threshold",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio < threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "distances_are_close_enough = distance_ratio >= threshold",
      "mutated_line": "distances_are_close_enough = distance_ratio == threshold",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio == threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "return distances_are_close_enough and angles_are_close_enough",
      "mutated_line": "return distances_are_close_enough or angles_are_close_enough",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough or angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] - v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] - v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] * (v1[1] * v2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] * (v1[1] * v2[1])\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 - (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 - (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 * (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 * (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i + 1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i + 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i * 1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i * 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i + 1) * len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) * len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[i + 1 + len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[i + 1 + len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] + p2[0], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] + p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] * p2[0], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] * p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] + p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] + p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] * p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] * p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] + p2[0], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] + p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] * p2[0], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] * p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] + p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] + p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] * p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] * p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] / v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] / v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] + v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] + v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] ** v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] ** v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] / v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] / v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + (v1[1] + v2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + (v1[1] + v2[1])\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] ** v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] ** v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 - v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 - v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 * v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 * v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 - v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 - v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 * v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 * v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "angle = math.acos(dot_product / (mag_v1 * mag_v2))",
      "mutated_line": "angle = math.acos(dot_product * (mag_v1 * mag_v2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product * (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "angle = math.acos(dot_product / (mag_v1 * mag_v2))",
      "mutated_line": "angle = math.acos(dot_product // (mag_v1 * mag_v2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product // (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) <= 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) <= 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) >= 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) >= 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) != 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) != 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) * 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) * 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt(points[i][0] - points[i + 1][0] + 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt(points[i][0] - points[i + 1][0] + 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) * 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) * 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1] + 2)) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1] + 2)) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) + 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) + 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) * 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) * 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i - 2]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 2]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i - 0]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 0]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i - 0]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 0]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = points[i-1]",
      "mutated_line": "p1 = points[i - -1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - -1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i - 1) % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i - 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[i * 1 % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[i * 1 % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] * 2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] * 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] + 2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] + 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] * 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] * 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + (v1[1] + 2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + (v1[1] + 2))\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] * 2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] * 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] + 2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] + 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] * 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] * 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + (v2[1] + 2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + (v2[1] + 2))\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "angle = math.acos(dot_product / (mag_v1 * mag_v2))",
      "mutated_line": "angle = math.acos(dot_product / (mag_v1 / mag_v2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 / mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "angle = math.acos(dot_product / (mag_v1 * mag_v2))",
      "mutated_line": "angle = math.acos(dot_product / (mag_v1 + mag_v2))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 + mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "angle = math.acos(dot_product / (mag_v1 * mag_v2))",
      "mutated_line": "angle = math.acos(dot_product / mag_v1 ** mag_v2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / mag_v1 ** mag_v2)\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) < 1.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 1.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) < -0.9 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < -0.9 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) < 0 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) < 1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[0]) < -0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < -0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] + points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] + points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] * points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] * points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 3 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 3 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 1 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 1 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 0 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 0 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 1 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 1 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** -2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** -2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] + points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] + points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] * points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] * points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 3) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 3) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 1) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 1) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 0) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 0) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 1) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 1) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** -2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** -2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 2)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 2)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 0)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 0)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 0)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 0)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - -1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - -1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i + 2) % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 2) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i + 0) % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 0) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i + 0) % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 0) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p3 = points[(i+1) % len(points)]",
      "mutated_line": "p3 = points[(i + -1) % len(points)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + -1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[1] - p2[0], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[1] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[-1] - p2[0], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[-1] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[1] - p2[0], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[1] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[1], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[1], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[-1], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[-1], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[1], p1[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[1], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[2] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[2] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[0] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[0] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[0] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[0] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[-1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[-1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] - p2[2])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[2])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] - p2[0])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[0])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] - p2[0])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[0])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v1 = (p1[0] - p2[0], p1[1] - p2[1])",
      "mutated_line": "v1 = (p1[0] - p2[0], p1[1] - p2[-1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[-1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[1] - p2[0], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[1] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[-1] - p2[0], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[-1] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[1] - p2[0], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[1] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[1], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[1], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[-1], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[-1], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[1], p3[1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[1], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[2] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[2] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[0] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[0] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[0] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[0] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[-1] - p2[1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[-1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] - p2[2])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[2])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] - p2[0])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[0])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] - p2[0])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[0])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "v2 = (p3[0] - p2[0], p3[1] - p2[1])",
      "mutated_line": "v2 = (p3[0] - p2[0], p3[1] - p2[-1])",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[-1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[1] * v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[1] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[-1] * v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[-1] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[1] * v2[0] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[1] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[1] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[1] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[-1] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[-1] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[1] + v1[1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[1] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[2] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[2] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[0] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[0] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[0] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[0] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[-1] * v2[1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[-1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] * v2[2]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[2]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] * v2[0]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[0]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] * v2[0]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[0]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dot_product = v1[0]*v2[0] + v1[1]*v2[1]",
      "mutated_line": "dot_product = v1[0] * v2[0] + v1[1] * v2[-1]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[-1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 3 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 3 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 1 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 1 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 0 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 0 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 1 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 1 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** -2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** -2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 3)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 3)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 1)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 1)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 0)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 0)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 1)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 1)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** -2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** -2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 3 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 3 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 1 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 1 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 0 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 0 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 1 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 1 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** -2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** -2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 3)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 3)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 1)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 1)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 0)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 0)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 1)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 1)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** -2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** -2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a + angles[0]) < 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a + angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a * angles[0]) < 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a * angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[1] ** 2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[1] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[-1] ** 2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[-1] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[1] ** 2 + v1[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[1] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[2] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[2] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[0] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[0] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[0] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[0] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)",
      "mutated_line": "mag_v1 = math.sqrt(v1[0] ** 2 + v1[-1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[-1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[1] ** 2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[1] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[-1] ** 2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[-1] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[1] ** 2 + v2[1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[1] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[2] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[2] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[0] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[0] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[0] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[0] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)",
      "mutated_line": "mag_v2 = math.sqrt(v2[0] ** 2 + v2[-1] ** 2)",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[-1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][-1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][-1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][1] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][-1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][-1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][1]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][2] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][2] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][0] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][0] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][0] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][0] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][-1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][-1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][2]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][2]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][0]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][0]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][0]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][0]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][-1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][-1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[1]) < 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[1]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[-1]) < 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[-1]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "angles_are_close_enough = all(abs(a - angles[0]) < 0.1 for a in angles)",
      "mutated_line": "angles_are_close_enough = all((abs(a - angles[1]) < 0.1 for a in angles))",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[1]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i - 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i - 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i * 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i * 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i - 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i - 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i * 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i * 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 2][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 2][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 0][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 0][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 0][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 0][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + -1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + -1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 2][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 2][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 0][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 0][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 0][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 0][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = [math.sqrt((points[i][0] - points[i+1][0])**2 + (points[i][1] - points[i+1][1])**2) for i in range(len(points)-1)]",
      "mutated_line": "distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + -1][1]) ** 2) for i in range(len(points) - 1)]",
      "code": "import math\n\ndef squarish(points, threshold=0.6) -> bool:\n    \"\"\"\n    This function determines whether the shape formed by the given points is \"squarish\".\n    \n    A shape is considered \"squarish\" if the following conditions are met:\n    1. All side lengths are approximately the same, with the ratio of the shortest to the longest side length being greater than or equal to the given threshold.\n    2. All angles are approximately the same, with a difference of less than 0.1 radians between each angle and the first angle.\n    \n    Args:\n    points (list): A list of tuples representing the points in the shape.\n    threshold (float): The minimum ratio of the shortest to the longest side length. Defaults to 0.6.\n    \n    Returns:\n    bool: True if the shape is \"squarish\", False otherwise.\n    \"\"\"\n    distances = [math.sqrt((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + -1][1]) ** 2) for i in range(len(points) - 1)]\n    angles = []\n    for i in range(len(points)):\n        p1 = points[i - 1]\n        p2 = points[i]\n        p3 = points[(i + 1) % len(points)]\n        v1 = (p1[0] - p2[0], p1[1] - p2[1])\n        v2 = (p3[0] - p2[0], p3[1] - p2[1])\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        mag_v1 = math.sqrt(v1[0] ** 2 + v1[1] ** 2)\n        mag_v2 = math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        angle = math.acos(dot_product / (mag_v1 * mag_v2))\n        angles.append(angle)\n    shortest = float(min(distances))\n    longest = float(max(distances))\n    distance_ratio = shortest / longest\n    distances_are_close_enough = distance_ratio >= threshold\n    angles_are_close_enough = all((abs(a - angles[0]) < 0.1 for a in angles))\n    return distances_are_close_enough and angles_are_close_enough"
    }
  ]
}