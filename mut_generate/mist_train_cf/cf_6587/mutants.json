{
  "task_id": "cf_6587",
  "entry_point": "n_queens",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return False\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return row + col",
      "mutated_line": "return row - col",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row - col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return row + col",
      "mutated_line": "return row * col",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row * col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(queens) == n:",
      "mutated_line": "if len(queens) != n:",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) != n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "min_sum = float('inf')",
      "mutated_line": "min_sum = float('')",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row and c == col and (abs(r - row) == abs(c - col)):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row and c == col and (abs(r - row) == abs(c - col)):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if total_sum < min_sum:",
      "mutated_line": "if total_sum <= min_sum:",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum <= min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if total_sum < min_sum:",
      "mutated_line": "if total_sum >= min_sum:",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum >= min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if total_sum < min_sum:",
      "mutated_line": "if total_sum != min_sum:",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum != min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r != row or c == col or abs(r - row) == abs(c - col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r != row or c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c != col or abs(r - row) == abs(c - col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c != col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c == col or abs(r - row) != abs(c - col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) != abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c - col):\n                return True\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c == col or abs(r + row) == abs(c - col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r + row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c == col or abs(r * row) == abs(c - col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r * row) == abs(c - col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c == col or abs(r - row) == abs(c + col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c + col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if r == row or c == col or abs(r - row) == abs(c - col):",
      "mutated_line": "if r == row or c == col or abs(r - row) == abs(c * col):",
      "code": "def n_queens(n):\n\n    def is_safe(row, col, queens):\n        for (r, c) in queens:\n            if r == row or c == col or abs(r - row) == abs(c * col):\n                return False\n        return True\n\n    def sum_threatened_cells(queen, n):\n        (row, col) = queen\n        return row + col\n\n    def backtrack(queens):\n        if len(queens) == n:\n            total_sum = sum((sum_threatened_cells(queen, n) for queen in queens))\n            nonlocal min_sum, min_solution\n            if total_sum < min_sum:\n                min_sum = total_sum\n                min_solution = queens[:]\n            return\n        row = len(queens)\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append((row, col))\n                backtrack(queens)\n                queens.pop()\n    min_sum = float('inf')\n    min_solution = []\n    backtrack([])\n    return min_solution"
    }
  ]
}