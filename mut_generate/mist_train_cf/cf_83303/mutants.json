{
  "task_id": "cf_83303",
  "entry_point": "bagOfTokensScore",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = bns = 0",
      "mutated_line": "ans = bns = 1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 1\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = bns = 0",
      "mutated_line": "ans = bns = -1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = -1\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = bns = 0",
      "mutated_line": "ans = bns = 1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 1\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque or (deque[0] <= P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque or (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[0] <= P and bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P and bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque or deque[0] <= P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque or deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "P -= deque.popleft()",
      "mutated_line": "P += deque.popleft()",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P += deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "bns += 1",
      "mutated_line": "bns -= 1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns -= 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if deque and bns:",
      "mutated_line": "if deque or bns:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque or bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "P += deque.pop()",
      "mutated_line": "P -= deque.pop()",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P -= deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "bns -= 1",
      "mutated_line": "bns += 1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[0] < P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] < P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[0] > P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] > P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[0] == P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] == P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[0] < P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] < P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[0] > P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] > P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[0] == P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] == P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bns += 1",
      "mutated_line": "bns += 2",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 2\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bns += 1",
      "mutated_line": "bns += 0",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 0\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bns += 1",
      "mutated_line": "bns += 0",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 0\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bns += 1",
      "mutated_line": "bns += -1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += -1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "bns -= 1",
      "mutated_line": "bns -= 2",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "bns -= 1",
      "mutated_line": "bns -= 0",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "bns -= 1",
      "mutated_line": "bns -= 0",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "bns -= 1",
      "mutated_line": "bns -= -1",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[1] <= P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[1] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[-1] <= P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[-1] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while deque and (deque[0] <= P or bns):",
      "mutated_line": "while deque and (deque[1] <= P or bns):",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[1] <= P or bns):\n        while deque and deque[0] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[1] <= P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[1] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[-1] <= P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[-1] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while deque and deque[0] <= P:",
      "mutated_line": "while deque and deque[1] <= P:",
      "code": "import collections\n\ndef bagOfTokensScore(tokens, P):\n    tokens.sort()\n    deque = collections.deque(tokens)\n    ans = bns = 0\n    while deque and (deque[0] <= P or bns):\n        while deque and deque[1] <= P:\n            P -= deque.popleft()\n            bns += 1\n        ans = max(ans, bns)\n        if deque and bns:\n            P += deque.pop()\n            bns -= 1\n    return ans"
    }
  ]
}