{
  "task_id": "cf_60459",
  "entry_point": "lev_distance",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if source_word == target_word:",
      "mutated_line": "if source_word != target_word:",
      "code": "def lev_distance(source_word, target_word):\n    if source_word != target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(source_word) < len(target_word):",
      "mutated_line": "if len(source_word) <= len(target_word):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) <= len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(source_word) < len(target_word):",
      "mutated_line": "if len(source_word) >= len(target_word):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) >= len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(source_word) < len(target_word):",
      "mutated_line": "if len(source_word) != len(target_word):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) != len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 1\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return -1\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 1\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) - 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) * 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return prev_row[-1]",
      "mutated_line": "return prev_row[+1]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[+1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 2)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 0)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 0)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev_row = range(len(target_word) + 1)",
      "mutated_line": "for (s_char, s_index) in zip(source_word, range(len(source_word))):",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + -1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index - 1]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index - 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index * 1]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index * 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] - 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] - 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] * 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] * 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] - 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] - 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] * 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] * 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "substitutions = prev_row[t_index] + (s_char != t_char)",
      "mutated_line": "substitutions = prev_row[t_index] - (s_char != t_char)",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] - (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "substitutions = prev_row[t_index] + (s_char != t_char)",
      "mutated_line": "substitutions = prev_row[t_index] * (s_char != t_char)",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] * (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return prev_row[-1]",
      "mutated_line": "return prev_row[-2]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-2]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return prev_row[-1]",
      "mutated_line": "return prev_row[-0]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return prev_row[-1]",
      "mutated_line": "return prev_row[-0]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return prev_row[-1]",
      "mutated_line": "return prev_row[--1]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[--1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index + 2]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 2]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index + 0]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 0]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index + 0]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 0]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "curr_row = [s_index + 1]",
      "mutated_line": "curr_row = [s_index + -1]",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + -1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] + 2",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 2\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] + 0",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 0\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] + 0",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 0\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 1] + -1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + -1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] + 2",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 2\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] + 0",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 0\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] + 0",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 0\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "deletions = curr_row[t_index] + 1",
      "mutated_line": "deletions = curr_row[t_index] + -1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + -1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "substitutions = prev_row[t_index] + (s_char != t_char)",
      "mutated_line": "substitutions = prev_row[t_index] + (s_char == t_char)",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char == t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index - 1] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index - 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index * 1] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index * 1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 2] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 2] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 0] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 0] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + 0] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + 0] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "insertions = prev_row[t_index + 1] + 1",
      "mutated_line": "insertions = prev_row[t_index + -1] + 1",
      "code": "def lev_distance(source_word, target_word):\n    if source_word == target_word:\n        return 0\n    if len(source_word) < len(target_word):\n        return lev_distance(target_word, source_word)\n    if not target_word:\n        return len(source_word)\n    prev_row = range(len(target_word) + 1)\n    for (s_char, s_index) in zip(source_word, range(len(source_word))):\n        curr_row = [s_index + 1]\n        for (t_char, t_index) in zip(target_word, range(len(target_word))):\n            insertions = prev_row[t_index + -1] + 1\n            deletions = curr_row[t_index] + 1\n            substitutions = prev_row[t_index] + (s_char != t_char)\n            curr_row.append(min(insertions, deletions, substitutions))\n        prev_row = curr_row\n    return prev_row[-1]"
    }
  ]
}