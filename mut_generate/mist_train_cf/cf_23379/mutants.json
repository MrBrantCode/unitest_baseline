{
  "task_id": "cf_23379",
  "entry_point": "find_shortest_path",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 or y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 or y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((1, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((-1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((-1, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((1, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, 1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 1))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, -1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, -1))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, 1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 1))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x != rows - 1 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x != rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y != cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y != cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows or 0 <= ny < cols or maze[nx][ny] == 0 or ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows or 0 <= ny < cols or maze[nx][ny] == 0 or ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[-1]))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "rows, cols = len(maze), len(maze[0])",
      "mutated_line": "(rows, cols) = (len(maze), len(maze[1]))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(1, 0, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(1, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(-1, 0, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(-1, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(1, 0, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(1, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 1, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 1, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, -1, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, -1, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 1, 1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 1, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 0, 2)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 2)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 0, 0)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 0)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 0, 0)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 0)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = deque([(0, 0, 1)])",
      "mutated_line": "queue = deque([(0, 0, -1)])",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, -1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows + 1 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows + 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows * 1 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows * 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols + 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols + 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols * 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols * 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 < nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 > nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 == nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 < ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 < ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 > ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 > ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 == ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 == ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] != 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] != 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 2 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 2 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 0 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 0 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 0 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 0 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - -1 and y == cols - 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - -1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols - 2:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 2:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols - 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 0:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols - 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 0:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x == rows - 1 and y == cols - 1:",
      "mutated_line": "if x == rows - 1 and y == cols - -1:",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - -1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if -1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and -1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and -1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 1 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 1) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == -1) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == -1) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (0 <= nx < rows) and (0 <= ny < cols) and maze[nx][ny] == 0 and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 1) and ((nx, ny) not in visited):",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 1) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length - 1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length - 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length * 1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length * 1))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length + 2))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 2))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length + 0))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 0))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length + 0))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + 0))\n                visited.add((nx, ny))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((nx, ny, length + 1))",
      "mutated_line": "queue.append((nx, ny, length + -1))",
      "code": "from collections import deque\n\ndef find_shortest_path(maze):\n    \"\"\"\n    This function finds the length of the shortest path from the top-left corner \n    to the bottom-right corner in a given 2D maze. The maze is represented as a \n    2D list where 0 represents an open space and 1 represents a wall. The path \n    can only be constructed from open spaces and can move in four directions \n    (up, down, left, right).\n\n    Args:\n        maze (list): A 2D list representing the maze.\n\n    Returns:\n        int: The length of the shortest path. If there is no path, returns infinity.\n    \"\"\"\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (x, y, length) = queue.popleft()\n        if x == rows - 1 and y == cols - 1:\n            return length\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (maze[nx][ny] == 0) and ((nx, ny) not in visited):\n                queue.append((nx, ny, length + -1))\n                visited.add((nx, ny))\n    return float('inf')"
    }
  ]
}