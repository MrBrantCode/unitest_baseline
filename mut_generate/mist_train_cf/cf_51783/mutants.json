{
  "task_id": "cf_51783",
  "entry_point": "canMouseWin",
  "mutant_count": 134,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[0] / n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] / n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[0] + n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] + n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[0] ** n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] ** n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if grid[i][j] == 'M':",
      "mutated_line": "if grid[i][j] != 'M':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x, y, time, is_mouse = queue.pop(0)",
      "mutated_line": "(x, y, time, is_mouse) = queue.pop(1)",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(1)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x, y, time, is_mouse = queue.pop(0)",
      "mutated_line": "(x, y, time, is_mouse) = queue.pop(-1)",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(-1)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x, y, time, is_mouse = queue.pop(0)",
      "mutated_line": "(x, y, time, is_mouse) = queue.pop(1)",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(1)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if grid[x][y] == 'C':",
      "mutated_line": "if grid[x][y] != 'C':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] != 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' and time > 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' and time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or grid[nx][ny] != '#':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m or 0 <= ny < n or grid[nx][ny] != '#':\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[1] * n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[-1] * n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degrees = [[0] * n for _ in range(m)]",
      "mutated_line": "in_degrees = [[1] * n for _ in range(m)]",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if grid[i][j] == 'M':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif grid[i][j] == 'C':",
      "mutated_line": "elif grid[i][j] != 'C':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] != 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[x][y] == 'C':",
      "mutated_line": "if grid[x][y] == '':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == '':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return False\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] != 'M' or time > 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] != 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time >= 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time >= 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time <= 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time <= 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time != 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time != 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x * (dx * jump), y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y - dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y * (dy * jump))\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 < nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 > nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 == nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 < ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 > ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 == ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] == '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] == '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif grid[i][j] == 'C':",
      "mutated_line": "elif grid[i][j] == '':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == '':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == '' or time > 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == '' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time > 1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 1:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time > -1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > -1:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[x][y] == 'M' or time > 0:",
      "mutated_line": "if grid[x][y] == 'M' or time > 1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 1:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx / jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + (dx + jump), y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx ** jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy / jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + (dy + jump))\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nx, ny = x + dx * jump, y + dy * jump",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy ** jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if -1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 1 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and -1 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] != '#'):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 1 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#':",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != ''):",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != ''):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if grid[nx][ny] == 'F':",
      "mutated_line": "if grid[nx][ny] != 'F':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] != 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "if in_degrees[nx][ny] != 0:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] != 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "queue.append((nx, ny, time + 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] != 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 1, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, -1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, -1, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 1, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, 2))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 2))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 0))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 0))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append((i, j, 0, 1))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, -1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, -1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if grid[nx][ny] == 'F':",
      "mutated_line": "if grid[nx][ny] == '':",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == '':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "if in_degrees[nx][ny] == 1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 1:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "if in_degrees[nx][ny] == -1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == -1:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "if in_degrees[nx][ny] == 1:",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 1:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 2",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 2\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 0",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 0\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 0",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 0\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = -1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = -1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "queue.append((nx, ny, time + 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 1:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "queue.append((nx, ny, time + 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == -1:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degrees[nx][ny] == 0:",
      "mutated_line": "queue.append((nx, ny, time + 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 1:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 2",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 2\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 0",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 0\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = 0",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 0\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "in_degrees[nx][ny] = 1",
      "mutated_line": "in_degrees[nx][ny] = -1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = -1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 1, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, -1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, -1, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 1, 0))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 1, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 1))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, -1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, -1))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i, j, 0, 0))  # (x, y, time, is_mouse)",
      "mutated_line": "queue.append((i, j, 0, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 1))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time - 1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time - 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time * 1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time * 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + 1, 2))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 2))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 0))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 0))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + 1, -1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, -1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time - 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time * 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 1))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, -1))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 1))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + 2, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 2, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + 0, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 0, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + 0, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 0, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue.append((nx, ny, time + 1, 1))",
      "mutated_line": "queue.append((nx, ny, time + -1, 1))",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + -1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 2, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 0, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + 0, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((nx, ny, time + 1, 0))",
      "mutated_line": "in_degrees[nx][ny] = 1",
      "code": "def canMouseWin(grid, catJump, mouseJump):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    in_degrees = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                queue.append((i, j, 0, 1))\n            elif grid[i][j] == 'C':\n                queue.append((i, j, 0, 0))\n    while queue:\n        (x, y, time, is_mouse) = queue.pop(0)\n        if is_mouse:\n            if grid[x][y] == 'C':\n                return True\n            jump = mouseJump\n        else:\n            if grid[x][y] == 'M' or time > 0:\n                continue\n            jump = catJump\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx * jump, y + dy * jump)\n            if 0 <= nx < m and 0 <= ny < n and (grid[nx][ny] != '#'):\n                if is_mouse:\n                    if grid[nx][ny] == 'F':\n                        continue\n                    if in_degrees[nx][ny] == 0:\n                        queue.append((nx, ny, time + 1, 1))\n                        in_degrees[nx][ny] = 1\n                elif in_degrees[nx][ny] == 0:\n                    queue.append((nx, ny, time + -1, 0))\n                    in_degrees[nx][ny] = 1\n    return False"
    }
  ]
}