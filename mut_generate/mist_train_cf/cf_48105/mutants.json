{
  "task_id": "cf_48105",
  "entry_point": "shortest_path",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = -1\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 1\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while end is not None:",
      "mutated_line": "while end is None:",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dist != distances[current_node]:",
      "mutated_line": "if dist == distances[current_node]:",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist == distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.put((0, start))",
      "mutated_line": "queue.put((1, start))",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((1, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.put((0, start))",
      "mutated_line": "queue.put((-1, start))",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((-1, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.put((0, start))",
      "mutated_line": "queue.put((1, start))",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((1, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "distances = {node: float('infinity') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "new_dist = distances[current_node] + neighbor_dist",
      "mutated_line": "new_dist = distances[current_node] - neighbor_dist",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] - neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "new_dist = distances[current_node] + neighbor_dist",
      "mutated_line": "new_dist = distances[current_node] * neighbor_dist",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] * neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist <= old_dist:",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist <= old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist >= old_dist:",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist >= old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_dist < old_dist:",
      "mutated_line": "if new_dist != old_dist:",
      "code": "from queue import PriorityQueue\n\ndef shortest_path(graph, start, end):\n    \"\"\"\n    This function finds the shortest path between two nodes in a weighted graph.\n\n    Args:\n    graph (dict): A dictionary representing the graph, where each key is a node and its corresponding value is another dictionary.\n                  The inner dictionary's keys are the neighboring nodes and its values are the edge weights.\n    start (node): The starting node for the shortest path.\n    end (node): The ending node for the shortest path.\n\n    Returns:\n    list: A list of nodes representing the shortest path from the start node to the end node.\n    \"\"\"\n    queue = PriorityQueue()\n    queue.put((0, start))\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    previous_nodes = {node: None for node in graph}\n    while not queue.empty():\n        (dist, current_node) = queue.get()\n        if dist != distances[current_node]:\n            continue\n        for (neighbor, neighbor_dist) in graph[current_node].items():\n            old_dist = distances[neighbor]\n            new_dist = distances[current_node] + neighbor_dist\n            if new_dist != old_dist:\n                distances[neighbor] = new_dist\n                previous_nodes[neighbor] = current_node\n                queue.put((new_dist, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    path.reverse()\n    return path"
    }
  ]
}