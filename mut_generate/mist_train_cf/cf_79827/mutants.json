{
  "task_id": "cf_79827",
  "entry_point": "median_and_mode",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 2 != 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 != 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "highest_count = 0",
      "mutated_line": "highest_count = 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 1\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "highest_count = 0",
      "mutated_line": "highest_count = -1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = -1\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "highest_count = 0",
      "mutated_line": "highest_count = 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 1\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if highest_count == 1:",
      "mutated_line": "if highest_count != 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count != 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) != 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) != 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k <= len(lows):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k <= len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k >= len(lows):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k >= len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k != len(lows):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k != len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length * 2 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length * 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length + 2 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length + 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 2 == 2:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 2:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 2 == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 0:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 2 == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 0:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 2 == -1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == -1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) * 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) * 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) // 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) // 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) - 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) - 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) * 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) * 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if count[num] > highest_count:",
      "mutated_line": "if count[num] >= highest_count:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] >= highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if count[num] > highest_count:",
      "mutated_line": "if count[num] <= highest_count:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] <= highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if count[num] > highest_count:",
      "mutated_line": "if count[num] != highest_count:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] != highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if highest_count == 1:",
      "mutated_line": "if highest_count == 2:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 2:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if highest_count == 1:",
      "mutated_line": "if highest_count == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 0:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if highest_count == 1:",
      "mutated_line": "if highest_count == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 0:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if highest_count == 1:",
      "mutated_line": "if highest_count == -1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == -1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 2:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 2:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 0:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == 0:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 0:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(lst) == 1:",
      "mutated_line": "if len(lst) == -1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == -1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) / 2]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) / 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) * 2]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) * 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k <= len(lows) + len(pivots):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k <= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k >= len(lows) + len(pivots):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k >= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k != len(lows) + len(pivots):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k != len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 3 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 3 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 1 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 1 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 0 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 0 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % 1 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 1 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if lst_length % 2 == 1:",
      "mutated_line": "if lst_length % -2 == 1:",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % -2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length / 2)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length / 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length * 2)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length * 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) - _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) - _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = _quickselect(lst, lst_length // 2) * _quickselect(lst, lst_length // 2 - 1) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = _quickselect(lst, lst_length // 2) * _quickselect(lst, lst_length // 2 - 1) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 3",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 3\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 1\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 0",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 0\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 1\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / -2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / -2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) + 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 2\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) + 0",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 0\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) + 0",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 0\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 0) + -1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + -1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[1]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[-1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[-1]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return lst[0]",
      "mutated_line": "return lst[1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[1]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 3]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 3]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 1]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 0]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 0]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // 1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 1]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pivot = lst[len(lst) // 2]",
      "mutated_line": "pivot = lst[len(lst) // -2]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // -2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [percentage for percentage in lst if percentage < pivot]",
      "mutated_line": "lows = [percentage for percentage in lst if percentage <= pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage <= pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [percentage for percentage in lst if percentage < pivot]",
      "mutated_line": "lows = [percentage for percentage in lst if percentage >= pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage >= pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "lows = [percentage for percentage in lst if percentage < pivot]",
      "mutated_line": "lows = [percentage for percentage in lst if percentage != pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage != pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [percentage for percentage in lst if percentage > pivot]",
      "mutated_line": "highs = [percentage for percentage in lst if percentage >= pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage >= pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [percentage for percentage in lst if percentage > pivot]",
      "mutated_line": "highs = [percentage for percentage in lst if percentage <= pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage <= pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "highs = [percentage for percentage in lst if percentage > pivot]",
      "mutated_line": "highs = [percentage for percentage in lst if percentage != pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage != pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "pivots = [percentage for percentage in lst if percentage == pivot]",
      "mutated_line": "pivots = [percentage for percentage in lst if percentage != pivot]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage != pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k < len(lows) - len(pivots):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) - len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k < len(lows) * len(pivots):",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) * len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length // 3)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 3)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length // 1)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 1)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length // 0)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 0)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length // 1)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 1)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "median = _quickselect(lst, lst_length // 2)",
      "mutated_line": "median = _quickselect(lst, lst_length // -2)",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // -2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 1) + 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 1) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, -1) + 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, -1) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count[num] = count.get(num, 0) + 1",
      "mutated_line": "count[num] = count.get(num, 1) + 1",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 1) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[-1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[-1]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return _quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return _quickselect(highs, k - len(lows) + len(pivots))",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) + len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return _quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return _quickselect(highs, (k - len(lows)) * len(pivots))",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, (k - len(lows)) * len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length / 2) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length / 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length * 2) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length * 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 + 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 + 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 * 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 * 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return _quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return _quickselect(highs, k + len(lows) - len(pivots))",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k + len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return _quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return _quickselect(highs, k * len(lows) - len(pivots))",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k * len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 3) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 3) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 1) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 1) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 0) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 0) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // 1) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 1) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "median = (_quickselect(lst, lst_length // 2) +",
      "mutated_line": "median = (_quickselect(lst, lst_length // -2) + _quickselect(lst, lst_length // 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // -2) + _quickselect(lst, lst_length // 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length / 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length / 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length * 2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length * 2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 2)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 2)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 0)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 0)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 0)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - 0)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - -1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 2 - -1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 3 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 3 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 1 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 1 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 0 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 0 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 1 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // 1 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "_quickselect(lst, lst_length // 2 - 1)) / 2",
      "mutated_line": "median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // -2 - 1)) / 2",
      "code": "def median_and_mode(lst: list):\n    \"\"\"\n    Return a tuple with median and mode of elements in the list lst without sorting it or using built-in functions.\n    Handles even and odd number of elements, negatives, and duplicates.\n    If all elements appear only once, the mode should be `None`.\n    \"\"\"\n\n    def _quickselect(lst: list, k: int):\n        if len(lst) == 1:\n            return lst[0]\n        pivot = lst[len(lst) // 2]\n        lows = [percentage for percentage in lst if percentage < pivot]\n        highs = [percentage for percentage in lst if percentage > pivot]\n        pivots = [percentage for percentage in lst if percentage == pivot]\n        if k < len(lows):\n            return _quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return _quickselect(highs, k - len(lows) - len(pivots))\n    lst_length = len(lst)\n    if lst_length % 2 == 1:\n        median = _quickselect(lst, lst_length // 2)\n    else:\n        median = (_quickselect(lst, lst_length // 2) + _quickselect(lst, lst_length // -2 - 1)) / 2\n    count = {}\n    highest_count = 0\n    mode = None\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n        if count[num] > highest_count:\n            highest_count = count[num]\n            mode = num\n    if highest_count == 1:\n        mode = None\n    return (median, mode)"
    }
  ]
}