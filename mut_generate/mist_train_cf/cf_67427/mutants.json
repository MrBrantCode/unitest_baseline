{
  "task_id": "cf_67427",
  "entry_point": "convert_xml_to_json",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "data['records'] = []",
      "mutated_line": "data[''] = []",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data[''] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for record in xml_root.findall('.//record'):",
      "mutated_line": "for record in xml_root.findall(''):",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall(''):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data[''] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "name = record.attrib['name']",
      "mutated_line": "name = record.attrib['']",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "age = record.attrib['age']",
      "mutated_line": "age = record.attrib['']",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data[''], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "json_object = json.dumps(data, indent = 4)",
      "mutated_line": "json_object = json.dumps(data, indent=5)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=5)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "json_object = json.dumps(data, indent = 4)",
      "mutated_line": "json_object = json.dumps(data, indent=3)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=3)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "json_object = json.dumps(data, indent = 4)",
      "mutated_line": "json_object = json.dumps(data, indent=0)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=0)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "json_object = json.dumps(data, indent = 4)",
      "mutated_line": "json_object = json.dumps(data, indent=1)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=1)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "json_object = json.dumps(data, indent = 4)",
      "mutated_line": "json_object = json.dumps(data, indent=-4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=-4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "street_address = record.find('address').text",
      "mutated_line": "street_address = record.find('').text",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "\"name\": name,",
      "mutated_line": "data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "\"age\": age,",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, '': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "\"street_address\": street_address",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, '': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "data['records'].append({",
      "mutated_line": "data[''].append({'name': name, 'age': age, 'street_address': street_address})",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data[''].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) - len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: ((len(i['name']) + len(i['age'])) * len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) - len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) * len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['street_address']), i['']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['age']) + len(i['']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['']) + len(i['age']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data['records'] = sorted(data['records'], key = lambda i : (len(i['name']) + len(i['age']) + len(i['street_address']), i['name']))",
      "mutated_line": "json_object = json.dumps(data, indent=4)",
      "code": "import xml.etree.ElementTree as ET\nimport json\n\ndef convert_xml_to_json(xml_file_path):\n    \"\"\"\n    This function takes an XML file path as input, converts the XML data to JSON, \n    and returns the JSON string. The function reorders the JSON keys based on the \n    length of their values in a hierarchy and sorts the records alphabetically by \n    the \"name\" attribute. The 'address' element in the XML is abstracted into \n    'street_address' in the JSON output.\n    \"\"\"\n    xml_root = ET.parse(xml_file_path).getroot()\n    data = {}\n    data['records'] = []\n    for record in xml_root.findall('.//record'):\n        name = record.attrib['name']\n        age = record.attrib['age']\n        street_address = record.find('address').text\n        data['records'].append({'name': name, 'age': age, 'street_address': street_address})\n    data['records'] = sorted(data['records'], key=lambda i: (len(i['name']) + len(i['']) + len(i['street_address']), i['name']))\n    json_object = json.dumps(data, indent=4)\n    return json_object"
    }
  ]
}