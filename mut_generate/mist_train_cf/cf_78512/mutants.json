{
  "task_id": "cf_78512",
  "entry_point": "advanced_monotonic",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def advanced_monotonic(l: list, strict: bool = False):",
      "mutated_line": "def advanced_monotonic(l: list, strict: bool=True):",
      "code": "def advanced_monotonic(l: list, strict: bool=True):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "LCR",
      "lineno": 47,
      "original_line": "return increasing or decreasing",
      "mutated_line": "return increasing and decreasing",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing and decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"\"\"Parses an element to a number if possible.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if type(x) == int or type(x) == float:",
      "mutated_line": "if type(x) == int and type(x) == float:",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int and type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if type(x) == int or type(x) == float:",
      "mutated_line": "if type(x) != int or type(x) == float:",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) != int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if type(x) == int or type(x) == float:",
      "mutated_line": "if type(x) == int or type(x) != float:",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) != float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "check_fn = lambda a, b: a < b",
      "mutated_line": "check_fn = lambda a, b: a <= b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a <= b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "check_fn = lambda a, b: a < b",
      "mutated_line": "check_fn = lambda a, b: a >= b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a >= b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "check_fn = lambda a, b: a < b",
      "mutated_line": "check_fn = lambda a, b: a != b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a != b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "check_fn = lambda a, b: a <= b",
      "mutated_line": "check_fn = lambda a, b: a < b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a < b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "check_fn = lambda a, b: a <= b",
      "mutated_line": "check_fn = lambda a, b: a > b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a > b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "check_fn = lambda a, b: a <= b",
      "mutated_line": "check_fn = lambda a, b: a == b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a == b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "check_fn = lambda a, b: a > b",
      "mutated_line": "check_fn = lambda a, b: a >= b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a >= b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "check_fn = lambda a, b: a > b",
      "mutated_line": "check_fn = lambda a, b: a <= b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a <= b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "check_fn = lambda a, b: a > b",
      "mutated_line": "check_fn = lambda a, b: a != b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a != b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "check_fn = lambda a, b: a >= b",
      "mutated_line": "check_fn = lambda a, b: a > b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a > b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "check_fn = lambda a, b: a >= b",
      "mutated_line": "check_fn = lambda a, b: a < b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a < b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "check_fn = lambda a, b: a >= b",
      "mutated_line": "check_fn = lambda a, b: a == b",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a == b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None or b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None or b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None or b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None or b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[2:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[2:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "increasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[-1:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[-1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[2:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[2:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[0:]) if a is not None and b is not None))\n    return increasing or decreasing"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "decreasing = all(check_fn(a, b) for a, b in zip(vals, vals[1:]) if a is not None and b is not None)",
      "mutated_line": "decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[-1:]) if a is not None and b is not None))",
      "code": "def advanced_monotonic(l: list, strict: bool=False):\n    \"\"\"\n    Checks if the elements in a list are monotonically increasing or decreasing.\n\n    Args:\n        l (list): The list of elements to check.\n        strict (bool, optional): Whether the monotonicity should be strict. Defaults to False.\n\n    Returns:\n        bool: True if the list elements are monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n\n    def parse(x):\n        \"\"\"Parses an element to a number if possible.\"\"\"\n        if type(x) == int or type(x) == float:\n            return x\n        if isinstance(x, str):\n            try:\n                return int(x)\n            except ValueError:\n                try:\n                    return float(x)\n                except ValueError:\n                    return None\n        return None\n    vals = [parse(x) for x in l]\n    if strict:\n        check_fn = lambda a, b: a < b\n    else:\n        check_fn = lambda a, b: a <= b\n    increasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[1:]) if a is not None and b is not None))\n    if strict:\n        check_fn = lambda a, b: a > b\n    else:\n        check_fn = lambda a, b: a >= b\n    decreasing = all((check_fn(a, b) for (a, b) in zip(vals, vals[-1:]) if a is not None and b is not None))\n    return increasing or decreasing"
    }
  ]
}