{
  "task_id": "cf_80400",
  "entry_point": "intersperse",
  "mutant_count": 17,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter <= 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter <= 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter >= 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter >= 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter != 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter != 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter < 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 1:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter < -1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < -1:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if delimiter < 0:",
      "mutated_line": "if delimiter < 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 1:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i == len(numbers) - 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i == len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_numbers.append(number * abs(delimiter))",
      "mutated_line": "new_numbers.append(number / abs(delimiter))",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number / abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_numbers.append(number * abs(delimiter))",
      "mutated_line": "new_numbers.append(number + abs(delimiter))",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number + abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_numbers.append(number * abs(delimiter))",
      "mutated_line": "new_numbers.append(number ** abs(delimiter))",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number ** abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) + 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) + 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) * 1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) * 1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) - 2:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 2:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) - 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 0:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) - 0:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - 0:\n                new_numbers.append(delimiter)\n    return new_numbers"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i != len(numbers) - 1:",
      "mutated_line": "if i != len(numbers) - -1:",
      "code": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    This function injects 'delimiter' into the 'numbers' array, between each pair of adjacent elements, \n    and properly handles situations when 'delimiter' is negative.\n    \"\"\"\n    new_numbers = []\n    if delimiter < 0:\n        for number in numbers:\n            new_numbers.append(number * abs(delimiter))\n    else:\n        for i in range(len(numbers)):\n            new_numbers.append(numbers[i])\n            if i != len(numbers) - -1:\n                new_numbers.append(delimiter)\n    return new_numbers"
    }
  ]
}